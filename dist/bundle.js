var jstt = (function (require$$0$1) {
	'use strict';

	var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

	function getAugmentedNamespace(n) {
	  if (n.__esModule) return n;
	  var f = n.default;
		if (typeof f == "function") {
			var a = function a () {
				if (this instanceof a) {
	        return Reflect.construct(f, arguments, this.constructor);
				}
				return f.apply(this, arguments);
			};
			a.prototype = f.prototype;
	  } else a = {};
	  Object.defineProperty(a, '__esModule', {value: true});
		Object.keys(n).forEach(function (k) {
			var d = Object.getOwnPropertyDescriptor(n, k);
			Object.defineProperty(a, k, d.get ? d : {
				enumerable: true,
				get: function () {
					return n[k];
				}
			});
		});
		return a;
	}

	var src$1 = {};

	var global$1 = (typeof global !== "undefined" ? global :
	  typeof self !== "undefined" ? self :
	  typeof window !== "undefined" ? window : {});

	// shim for using process in browser
	// based off https://github.com/defunctzombie/node-process/blob/master/browser.js

	function defaultSetTimout() {
	    throw new Error('setTimeout has not been defined');
	}
	function defaultClearTimeout () {
	    throw new Error('clearTimeout has not been defined');
	}
	var cachedSetTimeout = defaultSetTimout;
	var cachedClearTimeout = defaultClearTimeout;
	if (typeof global$1.setTimeout === 'function') {
	    cachedSetTimeout = setTimeout;
	}
	if (typeof global$1.clearTimeout === 'function') {
	    cachedClearTimeout = clearTimeout;
	}

	function runTimeout(fun) {
	    if (cachedSetTimeout === setTimeout) {
	        //normal enviroments in sane situations
	        return setTimeout(fun, 0);
	    }
	    // if setTimeout wasn't available but was latter defined
	    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
	        cachedSetTimeout = setTimeout;
	        return setTimeout(fun, 0);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedSetTimeout(fun, 0);
	    } catch(e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
	            return cachedSetTimeout.call(null, fun, 0);
	        } catch(e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
	            return cachedSetTimeout.call(this, fun, 0);
	        }
	    }


	}
	function runClearTimeout(marker) {
	    if (cachedClearTimeout === clearTimeout) {
	        //normal enviroments in sane situations
	        return clearTimeout(marker);
	    }
	    // if clearTimeout wasn't available but was latter defined
	    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
	        cachedClearTimeout = clearTimeout;
	        return clearTimeout(marker);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedClearTimeout(marker);
	    } catch (e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
	            return cachedClearTimeout.call(null, marker);
	        } catch (e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
	            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
	            return cachedClearTimeout.call(this, marker);
	        }
	    }



	}
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;

	function cleanUpNextTick() {
	    if (!draining || !currentQueue) {
	        return;
	    }
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}

	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = runTimeout(cleanUpNextTick);
	    draining = true;

	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    runClearTimeout(timeout);
	}
	function nextTick$1(fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        runTimeout(drainQueue);
	    }
	}
	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	var title = 'browser';
	var platform = 'browser';
	var browser = true;
	var env = {};
	var argv = [];
	var version = ''; // empty string to avoid regexp issues
	var versions = {};
	var release = {};
	var config = {};

	function noop$1() {}

	var on = noop$1;
	var addListener = noop$1;
	var once = noop$1;
	var off = noop$1;
	var removeListener = noop$1;
	var removeAllListeners = noop$1;
	var emit = noop$1;

	function binding(name) {
	    throw new Error('process.binding is not supported');
	}

	function cwd () { return '/' }
	function chdir (dir) {
	    throw new Error('process.chdir is not supported');
	}function umask() { return 0; }

	// from https://github.com/kumavis/browser-process-hrtime/blob/master/index.js
	var performance = global$1.performance || {};
	var performanceNow =
	  performance.now        ||
	  performance.mozNow     ||
	  performance.msNow      ||
	  performance.oNow       ||
	  performance.webkitNow  ||
	  function(){ return (new Date()).getTime() };

	// generate timestamp or delta
	// see http://nodejs.org/api/process.html#process_process_hrtime
	function hrtime(previousTimestamp){
	  var clocktime = performanceNow.call(performance)*1e-3;
	  var seconds = Math.floor(clocktime);
	  var nanoseconds = Math.floor((clocktime%1)*1e9);
	  if (previousTimestamp) {
	    seconds = seconds - previousTimestamp[0];
	    nanoseconds = nanoseconds - previousTimestamp[1];
	    if (nanoseconds<0) {
	      seconds--;
	      nanoseconds += 1e9;
	    }
	  }
	  return [seconds,nanoseconds]
	}

	var startTime = new Date();
	function uptime() {
	  var currentTime = new Date();
	  var dif = currentTime - startTime;
	  return dif / 1000;
	}

	var browser$1 = {
	  nextTick: nextTick$1,
	  title: title,
	  browser: browser,
	  env: env,
	  argv: argv,
	  version: version,
	  versions: versions,
	  on: on,
	  addListener: addListener,
	  once: once,
	  off: off,
	  removeListener: removeListener,
	  removeAllListeners: removeAllListeners,
	  emit: emit,
	  binding: binding,
	  cwd: cwd,
	  chdir: chdir,
	  umask: umask,
	  hrtime: hrtime,
	  platform: platform,
	  release: release,
	  config: config,
	  uptime: uptime
	};

	var src = {};

	var _polyfillNode_fs = {};

	var _polyfillNode_fs$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		default: _polyfillNode_fs
	});

	var require$$0 = /*@__PURE__*/getAugmentedNamespace(_polyfillNode_fs$1);

	var lodash = {exports: {}};

	/**
	 * @license
	 * Lodash <https://lodash.com/>
	 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
	 * Released under MIT license <https://lodash.com/license>
	 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
	 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	 */
	lodash.exports;

	(function (module, exports) {
	(function() {

		  /** Used as a safe reference for `undefined` in pre-ES5 environments. */
		  var undefined$1;

		  /** Used as the semantic version number. */
		  var VERSION = '4.17.21';

		  /** Used as the size to enable large array optimizations. */
		  var LARGE_ARRAY_SIZE = 200;

		  /** Error message constants. */
		  var CORE_ERROR_TEXT = 'Unsupported core-js use. Try https://npms.io/search?q=ponyfill.',
		      FUNC_ERROR_TEXT = 'Expected a function',
		      INVALID_TEMPL_VAR_ERROR_TEXT = 'Invalid `variable` option passed into `_.template`';

		  /** Used to stand-in for `undefined` hash values. */
		  var HASH_UNDEFINED = '__lodash_hash_undefined__';

		  /** Used as the maximum memoize cache size. */
		  var MAX_MEMOIZE_SIZE = 500;

		  /** Used as the internal argument placeholder. */
		  var PLACEHOLDER = '__lodash_placeholder__';

		  /** Used to compose bitmasks for cloning. */
		  var CLONE_DEEP_FLAG = 1,
		      CLONE_FLAT_FLAG = 2,
		      CLONE_SYMBOLS_FLAG = 4;

		  /** Used to compose bitmasks for value comparisons. */
		  var COMPARE_PARTIAL_FLAG = 1,
		      COMPARE_UNORDERED_FLAG = 2;

		  /** Used to compose bitmasks for function metadata. */
		  var WRAP_BIND_FLAG = 1,
		      WRAP_BIND_KEY_FLAG = 2,
		      WRAP_CURRY_BOUND_FLAG = 4,
		      WRAP_CURRY_FLAG = 8,
		      WRAP_CURRY_RIGHT_FLAG = 16,
		      WRAP_PARTIAL_FLAG = 32,
		      WRAP_PARTIAL_RIGHT_FLAG = 64,
		      WRAP_ARY_FLAG = 128,
		      WRAP_REARG_FLAG = 256,
		      WRAP_FLIP_FLAG = 512;

		  /** Used as default options for `_.truncate`. */
		  var DEFAULT_TRUNC_LENGTH = 30,
		      DEFAULT_TRUNC_OMISSION = '...';

		  /** Used to detect hot functions by number of calls within a span of milliseconds. */
		  var HOT_COUNT = 800,
		      HOT_SPAN = 16;

		  /** Used to indicate the type of lazy iteratees. */
		  var LAZY_FILTER_FLAG = 1,
		      LAZY_MAP_FLAG = 2,
		      LAZY_WHILE_FLAG = 3;

		  /** Used as references for various `Number` constants. */
		  var INFINITY = 1 / 0,
		      MAX_SAFE_INTEGER = 9007199254740991,
		      MAX_INTEGER = 1.7976931348623157e+308,
		      NAN = 0 / 0;

		  /** Used as references for the maximum length and index of an array. */
		  var MAX_ARRAY_LENGTH = 4294967295,
		      MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1,
		      HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;

		  /** Used to associate wrap methods with their bit flags. */
		  var wrapFlags = [
		    ['ary', WRAP_ARY_FLAG],
		    ['bind', WRAP_BIND_FLAG],
		    ['bindKey', WRAP_BIND_KEY_FLAG],
		    ['curry', WRAP_CURRY_FLAG],
		    ['curryRight', WRAP_CURRY_RIGHT_FLAG],
		    ['flip', WRAP_FLIP_FLAG],
		    ['partial', WRAP_PARTIAL_FLAG],
		    ['partialRight', WRAP_PARTIAL_RIGHT_FLAG],
		    ['rearg', WRAP_REARG_FLAG]
		  ];

		  /** `Object#toString` result references. */
		  var argsTag = '[object Arguments]',
		      arrayTag = '[object Array]',
		      asyncTag = '[object AsyncFunction]',
		      boolTag = '[object Boolean]',
		      dateTag = '[object Date]',
		      domExcTag = '[object DOMException]',
		      errorTag = '[object Error]',
		      funcTag = '[object Function]',
		      genTag = '[object GeneratorFunction]',
		      mapTag = '[object Map]',
		      numberTag = '[object Number]',
		      nullTag = '[object Null]',
		      objectTag = '[object Object]',
		      promiseTag = '[object Promise]',
		      proxyTag = '[object Proxy]',
		      regexpTag = '[object RegExp]',
		      setTag = '[object Set]',
		      stringTag = '[object String]',
		      symbolTag = '[object Symbol]',
		      undefinedTag = '[object Undefined]',
		      weakMapTag = '[object WeakMap]',
		      weakSetTag = '[object WeakSet]';

		  var arrayBufferTag = '[object ArrayBuffer]',
		      dataViewTag = '[object DataView]',
		      float32Tag = '[object Float32Array]',
		      float64Tag = '[object Float64Array]',
		      int8Tag = '[object Int8Array]',
		      int16Tag = '[object Int16Array]',
		      int32Tag = '[object Int32Array]',
		      uint8Tag = '[object Uint8Array]',
		      uint8ClampedTag = '[object Uint8ClampedArray]',
		      uint16Tag = '[object Uint16Array]',
		      uint32Tag = '[object Uint32Array]';

		  /** Used to match empty string literals in compiled template source. */
		  var reEmptyStringLeading = /\b__p \+= '';/g,
		      reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
		      reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;

		  /** Used to match HTML entities and HTML characters. */
		  var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g,
		      reUnescapedHtml = /[&<>"']/g,
		      reHasEscapedHtml = RegExp(reEscapedHtml.source),
		      reHasUnescapedHtml = RegExp(reUnescapedHtml.source);

		  /** Used to match template delimiters. */
		  var reEscape = /<%-([\s\S]+?)%>/g,
		      reEvaluate = /<%([\s\S]+?)%>/g,
		      reInterpolate = /<%=([\s\S]+?)%>/g;

		  /** Used to match property names within property paths. */
		  var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
		      reIsPlainProp = /^\w*$/,
		      rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

		  /**
		   * Used to match `RegExp`
		   * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
		   */
		  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g,
		      reHasRegExpChar = RegExp(reRegExpChar.source);

		  /** Used to match leading whitespace. */
		  var reTrimStart = /^\s+/;

		  /** Used to match a single whitespace character. */
		  var reWhitespace = /\s/;

		  /** Used to match wrap detail comments. */
		  var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/,
		      reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/,
		      reSplitDetails = /,? & /;

		  /** Used to match words composed of alphanumeric characters. */
		  var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;

		  /**
		   * Used to validate the `validate` option in `_.template` variable.
		   *
		   * Forbids characters which could potentially change the meaning of the function argument definition:
		   * - "()," (modification of function parameters)
		   * - "=" (default value)
		   * - "[]{}" (destructuring of function parameters)
		   * - "/" (beginning of a comment)
		   * - whitespace
		   */
		  var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;

		  /** Used to match backslashes in property paths. */
		  var reEscapeChar = /\\(\\)?/g;

		  /**
		   * Used to match
		   * [ES template delimiters](http://ecma-international.org/ecma-262/7.0/#sec-template-literal-lexical-components).
		   */
		  var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;

		  /** Used to match `RegExp` flags from their coerced string values. */
		  var reFlags = /\w*$/;

		  /** Used to detect bad signed hexadecimal string values. */
		  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

		  /** Used to detect binary string values. */
		  var reIsBinary = /^0b[01]+$/i;

		  /** Used to detect host constructors (Safari). */
		  var reIsHostCtor = /^\[object .+?Constructor\]$/;

		  /** Used to detect octal string values. */
		  var reIsOctal = /^0o[0-7]+$/i;

		  /** Used to detect unsigned integer values. */
		  var reIsUint = /^(?:0|[1-9]\d*)$/;

		  /** Used to match Latin Unicode letters (excluding mathematical operators). */
		  var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;

		  /** Used to ensure capturing order of template delimiters. */
		  var reNoMatch = /($^)/;

		  /** Used to match unescaped characters in compiled string literals. */
		  var reUnescapedString = /['\n\r\u2028\u2029\\]/g;

		  /** Used to compose unicode character classes. */
		  var rsAstralRange = '\\ud800-\\udfff',
		      rsComboMarksRange = '\\u0300-\\u036f',
		      reComboHalfMarksRange = '\\ufe20-\\ufe2f',
		      rsComboSymbolsRange = '\\u20d0-\\u20ff',
		      rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,
		      rsDingbatRange = '\\u2700-\\u27bf',
		      rsLowerRange = 'a-z\\xdf-\\xf6\\xf8-\\xff',
		      rsMathOpRange = '\\xac\\xb1\\xd7\\xf7',
		      rsNonCharRange = '\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf',
		      rsPunctuationRange = '\\u2000-\\u206f',
		      rsSpaceRange = ' \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000',
		      rsUpperRange = 'A-Z\\xc0-\\xd6\\xd8-\\xde',
		      rsVarRange = '\\ufe0e\\ufe0f',
		      rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;

		  /** Used to compose unicode capture groups. */
		  var rsApos = "['\u2019]",
		      rsAstral = '[' + rsAstralRange + ']',
		      rsBreak = '[' + rsBreakRange + ']',
		      rsCombo = '[' + rsComboRange + ']',
		      rsDigits = '\\d+',
		      rsDingbat = '[' + rsDingbatRange + ']',
		      rsLower = '[' + rsLowerRange + ']',
		      rsMisc = '[^' + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + ']',
		      rsFitz = '\\ud83c[\\udffb-\\udfff]',
		      rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',
		      rsNonAstral = '[^' + rsAstralRange + ']',
		      rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}',
		      rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]',
		      rsUpper = '[' + rsUpperRange + ']',
		      rsZWJ = '\\u200d';

		  /** Used to compose unicode regexes. */
		  var rsMiscLower = '(?:' + rsLower + '|' + rsMisc + ')',
		      rsMiscUpper = '(?:' + rsUpper + '|' + rsMisc + ')',
		      rsOptContrLower = '(?:' + rsApos + '(?:d|ll|m|re|s|t|ve))?',
		      rsOptContrUpper = '(?:' + rsApos + '(?:D|LL|M|RE|S|T|VE))?',
		      reOptMod = rsModifier + '?',
		      rsOptVar = '[' + rsVarRange + ']?',
		      rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',
		      rsOrdLower = '\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])',
		      rsOrdUpper = '\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])',
		      rsSeq = rsOptVar + reOptMod + rsOptJoin,
		      rsEmoji = '(?:' + [rsDingbat, rsRegional, rsSurrPair].join('|') + ')' + rsSeq,
		      rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';

		  /** Used to match apostrophes. */
		  var reApos = RegExp(rsApos, 'g');

		  /**
		   * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and
		   * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).
		   */
		  var reComboMark = RegExp(rsCombo, 'g');

		  /** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */
		  var reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');

		  /** Used to match complex or compound words. */
		  var reUnicodeWord = RegExp([
		    rsUpper + '?' + rsLower + '+' + rsOptContrLower + '(?=' + [rsBreak, rsUpper, '$'].join('|') + ')',
		    rsMiscUpper + '+' + rsOptContrUpper + '(?=' + [rsBreak, rsUpper + rsMiscLower, '$'].join('|') + ')',
		    rsUpper + '?' + rsMiscLower + '+' + rsOptContrLower,
		    rsUpper + '+' + rsOptContrUpper,
		    rsOrdUpper,
		    rsOrdLower,
		    rsDigits,
		    rsEmoji
		  ].join('|'), 'g');

		  /** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */
		  var reHasUnicode = RegExp('[' + rsZWJ + rsAstralRange  + rsComboRange + rsVarRange + ']');

		  /** Used to detect strings that need a more robust regexp to match words. */
		  var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;

		  /** Used to assign default `context` object properties. */
		  var contextProps = [
		    'Array', 'Buffer', 'DataView', 'Date', 'Error', 'Float32Array', 'Float64Array',
		    'Function', 'Int8Array', 'Int16Array', 'Int32Array', 'Map', 'Math', 'Object',
		    'Promise', 'RegExp', 'Set', 'String', 'Symbol', 'TypeError', 'Uint8Array',
		    'Uint8ClampedArray', 'Uint16Array', 'Uint32Array', 'WeakMap',
		    '_', 'clearTimeout', 'isFinite', 'parseInt', 'setTimeout'
		  ];

		  /** Used to make template sourceURLs easier to identify. */
		  var templateCounter = -1;

		  /** Used to identify `toStringTag` values of typed arrays. */
		  var typedArrayTags = {};
		  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
		  typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
		  typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
		  typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
		  typedArrayTags[uint32Tag] = true;
		  typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
		  typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
		  typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
		  typedArrayTags[errorTag] = typedArrayTags[funcTag] =
		  typedArrayTags[mapTag] = typedArrayTags[numberTag] =
		  typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
		  typedArrayTags[setTag] = typedArrayTags[stringTag] =
		  typedArrayTags[weakMapTag] = false;

		  /** Used to identify `toStringTag` values supported by `_.clone`. */
		  var cloneableTags = {};
		  cloneableTags[argsTag] = cloneableTags[arrayTag] =
		  cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =
		  cloneableTags[boolTag] = cloneableTags[dateTag] =
		  cloneableTags[float32Tag] = cloneableTags[float64Tag] =
		  cloneableTags[int8Tag] = cloneableTags[int16Tag] =
		  cloneableTags[int32Tag] = cloneableTags[mapTag] =
		  cloneableTags[numberTag] = cloneableTags[objectTag] =
		  cloneableTags[regexpTag] = cloneableTags[setTag] =
		  cloneableTags[stringTag] = cloneableTags[symbolTag] =
		  cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
		  cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
		  cloneableTags[errorTag] = cloneableTags[funcTag] =
		  cloneableTags[weakMapTag] = false;

		  /** Used to map Latin Unicode letters to basic Latin letters. */
		  var deburredLetters = {
		    // Latin-1 Supplement block.
		    '\xc0': 'A',  '\xc1': 'A', '\xc2': 'A', '\xc3': 'A', '\xc4': 'A', '\xc5': 'A',
		    '\xe0': 'a',  '\xe1': 'a', '\xe2': 'a', '\xe3': 'a', '\xe4': 'a', '\xe5': 'a',
		    '\xc7': 'C',  '\xe7': 'c',
		    '\xd0': 'D',  '\xf0': 'd',
		    '\xc8': 'E',  '\xc9': 'E', '\xca': 'E', '\xcb': 'E',
		    '\xe8': 'e',  '\xe9': 'e', '\xea': 'e', '\xeb': 'e',
		    '\xcc': 'I',  '\xcd': 'I', '\xce': 'I', '\xcf': 'I',
		    '\xec': 'i',  '\xed': 'i', '\xee': 'i', '\xef': 'i',
		    '\xd1': 'N',  '\xf1': 'n',
		    '\xd2': 'O',  '\xd3': 'O', '\xd4': 'O', '\xd5': 'O', '\xd6': 'O', '\xd8': 'O',
		    '\xf2': 'o',  '\xf3': 'o', '\xf4': 'o', '\xf5': 'o', '\xf6': 'o', '\xf8': 'o',
		    '\xd9': 'U',  '\xda': 'U', '\xdb': 'U', '\xdc': 'U',
		    '\xf9': 'u',  '\xfa': 'u', '\xfb': 'u', '\xfc': 'u',
		    '\xdd': 'Y',  '\xfd': 'y', '\xff': 'y',
		    '\xc6': 'Ae', '\xe6': 'ae',
		    '\xde': 'Th', '\xfe': 'th',
		    '\xdf': 'ss',
		    // Latin Extended-A block.
		    '\u0100': 'A',  '\u0102': 'A', '\u0104': 'A',
		    '\u0101': 'a',  '\u0103': 'a', '\u0105': 'a',
		    '\u0106': 'C',  '\u0108': 'C', '\u010a': 'C', '\u010c': 'C',
		    '\u0107': 'c',  '\u0109': 'c', '\u010b': 'c', '\u010d': 'c',
		    '\u010e': 'D',  '\u0110': 'D', '\u010f': 'd', '\u0111': 'd',
		    '\u0112': 'E',  '\u0114': 'E', '\u0116': 'E', '\u0118': 'E', '\u011a': 'E',
		    '\u0113': 'e',  '\u0115': 'e', '\u0117': 'e', '\u0119': 'e', '\u011b': 'e',
		    '\u011c': 'G',  '\u011e': 'G', '\u0120': 'G', '\u0122': 'G',
		    '\u011d': 'g',  '\u011f': 'g', '\u0121': 'g', '\u0123': 'g',
		    '\u0124': 'H',  '\u0126': 'H', '\u0125': 'h', '\u0127': 'h',
		    '\u0128': 'I',  '\u012a': 'I', '\u012c': 'I', '\u012e': 'I', '\u0130': 'I',
		    '\u0129': 'i',  '\u012b': 'i', '\u012d': 'i', '\u012f': 'i', '\u0131': 'i',
		    '\u0134': 'J',  '\u0135': 'j',
		    '\u0136': 'K',  '\u0137': 'k', '\u0138': 'k',
		    '\u0139': 'L',  '\u013b': 'L', '\u013d': 'L', '\u013f': 'L', '\u0141': 'L',
		    '\u013a': 'l',  '\u013c': 'l', '\u013e': 'l', '\u0140': 'l', '\u0142': 'l',
		    '\u0143': 'N',  '\u0145': 'N', '\u0147': 'N', '\u014a': 'N',
		    '\u0144': 'n',  '\u0146': 'n', '\u0148': 'n', '\u014b': 'n',
		    '\u014c': 'O',  '\u014e': 'O', '\u0150': 'O',
		    '\u014d': 'o',  '\u014f': 'o', '\u0151': 'o',
		    '\u0154': 'R',  '\u0156': 'R', '\u0158': 'R',
		    '\u0155': 'r',  '\u0157': 'r', '\u0159': 'r',
		    '\u015a': 'S',  '\u015c': 'S', '\u015e': 'S', '\u0160': 'S',
		    '\u015b': 's',  '\u015d': 's', '\u015f': 's', '\u0161': 's',
		    '\u0162': 'T',  '\u0164': 'T', '\u0166': 'T',
		    '\u0163': 't',  '\u0165': 't', '\u0167': 't',
		    '\u0168': 'U',  '\u016a': 'U', '\u016c': 'U', '\u016e': 'U', '\u0170': 'U', '\u0172': 'U',
		    '\u0169': 'u',  '\u016b': 'u', '\u016d': 'u', '\u016f': 'u', '\u0171': 'u', '\u0173': 'u',
		    '\u0174': 'W',  '\u0175': 'w',
		    '\u0176': 'Y',  '\u0177': 'y', '\u0178': 'Y',
		    '\u0179': 'Z',  '\u017b': 'Z', '\u017d': 'Z',
		    '\u017a': 'z',  '\u017c': 'z', '\u017e': 'z',
		    '\u0132': 'IJ', '\u0133': 'ij',
		    '\u0152': 'Oe', '\u0153': 'oe',
		    '\u0149': "'n", '\u017f': 's'
		  };

		  /** Used to map characters to HTML entities. */
		  var htmlEscapes = {
		    '&': '&amp;',
		    '<': '&lt;',
		    '>': '&gt;',
		    '"': '&quot;',
		    "'": '&#39;'
		  };

		  /** Used to map HTML entities to characters. */
		  var htmlUnescapes = {
		    '&amp;': '&',
		    '&lt;': '<',
		    '&gt;': '>',
		    '&quot;': '"',
		    '&#39;': "'"
		  };

		  /** Used to escape characters for inclusion in compiled string literals. */
		  var stringEscapes = {
		    '\\': '\\',
		    "'": "'",
		    '\n': 'n',
		    '\r': 'r',
		    '\u2028': 'u2028',
		    '\u2029': 'u2029'
		  };

		  /** Built-in method references without a dependency on `root`. */
		  var freeParseFloat = parseFloat,
		      freeParseInt = parseInt;

		  /** Detect free variable `global` from Node.js. */
		  var freeGlobal = typeof commonjsGlobal == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;

		  /** Detect free variable `self`. */
		  var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

		  /** Used as a reference to the global object. */
		  var root = freeGlobal || freeSelf || Function('return this')();

		  /** Detect free variable `exports`. */
		  var freeExports = exports && !exports.nodeType && exports;

		  /** Detect free variable `module`. */
		  var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;

		  /** Detect the popular CommonJS extension `module.exports`. */
		  var moduleExports = freeModule && freeModule.exports === freeExports;

		  /** Detect free variable `process` from Node.js. */
		  var freeProcess = moduleExports && freeGlobal.process;

		  /** Used to access faster Node.js helpers. */
		  var nodeUtil = (function() {
		    try {
		      // Use `util.types` for Node.js 10+.
		      var types = freeModule && freeModule.require && freeModule.require('util').types;

		      if (types) {
		        return types;
		      }

		      // Legacy `process.binding('util')` for Node.js < 10.
		      return freeProcess && freeProcess.binding && freeProcess.binding('util');
		    } catch (e) {}
		  }());

		  /* Node.js helper references. */
		  var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer,
		      nodeIsDate = nodeUtil && nodeUtil.isDate,
		      nodeIsMap = nodeUtil && nodeUtil.isMap,
		      nodeIsRegExp = nodeUtil && nodeUtil.isRegExp,
		      nodeIsSet = nodeUtil && nodeUtil.isSet,
		      nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

		  /*--------------------------------------------------------------------------*/

		  /**
		   * A faster alternative to `Function#apply`, this function invokes `func`
		   * with the `this` binding of `thisArg` and the arguments of `args`.
		   *
		   * @private
		   * @param {Function} func The function to invoke.
		   * @param {*} thisArg The `this` binding of `func`.
		   * @param {Array} args The arguments to invoke `func` with.
		   * @returns {*} Returns the result of `func`.
		   */
		  function apply(func, thisArg, args) {
		    switch (args.length) {
		      case 0: return func.call(thisArg);
		      case 1: return func.call(thisArg, args[0]);
		      case 2: return func.call(thisArg, args[0], args[1]);
		      case 3: return func.call(thisArg, args[0], args[1], args[2]);
		    }
		    return func.apply(thisArg, args);
		  }

		  /**
		   * A specialized version of `baseAggregator` for arrays.
		   *
		   * @private
		   * @param {Array} [array] The array to iterate over.
		   * @param {Function} setter The function to set `accumulator` values.
		   * @param {Function} iteratee The iteratee to transform keys.
		   * @param {Object} accumulator The initial aggregated object.
		   * @returns {Function} Returns `accumulator`.
		   */
		  function arrayAggregator(array, setter, iteratee, accumulator) {
		    var index = -1,
		        length = array == null ? 0 : array.length;

		    while (++index < length) {
		      var value = array[index];
		      setter(accumulator, value, iteratee(value), array);
		    }
		    return accumulator;
		  }

		  /**
		   * A specialized version of `_.forEach` for arrays without support for
		   * iteratee shorthands.
		   *
		   * @private
		   * @param {Array} [array] The array to iterate over.
		   * @param {Function} iteratee The function invoked per iteration.
		   * @returns {Array} Returns `array`.
		   */
		  function arrayEach(array, iteratee) {
		    var index = -1,
		        length = array == null ? 0 : array.length;

		    while (++index < length) {
		      if (iteratee(array[index], index, array) === false) {
		        break;
		      }
		    }
		    return array;
		  }

		  /**
		   * A specialized version of `_.forEachRight` for arrays without support for
		   * iteratee shorthands.
		   *
		   * @private
		   * @param {Array} [array] The array to iterate over.
		   * @param {Function} iteratee The function invoked per iteration.
		   * @returns {Array} Returns `array`.
		   */
		  function arrayEachRight(array, iteratee) {
		    var length = array == null ? 0 : array.length;

		    while (length--) {
		      if (iteratee(array[length], length, array) === false) {
		        break;
		      }
		    }
		    return array;
		  }

		  /**
		   * A specialized version of `_.every` for arrays without support for
		   * iteratee shorthands.
		   *
		   * @private
		   * @param {Array} [array] The array to iterate over.
		   * @param {Function} predicate The function invoked per iteration.
		   * @returns {boolean} Returns `true` if all elements pass the predicate check,
		   *  else `false`.
		   */
		  function arrayEvery(array, predicate) {
		    var index = -1,
		        length = array == null ? 0 : array.length;

		    while (++index < length) {
		      if (!predicate(array[index], index, array)) {
		        return false;
		      }
		    }
		    return true;
		  }

		  /**
		   * A specialized version of `_.filter` for arrays without support for
		   * iteratee shorthands.
		   *
		   * @private
		   * @param {Array} [array] The array to iterate over.
		   * @param {Function} predicate The function invoked per iteration.
		   * @returns {Array} Returns the new filtered array.
		   */
		  function arrayFilter(array, predicate) {
		    var index = -1,
		        length = array == null ? 0 : array.length,
		        resIndex = 0,
		        result = [];

		    while (++index < length) {
		      var value = array[index];
		      if (predicate(value, index, array)) {
		        result[resIndex++] = value;
		      }
		    }
		    return result;
		  }

		  /**
		   * A specialized version of `_.includes` for arrays without support for
		   * specifying an index to search from.
		   *
		   * @private
		   * @param {Array} [array] The array to inspect.
		   * @param {*} target The value to search for.
		   * @returns {boolean} Returns `true` if `target` is found, else `false`.
		   */
		  function arrayIncludes(array, value) {
		    var length = array == null ? 0 : array.length;
		    return !!length && baseIndexOf(array, value, 0) > -1;
		  }

		  /**
		   * This function is like `arrayIncludes` except that it accepts a comparator.
		   *
		   * @private
		   * @param {Array} [array] The array to inspect.
		   * @param {*} target The value to search for.
		   * @param {Function} comparator The comparator invoked per element.
		   * @returns {boolean} Returns `true` if `target` is found, else `false`.
		   */
		  function arrayIncludesWith(array, value, comparator) {
		    var index = -1,
		        length = array == null ? 0 : array.length;

		    while (++index < length) {
		      if (comparator(value, array[index])) {
		        return true;
		      }
		    }
		    return false;
		  }

		  /**
		   * A specialized version of `_.map` for arrays without support for iteratee
		   * shorthands.
		   *
		   * @private
		   * @param {Array} [array] The array to iterate over.
		   * @param {Function} iteratee The function invoked per iteration.
		   * @returns {Array} Returns the new mapped array.
		   */
		  function arrayMap(array, iteratee) {
		    var index = -1,
		        length = array == null ? 0 : array.length,
		        result = Array(length);

		    while (++index < length) {
		      result[index] = iteratee(array[index], index, array);
		    }
		    return result;
		  }

		  /**
		   * Appends the elements of `values` to `array`.
		   *
		   * @private
		   * @param {Array} array The array to modify.
		   * @param {Array} values The values to append.
		   * @returns {Array} Returns `array`.
		   */
		  function arrayPush(array, values) {
		    var index = -1,
		        length = values.length,
		        offset = array.length;

		    while (++index < length) {
		      array[offset + index] = values[index];
		    }
		    return array;
		  }

		  /**
		   * A specialized version of `_.reduce` for arrays without support for
		   * iteratee shorthands.
		   *
		   * @private
		   * @param {Array} [array] The array to iterate over.
		   * @param {Function} iteratee The function invoked per iteration.
		   * @param {*} [accumulator] The initial value.
		   * @param {boolean} [initAccum] Specify using the first element of `array` as
		   *  the initial value.
		   * @returns {*} Returns the accumulated value.
		   */
		  function arrayReduce(array, iteratee, accumulator, initAccum) {
		    var index = -1,
		        length = array == null ? 0 : array.length;

		    if (initAccum && length) {
		      accumulator = array[++index];
		    }
		    while (++index < length) {
		      accumulator = iteratee(accumulator, array[index], index, array);
		    }
		    return accumulator;
		  }

		  /**
		   * A specialized version of `_.reduceRight` for arrays without support for
		   * iteratee shorthands.
		   *
		   * @private
		   * @param {Array} [array] The array to iterate over.
		   * @param {Function} iteratee The function invoked per iteration.
		   * @param {*} [accumulator] The initial value.
		   * @param {boolean} [initAccum] Specify using the last element of `array` as
		   *  the initial value.
		   * @returns {*} Returns the accumulated value.
		   */
		  function arrayReduceRight(array, iteratee, accumulator, initAccum) {
		    var length = array == null ? 0 : array.length;
		    if (initAccum && length) {
		      accumulator = array[--length];
		    }
		    while (length--) {
		      accumulator = iteratee(accumulator, array[length], length, array);
		    }
		    return accumulator;
		  }

		  /**
		   * A specialized version of `_.some` for arrays without support for iteratee
		   * shorthands.
		   *
		   * @private
		   * @param {Array} [array] The array to iterate over.
		   * @param {Function} predicate The function invoked per iteration.
		   * @returns {boolean} Returns `true` if any element passes the predicate check,
		   *  else `false`.
		   */
		  function arraySome(array, predicate) {
		    var index = -1,
		        length = array == null ? 0 : array.length;

		    while (++index < length) {
		      if (predicate(array[index], index, array)) {
		        return true;
		      }
		    }
		    return false;
		  }

		  /**
		   * Gets the size of an ASCII `string`.
		   *
		   * @private
		   * @param {string} string The string inspect.
		   * @returns {number} Returns the string size.
		   */
		  var asciiSize = baseProperty('length');

		  /**
		   * Converts an ASCII `string` to an array.
		   *
		   * @private
		   * @param {string} string The string to convert.
		   * @returns {Array} Returns the converted array.
		   */
		  function asciiToArray(string) {
		    return string.split('');
		  }

		  /**
		   * Splits an ASCII `string` into an array of its words.
		   *
		   * @private
		   * @param {string} The string to inspect.
		   * @returns {Array} Returns the words of `string`.
		   */
		  function asciiWords(string) {
		    return string.match(reAsciiWord) || [];
		  }

		  /**
		   * The base implementation of methods like `_.findKey` and `_.findLastKey`,
		   * without support for iteratee shorthands, which iterates over `collection`
		   * using `eachFunc`.
		   *
		   * @private
		   * @param {Array|Object} collection The collection to inspect.
		   * @param {Function} predicate The function invoked per iteration.
		   * @param {Function} eachFunc The function to iterate over `collection`.
		   * @returns {*} Returns the found element or its key, else `undefined`.
		   */
		  function baseFindKey(collection, predicate, eachFunc) {
		    var result;
		    eachFunc(collection, function(value, key, collection) {
		      if (predicate(value, key, collection)) {
		        result = key;
		        return false;
		      }
		    });
		    return result;
		  }

		  /**
		   * The base implementation of `_.findIndex` and `_.findLastIndex` without
		   * support for iteratee shorthands.
		   *
		   * @private
		   * @param {Array} array The array to inspect.
		   * @param {Function} predicate The function invoked per iteration.
		   * @param {number} fromIndex The index to search from.
		   * @param {boolean} [fromRight] Specify iterating from right to left.
		   * @returns {number} Returns the index of the matched value, else `-1`.
		   */
		  function baseFindIndex(array, predicate, fromIndex, fromRight) {
		    var length = array.length,
		        index = fromIndex + (fromRight ? 1 : -1);

		    while ((fromRight ? index-- : ++index < length)) {
		      if (predicate(array[index], index, array)) {
		        return index;
		      }
		    }
		    return -1;
		  }

		  /**
		   * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
		   *
		   * @private
		   * @param {Array} array The array to inspect.
		   * @param {*} value The value to search for.
		   * @param {number} fromIndex The index to search from.
		   * @returns {number} Returns the index of the matched value, else `-1`.
		   */
		  function baseIndexOf(array, value, fromIndex) {
		    return value === value
		      ? strictIndexOf(array, value, fromIndex)
		      : baseFindIndex(array, baseIsNaN, fromIndex);
		  }

		  /**
		   * This function is like `baseIndexOf` except that it accepts a comparator.
		   *
		   * @private
		   * @param {Array} array The array to inspect.
		   * @param {*} value The value to search for.
		   * @param {number} fromIndex The index to search from.
		   * @param {Function} comparator The comparator invoked per element.
		   * @returns {number} Returns the index of the matched value, else `-1`.
		   */
		  function baseIndexOfWith(array, value, fromIndex, comparator) {
		    var index = fromIndex - 1,
		        length = array.length;

		    while (++index < length) {
		      if (comparator(array[index], value)) {
		        return index;
		      }
		    }
		    return -1;
		  }

		  /**
		   * The base implementation of `_.isNaN` without support for number objects.
		   *
		   * @private
		   * @param {*} value The value to check.
		   * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
		   */
		  function baseIsNaN(value) {
		    return value !== value;
		  }

		  /**
		   * The base implementation of `_.mean` and `_.meanBy` without support for
		   * iteratee shorthands.
		   *
		   * @private
		   * @param {Array} array The array to iterate over.
		   * @param {Function} iteratee The function invoked per iteration.
		   * @returns {number} Returns the mean.
		   */
		  function baseMean(array, iteratee) {
		    var length = array == null ? 0 : array.length;
		    return length ? (baseSum(array, iteratee) / length) : NAN;
		  }

		  /**
		   * The base implementation of `_.property` without support for deep paths.
		   *
		   * @private
		   * @param {string} key The key of the property to get.
		   * @returns {Function} Returns the new accessor function.
		   */
		  function baseProperty(key) {
		    return function(object) {
		      return object == null ? undefined$1 : object[key];
		    };
		  }

		  /**
		   * The base implementation of `_.propertyOf` without support for deep paths.
		   *
		   * @private
		   * @param {Object} object The object to query.
		   * @returns {Function} Returns the new accessor function.
		   */
		  function basePropertyOf(object) {
		    return function(key) {
		      return object == null ? undefined$1 : object[key];
		    };
		  }

		  /**
		   * The base implementation of `_.reduce` and `_.reduceRight`, without support
		   * for iteratee shorthands, which iterates over `collection` using `eachFunc`.
		   *
		   * @private
		   * @param {Array|Object} collection The collection to iterate over.
		   * @param {Function} iteratee The function invoked per iteration.
		   * @param {*} accumulator The initial value.
		   * @param {boolean} initAccum Specify using the first or last element of
		   *  `collection` as the initial value.
		   * @param {Function} eachFunc The function to iterate over `collection`.
		   * @returns {*} Returns the accumulated value.
		   */
		  function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
		    eachFunc(collection, function(value, index, collection) {
		      accumulator = initAccum
		        ? (initAccum = false, value)
		        : iteratee(accumulator, value, index, collection);
		    });
		    return accumulator;
		  }

		  /**
		   * The base implementation of `_.sortBy` which uses `comparer` to define the
		   * sort order of `array` and replaces criteria objects with their corresponding
		   * values.
		   *
		   * @private
		   * @param {Array} array The array to sort.
		   * @param {Function} comparer The function to define sort order.
		   * @returns {Array} Returns `array`.
		   */
		  function baseSortBy(array, comparer) {
		    var length = array.length;

		    array.sort(comparer);
		    while (length--) {
		      array[length] = array[length].value;
		    }
		    return array;
		  }

		  /**
		   * The base implementation of `_.sum` and `_.sumBy` without support for
		   * iteratee shorthands.
		   *
		   * @private
		   * @param {Array} array The array to iterate over.
		   * @param {Function} iteratee The function invoked per iteration.
		   * @returns {number} Returns the sum.
		   */
		  function baseSum(array, iteratee) {
		    var result,
		        index = -1,
		        length = array.length;

		    while (++index < length) {
		      var current = iteratee(array[index]);
		      if (current !== undefined$1) {
		        result = result === undefined$1 ? current : (result + current);
		      }
		    }
		    return result;
		  }

		  /**
		   * The base implementation of `_.times` without support for iteratee shorthands
		   * or max array length checks.
		   *
		   * @private
		   * @param {number} n The number of times to invoke `iteratee`.
		   * @param {Function} iteratee The function invoked per iteration.
		   * @returns {Array} Returns the array of results.
		   */
		  function baseTimes(n, iteratee) {
		    var index = -1,
		        result = Array(n);

		    while (++index < n) {
		      result[index] = iteratee(index);
		    }
		    return result;
		  }

		  /**
		   * The base implementation of `_.toPairs` and `_.toPairsIn` which creates an array
		   * of key-value pairs for `object` corresponding to the property names of `props`.
		   *
		   * @private
		   * @param {Object} object The object to query.
		   * @param {Array} props The property names to get values for.
		   * @returns {Object} Returns the key-value pairs.
		   */
		  function baseToPairs(object, props) {
		    return arrayMap(props, function(key) {
		      return [key, object[key]];
		    });
		  }

		  /**
		   * The base implementation of `_.trim`.
		   *
		   * @private
		   * @param {string} string The string to trim.
		   * @returns {string} Returns the trimmed string.
		   */
		  function baseTrim(string) {
		    return string
		      ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, '')
		      : string;
		  }

		  /**
		   * The base implementation of `_.unary` without support for storing metadata.
		   *
		   * @private
		   * @param {Function} func The function to cap arguments for.
		   * @returns {Function} Returns the new capped function.
		   */
		  function baseUnary(func) {
		    return function(value) {
		      return func(value);
		    };
		  }

		  /**
		   * The base implementation of `_.values` and `_.valuesIn` which creates an
		   * array of `object` property values corresponding to the property names
		   * of `props`.
		   *
		   * @private
		   * @param {Object} object The object to query.
		   * @param {Array} props The property names to get values for.
		   * @returns {Object} Returns the array of property values.
		   */
		  function baseValues(object, props) {
		    return arrayMap(props, function(key) {
		      return object[key];
		    });
		  }

		  /**
		   * Checks if a `cache` value for `key` exists.
		   *
		   * @private
		   * @param {Object} cache The cache to query.
		   * @param {string} key The key of the entry to check.
		   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
		   */
		  function cacheHas(cache, key) {
		    return cache.has(key);
		  }

		  /**
		   * Used by `_.trim` and `_.trimStart` to get the index of the first string symbol
		   * that is not found in the character symbols.
		   *
		   * @private
		   * @param {Array} strSymbols The string symbols to inspect.
		   * @param {Array} chrSymbols The character symbols to find.
		   * @returns {number} Returns the index of the first unmatched string symbol.
		   */
		  function charsStartIndex(strSymbols, chrSymbols) {
		    var index = -1,
		        length = strSymbols.length;

		    while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}
		    return index;
		  }

		  /**
		   * Used by `_.trim` and `_.trimEnd` to get the index of the last string symbol
		   * that is not found in the character symbols.
		   *
		   * @private
		   * @param {Array} strSymbols The string symbols to inspect.
		   * @param {Array} chrSymbols The character symbols to find.
		   * @returns {number} Returns the index of the last unmatched string symbol.
		   */
		  function charsEndIndex(strSymbols, chrSymbols) {
		    var index = strSymbols.length;

		    while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}
		    return index;
		  }

		  /**
		   * Gets the number of `placeholder` occurrences in `array`.
		   *
		   * @private
		   * @param {Array} array The array to inspect.
		   * @param {*} placeholder The placeholder to search for.
		   * @returns {number} Returns the placeholder count.
		   */
		  function countHolders(array, placeholder) {
		    var length = array.length,
		        result = 0;

		    while (length--) {
		      if (array[length] === placeholder) {
		        ++result;
		      }
		    }
		    return result;
		  }

		  /**
		   * Used by `_.deburr` to convert Latin-1 Supplement and Latin Extended-A
		   * letters to basic Latin letters.
		   *
		   * @private
		   * @param {string} letter The matched letter to deburr.
		   * @returns {string} Returns the deburred letter.
		   */
		  var deburrLetter = basePropertyOf(deburredLetters);

		  /**
		   * Used by `_.escape` to convert characters to HTML entities.
		   *
		   * @private
		   * @param {string} chr The matched character to escape.
		   * @returns {string} Returns the escaped character.
		   */
		  var escapeHtmlChar = basePropertyOf(htmlEscapes);

		  /**
		   * Used by `_.template` to escape characters for inclusion in compiled string literals.
		   *
		   * @private
		   * @param {string} chr The matched character to escape.
		   * @returns {string} Returns the escaped character.
		   */
		  function escapeStringChar(chr) {
		    return '\\' + stringEscapes[chr];
		  }

		  /**
		   * Gets the value at `key` of `object`.
		   *
		   * @private
		   * @param {Object} [object] The object to query.
		   * @param {string} key The key of the property to get.
		   * @returns {*} Returns the property value.
		   */
		  function getValue(object, key) {
		    return object == null ? undefined$1 : object[key];
		  }

		  /**
		   * Checks if `string` contains Unicode symbols.
		   *
		   * @private
		   * @param {string} string The string to inspect.
		   * @returns {boolean} Returns `true` if a symbol is found, else `false`.
		   */
		  function hasUnicode(string) {
		    return reHasUnicode.test(string);
		  }

		  /**
		   * Checks if `string` contains a word composed of Unicode symbols.
		   *
		   * @private
		   * @param {string} string The string to inspect.
		   * @returns {boolean} Returns `true` if a word is found, else `false`.
		   */
		  function hasUnicodeWord(string) {
		    return reHasUnicodeWord.test(string);
		  }

		  /**
		   * Converts `iterator` to an array.
		   *
		   * @private
		   * @param {Object} iterator The iterator to convert.
		   * @returns {Array} Returns the converted array.
		   */
		  function iteratorToArray(iterator) {
		    var data,
		        result = [];

		    while (!(data = iterator.next()).done) {
		      result.push(data.value);
		    }
		    return result;
		  }

		  /**
		   * Converts `map` to its key-value pairs.
		   *
		   * @private
		   * @param {Object} map The map to convert.
		   * @returns {Array} Returns the key-value pairs.
		   */
		  function mapToArray(map) {
		    var index = -1,
		        result = Array(map.size);

		    map.forEach(function(value, key) {
		      result[++index] = [key, value];
		    });
		    return result;
		  }

		  /**
		   * Creates a unary function that invokes `func` with its argument transformed.
		   *
		   * @private
		   * @param {Function} func The function to wrap.
		   * @param {Function} transform The argument transform.
		   * @returns {Function} Returns the new function.
		   */
		  function overArg(func, transform) {
		    return function(arg) {
		      return func(transform(arg));
		    };
		  }

		  /**
		   * Replaces all `placeholder` elements in `array` with an internal placeholder
		   * and returns an array of their indexes.
		   *
		   * @private
		   * @param {Array} array The array to modify.
		   * @param {*} placeholder The placeholder to replace.
		   * @returns {Array} Returns the new array of placeholder indexes.
		   */
		  function replaceHolders(array, placeholder) {
		    var index = -1,
		        length = array.length,
		        resIndex = 0,
		        result = [];

		    while (++index < length) {
		      var value = array[index];
		      if (value === placeholder || value === PLACEHOLDER) {
		        array[index] = PLACEHOLDER;
		        result[resIndex++] = index;
		      }
		    }
		    return result;
		  }

		  /**
		   * Converts `set` to an array of its values.
		   *
		   * @private
		   * @param {Object} set The set to convert.
		   * @returns {Array} Returns the values.
		   */
		  function setToArray(set) {
		    var index = -1,
		        result = Array(set.size);

		    set.forEach(function(value) {
		      result[++index] = value;
		    });
		    return result;
		  }

		  /**
		   * Converts `set` to its value-value pairs.
		   *
		   * @private
		   * @param {Object} set The set to convert.
		   * @returns {Array} Returns the value-value pairs.
		   */
		  function setToPairs(set) {
		    var index = -1,
		        result = Array(set.size);

		    set.forEach(function(value) {
		      result[++index] = [value, value];
		    });
		    return result;
		  }

		  /**
		   * A specialized version of `_.indexOf` which performs strict equality
		   * comparisons of values, i.e. `===`.
		   *
		   * @private
		   * @param {Array} array The array to inspect.
		   * @param {*} value The value to search for.
		   * @param {number} fromIndex The index to search from.
		   * @returns {number} Returns the index of the matched value, else `-1`.
		   */
		  function strictIndexOf(array, value, fromIndex) {
		    var index = fromIndex - 1,
		        length = array.length;

		    while (++index < length) {
		      if (array[index] === value) {
		        return index;
		      }
		    }
		    return -1;
		  }

		  /**
		   * A specialized version of `_.lastIndexOf` which performs strict equality
		   * comparisons of values, i.e. `===`.
		   *
		   * @private
		   * @param {Array} array The array to inspect.
		   * @param {*} value The value to search for.
		   * @param {number} fromIndex The index to search from.
		   * @returns {number} Returns the index of the matched value, else `-1`.
		   */
		  function strictLastIndexOf(array, value, fromIndex) {
		    var index = fromIndex + 1;
		    while (index--) {
		      if (array[index] === value) {
		        return index;
		      }
		    }
		    return index;
		  }

		  /**
		   * Gets the number of symbols in `string`.
		   *
		   * @private
		   * @param {string} string The string to inspect.
		   * @returns {number} Returns the string size.
		   */
		  function stringSize(string) {
		    return hasUnicode(string)
		      ? unicodeSize(string)
		      : asciiSize(string);
		  }

		  /**
		   * Converts `string` to an array.
		   *
		   * @private
		   * @param {string} string The string to convert.
		   * @returns {Array} Returns the converted array.
		   */
		  function stringToArray(string) {
		    return hasUnicode(string)
		      ? unicodeToArray(string)
		      : asciiToArray(string);
		  }

		  /**
		   * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace
		   * character of `string`.
		   *
		   * @private
		   * @param {string} string The string to inspect.
		   * @returns {number} Returns the index of the last non-whitespace character.
		   */
		  function trimmedEndIndex(string) {
		    var index = string.length;

		    while (index-- && reWhitespace.test(string.charAt(index))) {}
		    return index;
		  }

		  /**
		   * Used by `_.unescape` to convert HTML entities to characters.
		   *
		   * @private
		   * @param {string} chr The matched character to unescape.
		   * @returns {string} Returns the unescaped character.
		   */
		  var unescapeHtmlChar = basePropertyOf(htmlUnescapes);

		  /**
		   * Gets the size of a Unicode `string`.
		   *
		   * @private
		   * @param {string} string The string inspect.
		   * @returns {number} Returns the string size.
		   */
		  function unicodeSize(string) {
		    var result = reUnicode.lastIndex = 0;
		    while (reUnicode.test(string)) {
		      ++result;
		    }
		    return result;
		  }

		  /**
		   * Converts a Unicode `string` to an array.
		   *
		   * @private
		   * @param {string} string The string to convert.
		   * @returns {Array} Returns the converted array.
		   */
		  function unicodeToArray(string) {
		    return string.match(reUnicode) || [];
		  }

		  /**
		   * Splits a Unicode `string` into an array of its words.
		   *
		   * @private
		   * @param {string} The string to inspect.
		   * @returns {Array} Returns the words of `string`.
		   */
		  function unicodeWords(string) {
		    return string.match(reUnicodeWord) || [];
		  }

		  /*--------------------------------------------------------------------------*/

		  /**
		   * Create a new pristine `lodash` function using the `context` object.
		   *
		   * @static
		   * @memberOf _
		   * @since 1.1.0
		   * @category Util
		   * @param {Object} [context=root] The context object.
		   * @returns {Function} Returns a new `lodash` function.
		   * @example
		   *
		   * _.mixin({ 'foo': _.constant('foo') });
		   *
		   * var lodash = _.runInContext();
		   * lodash.mixin({ 'bar': lodash.constant('bar') });
		   *
		   * _.isFunction(_.foo);
		   * // => true
		   * _.isFunction(_.bar);
		   * // => false
		   *
		   * lodash.isFunction(lodash.foo);
		   * // => false
		   * lodash.isFunction(lodash.bar);
		   * // => true
		   *
		   * // Create a suped-up `defer` in Node.js.
		   * var defer = _.runInContext({ 'setTimeout': setImmediate }).defer;
		   */
		  var runInContext = (function runInContext(context) {
		    context = context == null ? root : _.defaults(root.Object(), context, _.pick(root, contextProps));

		    /** Built-in constructor references. */
		    var Array = context.Array,
		        Date = context.Date,
		        Error = context.Error,
		        Function = context.Function,
		        Math = context.Math,
		        Object = context.Object,
		        RegExp = context.RegExp,
		        String = context.String,
		        TypeError = context.TypeError;

		    /** Used for built-in method references. */
		    var arrayProto = Array.prototype,
		        funcProto = Function.prototype,
		        objectProto = Object.prototype;

		    /** Used to detect overreaching core-js shims. */
		    var coreJsData = context['__core-js_shared__'];

		    /** Used to resolve the decompiled source of functions. */
		    var funcToString = funcProto.toString;

		    /** Used to check objects for own properties. */
		    var hasOwnProperty = objectProto.hasOwnProperty;

		    /** Used to generate unique IDs. */
		    var idCounter = 0;

		    /** Used to detect methods masquerading as native. */
		    var maskSrcKey = (function() {
		      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
		      return uid ? ('Symbol(src)_1.' + uid) : '';
		    }());

		    /**
		     * Used to resolve the
		     * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
		     * of values.
		     */
		    var nativeObjectToString = objectProto.toString;

		    /** Used to infer the `Object` constructor. */
		    var objectCtorString = funcToString.call(Object);

		    /** Used to restore the original `_` reference in `_.noConflict`. */
		    var oldDash = root._;

		    /** Used to detect if a method is native. */
		    var reIsNative = RegExp('^' +
		      funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
		      .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
		    );

		    /** Built-in value references. */
		    var Buffer = moduleExports ? context.Buffer : undefined$1,
		        Symbol = context.Symbol,
		        Uint8Array = context.Uint8Array,
		        allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined$1,
		        getPrototype = overArg(Object.getPrototypeOf, Object),
		        objectCreate = Object.create,
		        propertyIsEnumerable = objectProto.propertyIsEnumerable,
		        splice = arrayProto.splice,
		        spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined$1,
		        symIterator = Symbol ? Symbol.iterator : undefined$1,
		        symToStringTag = Symbol ? Symbol.toStringTag : undefined$1;

		    var defineProperty = (function() {
		      try {
		        var func = getNative(Object, 'defineProperty');
		        func({}, '', {});
		        return func;
		      } catch (e) {}
		    }());

		    /** Mocked built-ins. */
		    var ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout,
		        ctxNow = Date && Date.now !== root.Date.now && Date.now,
		        ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout;

		    /* Built-in method references for those with the same name as other `lodash` methods. */
		    var nativeCeil = Math.ceil,
		        nativeFloor = Math.floor,
		        nativeGetSymbols = Object.getOwnPropertySymbols,
		        nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined$1,
		        nativeIsFinite = context.isFinite,
		        nativeJoin = arrayProto.join,
		        nativeKeys = overArg(Object.keys, Object),
		        nativeMax = Math.max,
		        nativeMin = Math.min,
		        nativeNow = Date.now,
		        nativeParseInt = context.parseInt,
		        nativeRandom = Math.random,
		        nativeReverse = arrayProto.reverse;

		    /* Built-in method references that are verified to be native. */
		    var DataView = getNative(context, 'DataView'),
		        Map = getNative(context, 'Map'),
		        Promise = getNative(context, 'Promise'),
		        Set = getNative(context, 'Set'),
		        WeakMap = getNative(context, 'WeakMap'),
		        nativeCreate = getNative(Object, 'create');

		    /** Used to store function metadata. */
		    var metaMap = WeakMap && new WeakMap;

		    /** Used to lookup unminified function names. */
		    var realNames = {};

		    /** Used to detect maps, sets, and weakmaps. */
		    var dataViewCtorString = toSource(DataView),
		        mapCtorString = toSource(Map),
		        promiseCtorString = toSource(Promise),
		        setCtorString = toSource(Set),
		        weakMapCtorString = toSource(WeakMap);

		    /** Used to convert symbols to primitives and strings. */
		    var symbolProto = Symbol ? Symbol.prototype : undefined$1,
		        symbolValueOf = symbolProto ? symbolProto.valueOf : undefined$1,
		        symbolToString = symbolProto ? symbolProto.toString : undefined$1;

		    /*------------------------------------------------------------------------*/

		    /**
		     * Creates a `lodash` object which wraps `value` to enable implicit method
		     * chain sequences. Methods that operate on and return arrays, collections,
		     * and functions can be chained together. Methods that retrieve a single value
		     * or may return a primitive value will automatically end the chain sequence
		     * and return the unwrapped value. Otherwise, the value must be unwrapped
		     * with `_#value`.
		     *
		     * Explicit chain sequences, which must be unwrapped with `_#value`, may be
		     * enabled using `_.chain`.
		     *
		     * The execution of chained methods is lazy, that is, it's deferred until
		     * `_#value` is implicitly or explicitly called.
		     *
		     * Lazy evaluation allows several methods to support shortcut fusion.
		     * Shortcut fusion is an optimization to merge iteratee calls; this avoids
		     * the creation of intermediate arrays and can greatly reduce the number of
		     * iteratee executions. Sections of a chain sequence qualify for shortcut
		     * fusion if the section is applied to an array and iteratees accept only
		     * one argument. The heuristic for whether a section qualifies for shortcut
		     * fusion is subject to change.
		     *
		     * Chaining is supported in custom builds as long as the `_#value` method is
		     * directly or indirectly included in the build.
		     *
		     * In addition to lodash methods, wrappers have `Array` and `String` methods.
		     *
		     * The wrapper `Array` methods are:
		     * `concat`, `join`, `pop`, `push`, `shift`, `sort`, `splice`, and `unshift`
		     *
		     * The wrapper `String` methods are:
		     * `replace` and `split`
		     *
		     * The wrapper methods that support shortcut fusion are:
		     * `at`, `compact`, `drop`, `dropRight`, `dropWhile`, `filter`, `find`,
		     * `findLast`, `head`, `initial`, `last`, `map`, `reject`, `reverse`, `slice`,
		     * `tail`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, and `toArray`
		     *
		     * The chainable wrapper methods are:
		     * `after`, `ary`, `assign`, `assignIn`, `assignInWith`, `assignWith`, `at`,
		     * `before`, `bind`, `bindAll`, `bindKey`, `castArray`, `chain`, `chunk`,
		     * `commit`, `compact`, `concat`, `conforms`, `constant`, `countBy`, `create`,
		     * `curry`, `debounce`, `defaults`, `defaultsDeep`, `defer`, `delay`,
		     * `difference`, `differenceBy`, `differenceWith`, `drop`, `dropRight`,
		     * `dropRightWhile`, `dropWhile`, `extend`, `extendWith`, `fill`, `filter`,
		     * `flatMap`, `flatMapDeep`, `flatMapDepth`, `flatten`, `flattenDeep`,
		     * `flattenDepth`, `flip`, `flow`, `flowRight`, `fromPairs`, `functions`,
		     * `functionsIn`, `groupBy`, `initial`, `intersection`, `intersectionBy`,
		     * `intersectionWith`, `invert`, `invertBy`, `invokeMap`, `iteratee`, `keyBy`,
		     * `keys`, `keysIn`, `map`, `mapKeys`, `mapValues`, `matches`, `matchesProperty`,
		     * `memoize`, `merge`, `mergeWith`, `method`, `methodOf`, `mixin`, `negate`,
		     * `nthArg`, `omit`, `omitBy`, `once`, `orderBy`, `over`, `overArgs`,
		     * `overEvery`, `overSome`, `partial`, `partialRight`, `partition`, `pick`,
		     * `pickBy`, `plant`, `property`, `propertyOf`, `pull`, `pullAll`, `pullAllBy`,
		     * `pullAllWith`, `pullAt`, `push`, `range`, `rangeRight`, `rearg`, `reject`,
		     * `remove`, `rest`, `reverse`, `sampleSize`, `set`, `setWith`, `shuffle`,
		     * `slice`, `sort`, `sortBy`, `splice`, `spread`, `tail`, `take`, `takeRight`,
		     * `takeRightWhile`, `takeWhile`, `tap`, `throttle`, `thru`, `toArray`,
		     * `toPairs`, `toPairsIn`, `toPath`, `toPlainObject`, `transform`, `unary`,
		     * `union`, `unionBy`, `unionWith`, `uniq`, `uniqBy`, `uniqWith`, `unset`,
		     * `unshift`, `unzip`, `unzipWith`, `update`, `updateWith`, `values`,
		     * `valuesIn`, `without`, `wrap`, `xor`, `xorBy`, `xorWith`, `zip`,
		     * `zipObject`, `zipObjectDeep`, and `zipWith`
		     *
		     * The wrapper methods that are **not** chainable by default are:
		     * `add`, `attempt`, `camelCase`, `capitalize`, `ceil`, `clamp`, `clone`,
		     * `cloneDeep`, `cloneDeepWith`, `cloneWith`, `conformsTo`, `deburr`,
		     * `defaultTo`, `divide`, `each`, `eachRight`, `endsWith`, `eq`, `escape`,
		     * `escapeRegExp`, `every`, `find`, `findIndex`, `findKey`, `findLast`,
		     * `findLastIndex`, `findLastKey`, `first`, `floor`, `forEach`, `forEachRight`,
		     * `forIn`, `forInRight`, `forOwn`, `forOwnRight`, `get`, `gt`, `gte`, `has`,
		     * `hasIn`, `head`, `identity`, `includes`, `indexOf`, `inRange`, `invoke`,
		     * `isArguments`, `isArray`, `isArrayBuffer`, `isArrayLike`, `isArrayLikeObject`,
		     * `isBoolean`, `isBuffer`, `isDate`, `isElement`, `isEmpty`, `isEqual`,
		     * `isEqualWith`, `isError`, `isFinite`, `isFunction`, `isInteger`, `isLength`,
		     * `isMap`, `isMatch`, `isMatchWith`, `isNaN`, `isNative`, `isNil`, `isNull`,
		     * `isNumber`, `isObject`, `isObjectLike`, `isPlainObject`, `isRegExp`,
		     * `isSafeInteger`, `isSet`, `isString`, `isUndefined`, `isTypedArray`,
		     * `isWeakMap`, `isWeakSet`, `join`, `kebabCase`, `last`, `lastIndexOf`,
		     * `lowerCase`, `lowerFirst`, `lt`, `lte`, `max`, `maxBy`, `mean`, `meanBy`,
		     * `min`, `minBy`, `multiply`, `noConflict`, `noop`, `now`, `nth`, `pad`,
		     * `padEnd`, `padStart`, `parseInt`, `pop`, `random`, `reduce`, `reduceRight`,
		     * `repeat`, `result`, `round`, `runInContext`, `sample`, `shift`, `size`,
		     * `snakeCase`, `some`, `sortedIndex`, `sortedIndexBy`, `sortedLastIndex`,
		     * `sortedLastIndexBy`, `startCase`, `startsWith`, `stubArray`, `stubFalse`,
		     * `stubObject`, `stubString`, `stubTrue`, `subtract`, `sum`, `sumBy`,
		     * `template`, `times`, `toFinite`, `toInteger`, `toJSON`, `toLength`,
		     * `toLower`, `toNumber`, `toSafeInteger`, `toString`, `toUpper`, `trim`,
		     * `trimEnd`, `trimStart`, `truncate`, `unescape`, `uniqueId`, `upperCase`,
		     * `upperFirst`, `value`, and `words`
		     *
		     * @name _
		     * @constructor
		     * @category Seq
		     * @param {*} value The value to wrap in a `lodash` instance.
		     * @returns {Object} Returns the new `lodash` wrapper instance.
		     * @example
		     *
		     * function square(n) {
		     *   return n * n;
		     * }
		     *
		     * var wrapped = _([1, 2, 3]);
		     *
		     * // Returns an unwrapped value.
		     * wrapped.reduce(_.add);
		     * // => 6
		     *
		     * // Returns a wrapped value.
		     * var squares = wrapped.map(square);
		     *
		     * _.isArray(squares);
		     * // => false
		     *
		     * _.isArray(squares.value());
		     * // => true
		     */
		    function lodash(value) {
		      if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
		        if (value instanceof LodashWrapper) {
		          return value;
		        }
		        if (hasOwnProperty.call(value, '__wrapped__')) {
		          return wrapperClone(value);
		        }
		      }
		      return new LodashWrapper(value);
		    }

		    /**
		     * The base implementation of `_.create` without support for assigning
		     * properties to the created object.
		     *
		     * @private
		     * @param {Object} proto The object to inherit from.
		     * @returns {Object} Returns the new object.
		     */
		    var baseCreate = (function() {
		      function object() {}
		      return function(proto) {
		        if (!isObject(proto)) {
		          return {};
		        }
		        if (objectCreate) {
		          return objectCreate(proto);
		        }
		        object.prototype = proto;
		        var result = new object;
		        object.prototype = undefined$1;
		        return result;
		      };
		    }());

		    /**
		     * The function whose prototype chain sequence wrappers inherit from.
		     *
		     * @private
		     */
		    function baseLodash() {
		      // No operation performed.
		    }

		    /**
		     * The base constructor for creating `lodash` wrapper objects.
		     *
		     * @private
		     * @param {*} value The value to wrap.
		     * @param {boolean} [chainAll] Enable explicit method chain sequences.
		     */
		    function LodashWrapper(value, chainAll) {
		      this.__wrapped__ = value;
		      this.__actions__ = [];
		      this.__chain__ = !!chainAll;
		      this.__index__ = 0;
		      this.__values__ = undefined$1;
		    }

		    /**
		     * By default, the template delimiters used by lodash are like those in
		     * embedded Ruby (ERB) as well as ES2015 template strings. Change the
		     * following template settings to use alternative delimiters.
		     *
		     * @static
		     * @memberOf _
		     * @type {Object}
		     */
		    lodash.templateSettings = {

		      /**
		       * Used to detect `data` property values to be HTML-escaped.
		       *
		       * @memberOf _.templateSettings
		       * @type {RegExp}
		       */
		      'escape': reEscape,

		      /**
		       * Used to detect code to be evaluated.
		       *
		       * @memberOf _.templateSettings
		       * @type {RegExp}
		       */
		      'evaluate': reEvaluate,

		      /**
		       * Used to detect `data` property values to inject.
		       *
		       * @memberOf _.templateSettings
		       * @type {RegExp}
		       */
		      'interpolate': reInterpolate,

		      /**
		       * Used to reference the data object in the template text.
		       *
		       * @memberOf _.templateSettings
		       * @type {string}
		       */
		      'variable': '',

		      /**
		       * Used to import variables into the compiled template.
		       *
		       * @memberOf _.templateSettings
		       * @type {Object}
		       */
		      'imports': {

		        /**
		         * A reference to the `lodash` function.
		         *
		         * @memberOf _.templateSettings.imports
		         * @type {Function}
		         */
		        '_': lodash
		      }
		    };

		    // Ensure wrappers are instances of `baseLodash`.
		    lodash.prototype = baseLodash.prototype;
		    lodash.prototype.constructor = lodash;

		    LodashWrapper.prototype = baseCreate(baseLodash.prototype);
		    LodashWrapper.prototype.constructor = LodashWrapper;

		    /*------------------------------------------------------------------------*/

		    /**
		     * Creates a lazy wrapper object which wraps `value` to enable lazy evaluation.
		     *
		     * @private
		     * @constructor
		     * @param {*} value The value to wrap.
		     */
		    function LazyWrapper(value) {
		      this.__wrapped__ = value;
		      this.__actions__ = [];
		      this.__dir__ = 1;
		      this.__filtered__ = false;
		      this.__iteratees__ = [];
		      this.__takeCount__ = MAX_ARRAY_LENGTH;
		      this.__views__ = [];
		    }

		    /**
		     * Creates a clone of the lazy wrapper object.
		     *
		     * @private
		     * @name clone
		     * @memberOf LazyWrapper
		     * @returns {Object} Returns the cloned `LazyWrapper` object.
		     */
		    function lazyClone() {
		      var result = new LazyWrapper(this.__wrapped__);
		      result.__actions__ = copyArray(this.__actions__);
		      result.__dir__ = this.__dir__;
		      result.__filtered__ = this.__filtered__;
		      result.__iteratees__ = copyArray(this.__iteratees__);
		      result.__takeCount__ = this.__takeCount__;
		      result.__views__ = copyArray(this.__views__);
		      return result;
		    }

		    /**
		     * Reverses the direction of lazy iteration.
		     *
		     * @private
		     * @name reverse
		     * @memberOf LazyWrapper
		     * @returns {Object} Returns the new reversed `LazyWrapper` object.
		     */
		    function lazyReverse() {
		      if (this.__filtered__) {
		        var result = new LazyWrapper(this);
		        result.__dir__ = -1;
		        result.__filtered__ = true;
		      } else {
		        result = this.clone();
		        result.__dir__ *= -1;
		      }
		      return result;
		    }

		    /**
		     * Extracts the unwrapped value from its lazy wrapper.
		     *
		     * @private
		     * @name value
		     * @memberOf LazyWrapper
		     * @returns {*} Returns the unwrapped value.
		     */
		    function lazyValue() {
		      var array = this.__wrapped__.value(),
		          dir = this.__dir__,
		          isArr = isArray(array),
		          isRight = dir < 0,
		          arrLength = isArr ? array.length : 0,
		          view = getView(0, arrLength, this.__views__),
		          start = view.start,
		          end = view.end,
		          length = end - start,
		          index = isRight ? end : (start - 1),
		          iteratees = this.__iteratees__,
		          iterLength = iteratees.length,
		          resIndex = 0,
		          takeCount = nativeMin(length, this.__takeCount__);

		      if (!isArr || (!isRight && arrLength == length && takeCount == length)) {
		        return baseWrapperValue(array, this.__actions__);
		      }
		      var result = [];

		      outer:
		      while (length-- && resIndex < takeCount) {
		        index += dir;

		        var iterIndex = -1,
		            value = array[index];

		        while (++iterIndex < iterLength) {
		          var data = iteratees[iterIndex],
		              iteratee = data.iteratee,
		              type = data.type,
		              computed = iteratee(value);

		          if (type == LAZY_MAP_FLAG) {
		            value = computed;
		          } else if (!computed) {
		            if (type == LAZY_FILTER_FLAG) {
		              continue outer;
		            } else {
		              break outer;
		            }
		          }
		        }
		        result[resIndex++] = value;
		      }
		      return result;
		    }

		    // Ensure `LazyWrapper` is an instance of `baseLodash`.
		    LazyWrapper.prototype = baseCreate(baseLodash.prototype);
		    LazyWrapper.prototype.constructor = LazyWrapper;

		    /*------------------------------------------------------------------------*/

		    /**
		     * Creates a hash object.
		     *
		     * @private
		     * @constructor
		     * @param {Array} [entries] The key-value pairs to cache.
		     */
		    function Hash(entries) {
		      var index = -1,
		          length = entries == null ? 0 : entries.length;

		      this.clear();
		      while (++index < length) {
		        var entry = entries[index];
		        this.set(entry[0], entry[1]);
		      }
		    }

		    /**
		     * Removes all key-value entries from the hash.
		     *
		     * @private
		     * @name clear
		     * @memberOf Hash
		     */
		    function hashClear() {
		      this.__data__ = nativeCreate ? nativeCreate(null) : {};
		      this.size = 0;
		    }

		    /**
		     * Removes `key` and its value from the hash.
		     *
		     * @private
		     * @name delete
		     * @memberOf Hash
		     * @param {Object} hash The hash to modify.
		     * @param {string} key The key of the value to remove.
		     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
		     */
		    function hashDelete(key) {
		      var result = this.has(key) && delete this.__data__[key];
		      this.size -= result ? 1 : 0;
		      return result;
		    }

		    /**
		     * Gets the hash value for `key`.
		     *
		     * @private
		     * @name get
		     * @memberOf Hash
		     * @param {string} key The key of the value to get.
		     * @returns {*} Returns the entry value.
		     */
		    function hashGet(key) {
		      var data = this.__data__;
		      if (nativeCreate) {
		        var result = data[key];
		        return result === HASH_UNDEFINED ? undefined$1 : result;
		      }
		      return hasOwnProperty.call(data, key) ? data[key] : undefined$1;
		    }

		    /**
		     * Checks if a hash value for `key` exists.
		     *
		     * @private
		     * @name has
		     * @memberOf Hash
		     * @param {string} key The key of the entry to check.
		     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
		     */
		    function hashHas(key) {
		      var data = this.__data__;
		      return nativeCreate ? (data[key] !== undefined$1) : hasOwnProperty.call(data, key);
		    }

		    /**
		     * Sets the hash `key` to `value`.
		     *
		     * @private
		     * @name set
		     * @memberOf Hash
		     * @param {string} key The key of the value to set.
		     * @param {*} value The value to set.
		     * @returns {Object} Returns the hash instance.
		     */
		    function hashSet(key, value) {
		      var data = this.__data__;
		      this.size += this.has(key) ? 0 : 1;
		      data[key] = (nativeCreate && value === undefined$1) ? HASH_UNDEFINED : value;
		      return this;
		    }

		    // Add methods to `Hash`.
		    Hash.prototype.clear = hashClear;
		    Hash.prototype['delete'] = hashDelete;
		    Hash.prototype.get = hashGet;
		    Hash.prototype.has = hashHas;
		    Hash.prototype.set = hashSet;

		    /*------------------------------------------------------------------------*/

		    /**
		     * Creates an list cache object.
		     *
		     * @private
		     * @constructor
		     * @param {Array} [entries] The key-value pairs to cache.
		     */
		    function ListCache(entries) {
		      var index = -1,
		          length = entries == null ? 0 : entries.length;

		      this.clear();
		      while (++index < length) {
		        var entry = entries[index];
		        this.set(entry[0], entry[1]);
		      }
		    }

		    /**
		     * Removes all key-value entries from the list cache.
		     *
		     * @private
		     * @name clear
		     * @memberOf ListCache
		     */
		    function listCacheClear() {
		      this.__data__ = [];
		      this.size = 0;
		    }

		    /**
		     * Removes `key` and its value from the list cache.
		     *
		     * @private
		     * @name delete
		     * @memberOf ListCache
		     * @param {string} key The key of the value to remove.
		     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
		     */
		    function listCacheDelete(key) {
		      var data = this.__data__,
		          index = assocIndexOf(data, key);

		      if (index < 0) {
		        return false;
		      }
		      var lastIndex = data.length - 1;
		      if (index == lastIndex) {
		        data.pop();
		      } else {
		        splice.call(data, index, 1);
		      }
		      --this.size;
		      return true;
		    }

		    /**
		     * Gets the list cache value for `key`.
		     *
		     * @private
		     * @name get
		     * @memberOf ListCache
		     * @param {string} key The key of the value to get.
		     * @returns {*} Returns the entry value.
		     */
		    function listCacheGet(key) {
		      var data = this.__data__,
		          index = assocIndexOf(data, key);

		      return index < 0 ? undefined$1 : data[index][1];
		    }

		    /**
		     * Checks if a list cache value for `key` exists.
		     *
		     * @private
		     * @name has
		     * @memberOf ListCache
		     * @param {string} key The key of the entry to check.
		     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
		     */
		    function listCacheHas(key) {
		      return assocIndexOf(this.__data__, key) > -1;
		    }

		    /**
		     * Sets the list cache `key` to `value`.
		     *
		     * @private
		     * @name set
		     * @memberOf ListCache
		     * @param {string} key The key of the value to set.
		     * @param {*} value The value to set.
		     * @returns {Object} Returns the list cache instance.
		     */
		    function listCacheSet(key, value) {
		      var data = this.__data__,
		          index = assocIndexOf(data, key);

		      if (index < 0) {
		        ++this.size;
		        data.push([key, value]);
		      } else {
		        data[index][1] = value;
		      }
		      return this;
		    }

		    // Add methods to `ListCache`.
		    ListCache.prototype.clear = listCacheClear;
		    ListCache.prototype['delete'] = listCacheDelete;
		    ListCache.prototype.get = listCacheGet;
		    ListCache.prototype.has = listCacheHas;
		    ListCache.prototype.set = listCacheSet;

		    /*------------------------------------------------------------------------*/

		    /**
		     * Creates a map cache object to store key-value pairs.
		     *
		     * @private
		     * @constructor
		     * @param {Array} [entries] The key-value pairs to cache.
		     */
		    function MapCache(entries) {
		      var index = -1,
		          length = entries == null ? 0 : entries.length;

		      this.clear();
		      while (++index < length) {
		        var entry = entries[index];
		        this.set(entry[0], entry[1]);
		      }
		    }

		    /**
		     * Removes all key-value entries from the map.
		     *
		     * @private
		     * @name clear
		     * @memberOf MapCache
		     */
		    function mapCacheClear() {
		      this.size = 0;
		      this.__data__ = {
		        'hash': new Hash,
		        'map': new (Map || ListCache),
		        'string': new Hash
		      };
		    }

		    /**
		     * Removes `key` and its value from the map.
		     *
		     * @private
		     * @name delete
		     * @memberOf MapCache
		     * @param {string} key The key of the value to remove.
		     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
		     */
		    function mapCacheDelete(key) {
		      var result = getMapData(this, key)['delete'](key);
		      this.size -= result ? 1 : 0;
		      return result;
		    }

		    /**
		     * Gets the map value for `key`.
		     *
		     * @private
		     * @name get
		     * @memberOf MapCache
		     * @param {string} key The key of the value to get.
		     * @returns {*} Returns the entry value.
		     */
		    function mapCacheGet(key) {
		      return getMapData(this, key).get(key);
		    }

		    /**
		     * Checks if a map value for `key` exists.
		     *
		     * @private
		     * @name has
		     * @memberOf MapCache
		     * @param {string} key The key of the entry to check.
		     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
		     */
		    function mapCacheHas(key) {
		      return getMapData(this, key).has(key);
		    }

		    /**
		     * Sets the map `key` to `value`.
		     *
		     * @private
		     * @name set
		     * @memberOf MapCache
		     * @param {string} key The key of the value to set.
		     * @param {*} value The value to set.
		     * @returns {Object} Returns the map cache instance.
		     */
		    function mapCacheSet(key, value) {
		      var data = getMapData(this, key),
		          size = data.size;

		      data.set(key, value);
		      this.size += data.size == size ? 0 : 1;
		      return this;
		    }

		    // Add methods to `MapCache`.
		    MapCache.prototype.clear = mapCacheClear;
		    MapCache.prototype['delete'] = mapCacheDelete;
		    MapCache.prototype.get = mapCacheGet;
		    MapCache.prototype.has = mapCacheHas;
		    MapCache.prototype.set = mapCacheSet;

		    /*------------------------------------------------------------------------*/

		    /**
		     *
		     * Creates an array cache object to store unique values.
		     *
		     * @private
		     * @constructor
		     * @param {Array} [values] The values to cache.
		     */
		    function SetCache(values) {
		      var index = -1,
		          length = values == null ? 0 : values.length;

		      this.__data__ = new MapCache;
		      while (++index < length) {
		        this.add(values[index]);
		      }
		    }

		    /**
		     * Adds `value` to the array cache.
		     *
		     * @private
		     * @name add
		     * @memberOf SetCache
		     * @alias push
		     * @param {*} value The value to cache.
		     * @returns {Object} Returns the cache instance.
		     */
		    function setCacheAdd(value) {
		      this.__data__.set(value, HASH_UNDEFINED);
		      return this;
		    }

		    /**
		     * Checks if `value` is in the array cache.
		     *
		     * @private
		     * @name has
		     * @memberOf SetCache
		     * @param {*} value The value to search for.
		     * @returns {number} Returns `true` if `value` is found, else `false`.
		     */
		    function setCacheHas(value) {
		      return this.__data__.has(value);
		    }

		    // Add methods to `SetCache`.
		    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
		    SetCache.prototype.has = setCacheHas;

		    /*------------------------------------------------------------------------*/

		    /**
		     * Creates a stack cache object to store key-value pairs.
		     *
		     * @private
		     * @constructor
		     * @param {Array} [entries] The key-value pairs to cache.
		     */
		    function Stack(entries) {
		      var data = this.__data__ = new ListCache(entries);
		      this.size = data.size;
		    }

		    /**
		     * Removes all key-value entries from the stack.
		     *
		     * @private
		     * @name clear
		     * @memberOf Stack
		     */
		    function stackClear() {
		      this.__data__ = new ListCache;
		      this.size = 0;
		    }

		    /**
		     * Removes `key` and its value from the stack.
		     *
		     * @private
		     * @name delete
		     * @memberOf Stack
		     * @param {string} key The key of the value to remove.
		     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
		     */
		    function stackDelete(key) {
		      var data = this.__data__,
		          result = data['delete'](key);

		      this.size = data.size;
		      return result;
		    }

		    /**
		     * Gets the stack value for `key`.
		     *
		     * @private
		     * @name get
		     * @memberOf Stack
		     * @param {string} key The key of the value to get.
		     * @returns {*} Returns the entry value.
		     */
		    function stackGet(key) {
		      return this.__data__.get(key);
		    }

		    /**
		     * Checks if a stack value for `key` exists.
		     *
		     * @private
		     * @name has
		     * @memberOf Stack
		     * @param {string} key The key of the entry to check.
		     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
		     */
		    function stackHas(key) {
		      return this.__data__.has(key);
		    }

		    /**
		     * Sets the stack `key` to `value`.
		     *
		     * @private
		     * @name set
		     * @memberOf Stack
		     * @param {string} key The key of the value to set.
		     * @param {*} value The value to set.
		     * @returns {Object} Returns the stack cache instance.
		     */
		    function stackSet(key, value) {
		      var data = this.__data__;
		      if (data instanceof ListCache) {
		        var pairs = data.__data__;
		        if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
		          pairs.push([key, value]);
		          this.size = ++data.size;
		          return this;
		        }
		        data = this.__data__ = new MapCache(pairs);
		      }
		      data.set(key, value);
		      this.size = data.size;
		      return this;
		    }

		    // Add methods to `Stack`.
		    Stack.prototype.clear = stackClear;
		    Stack.prototype['delete'] = stackDelete;
		    Stack.prototype.get = stackGet;
		    Stack.prototype.has = stackHas;
		    Stack.prototype.set = stackSet;

		    /*------------------------------------------------------------------------*/

		    /**
		     * Creates an array of the enumerable property names of the array-like `value`.
		     *
		     * @private
		     * @param {*} value The value to query.
		     * @param {boolean} inherited Specify returning inherited property names.
		     * @returns {Array} Returns the array of property names.
		     */
		    function arrayLikeKeys(value, inherited) {
		      var isArr = isArray(value),
		          isArg = !isArr && isArguments(value),
		          isBuff = !isArr && !isArg && isBuffer(value),
		          isType = !isArr && !isArg && !isBuff && isTypedArray(value),
		          skipIndexes = isArr || isArg || isBuff || isType,
		          result = skipIndexes ? baseTimes(value.length, String) : [],
		          length = result.length;

		      for (var key in value) {
		        if ((inherited || hasOwnProperty.call(value, key)) &&
		            !(skipIndexes && (
		               // Safari 9 has enumerable `arguments.length` in strict mode.
		               key == 'length' ||
		               // Node.js 0.10 has enumerable non-index properties on buffers.
		               (isBuff && (key == 'offset' || key == 'parent')) ||
		               // PhantomJS 2 has enumerable non-index properties on typed arrays.
		               (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
		               // Skip index properties.
		               isIndex(key, length)
		            ))) {
		          result.push(key);
		        }
		      }
		      return result;
		    }

		    /**
		     * A specialized version of `_.sample` for arrays.
		     *
		     * @private
		     * @param {Array} array The array to sample.
		     * @returns {*} Returns the random element.
		     */
		    function arraySample(array) {
		      var length = array.length;
		      return length ? array[baseRandom(0, length - 1)] : undefined$1;
		    }

		    /**
		     * A specialized version of `_.sampleSize` for arrays.
		     *
		     * @private
		     * @param {Array} array The array to sample.
		     * @param {number} n The number of elements to sample.
		     * @returns {Array} Returns the random elements.
		     */
		    function arraySampleSize(array, n) {
		      return shuffleSelf(copyArray(array), baseClamp(n, 0, array.length));
		    }

		    /**
		     * A specialized version of `_.shuffle` for arrays.
		     *
		     * @private
		     * @param {Array} array The array to shuffle.
		     * @returns {Array} Returns the new shuffled array.
		     */
		    function arrayShuffle(array) {
		      return shuffleSelf(copyArray(array));
		    }

		    /**
		     * This function is like `assignValue` except that it doesn't assign
		     * `undefined` values.
		     *
		     * @private
		     * @param {Object} object The object to modify.
		     * @param {string} key The key of the property to assign.
		     * @param {*} value The value to assign.
		     */
		    function assignMergeValue(object, key, value) {
		      if ((value !== undefined$1 && !eq(object[key], value)) ||
		          (value === undefined$1 && !(key in object))) {
		        baseAssignValue(object, key, value);
		      }
		    }

		    /**
		     * Assigns `value` to `key` of `object` if the existing value is not equivalent
		     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
		     * for equality comparisons.
		     *
		     * @private
		     * @param {Object} object The object to modify.
		     * @param {string} key The key of the property to assign.
		     * @param {*} value The value to assign.
		     */
		    function assignValue(object, key, value) {
		      var objValue = object[key];
		      if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
		          (value === undefined$1 && !(key in object))) {
		        baseAssignValue(object, key, value);
		      }
		    }

		    /**
		     * Gets the index at which the `key` is found in `array` of key-value pairs.
		     *
		     * @private
		     * @param {Array} array The array to inspect.
		     * @param {*} key The key to search for.
		     * @returns {number} Returns the index of the matched value, else `-1`.
		     */
		    function assocIndexOf(array, key) {
		      var length = array.length;
		      while (length--) {
		        if (eq(array[length][0], key)) {
		          return length;
		        }
		      }
		      return -1;
		    }

		    /**
		     * Aggregates elements of `collection` on `accumulator` with keys transformed
		     * by `iteratee` and values set by `setter`.
		     *
		     * @private
		     * @param {Array|Object} collection The collection to iterate over.
		     * @param {Function} setter The function to set `accumulator` values.
		     * @param {Function} iteratee The iteratee to transform keys.
		     * @param {Object} accumulator The initial aggregated object.
		     * @returns {Function} Returns `accumulator`.
		     */
		    function baseAggregator(collection, setter, iteratee, accumulator) {
		      baseEach(collection, function(value, key, collection) {
		        setter(accumulator, value, iteratee(value), collection);
		      });
		      return accumulator;
		    }

		    /**
		     * The base implementation of `_.assign` without support for multiple sources
		     * or `customizer` functions.
		     *
		     * @private
		     * @param {Object} object The destination object.
		     * @param {Object} source The source object.
		     * @returns {Object} Returns `object`.
		     */
		    function baseAssign(object, source) {
		      return object && copyObject(source, keys(source), object);
		    }

		    /**
		     * The base implementation of `_.assignIn` without support for multiple sources
		     * or `customizer` functions.
		     *
		     * @private
		     * @param {Object} object The destination object.
		     * @param {Object} source The source object.
		     * @returns {Object} Returns `object`.
		     */
		    function baseAssignIn(object, source) {
		      return object && copyObject(source, keysIn(source), object);
		    }

		    /**
		     * The base implementation of `assignValue` and `assignMergeValue` without
		     * value checks.
		     *
		     * @private
		     * @param {Object} object The object to modify.
		     * @param {string} key The key of the property to assign.
		     * @param {*} value The value to assign.
		     */
		    function baseAssignValue(object, key, value) {
		      if (key == '__proto__' && defineProperty) {
		        defineProperty(object, key, {
		          'configurable': true,
		          'enumerable': true,
		          'value': value,
		          'writable': true
		        });
		      } else {
		        object[key] = value;
		      }
		    }

		    /**
		     * The base implementation of `_.at` without support for individual paths.
		     *
		     * @private
		     * @param {Object} object The object to iterate over.
		     * @param {string[]} paths The property paths to pick.
		     * @returns {Array} Returns the picked elements.
		     */
		    function baseAt(object, paths) {
		      var index = -1,
		          length = paths.length,
		          result = Array(length),
		          skip = object == null;

		      while (++index < length) {
		        result[index] = skip ? undefined$1 : get(object, paths[index]);
		      }
		      return result;
		    }

		    /**
		     * The base implementation of `_.clamp` which doesn't coerce arguments.
		     *
		     * @private
		     * @param {number} number The number to clamp.
		     * @param {number} [lower] The lower bound.
		     * @param {number} upper The upper bound.
		     * @returns {number} Returns the clamped number.
		     */
		    function baseClamp(number, lower, upper) {
		      if (number === number) {
		        if (upper !== undefined$1) {
		          number = number <= upper ? number : upper;
		        }
		        if (lower !== undefined$1) {
		          number = number >= lower ? number : lower;
		        }
		      }
		      return number;
		    }

		    /**
		     * The base implementation of `_.clone` and `_.cloneDeep` which tracks
		     * traversed objects.
		     *
		     * @private
		     * @param {*} value The value to clone.
		     * @param {boolean} bitmask The bitmask flags.
		     *  1 - Deep clone
		     *  2 - Flatten inherited properties
		     *  4 - Clone symbols
		     * @param {Function} [customizer] The function to customize cloning.
		     * @param {string} [key] The key of `value`.
		     * @param {Object} [object] The parent object of `value`.
		     * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
		     * @returns {*} Returns the cloned value.
		     */
		    function baseClone(value, bitmask, customizer, key, object, stack) {
		      var result,
		          isDeep = bitmask & CLONE_DEEP_FLAG,
		          isFlat = bitmask & CLONE_FLAT_FLAG,
		          isFull = bitmask & CLONE_SYMBOLS_FLAG;

		      if (customizer) {
		        result = object ? customizer(value, key, object, stack) : customizer(value);
		      }
		      if (result !== undefined$1) {
		        return result;
		      }
		      if (!isObject(value)) {
		        return value;
		      }
		      var isArr = isArray(value);
		      if (isArr) {
		        result = initCloneArray(value);
		        if (!isDeep) {
		          return copyArray(value, result);
		        }
		      } else {
		        var tag = getTag(value),
		            isFunc = tag == funcTag || tag == genTag;

		        if (isBuffer(value)) {
		          return cloneBuffer(value, isDeep);
		        }
		        if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
		          result = (isFlat || isFunc) ? {} : initCloneObject(value);
		          if (!isDeep) {
		            return isFlat
		              ? copySymbolsIn(value, baseAssignIn(result, value))
		              : copySymbols(value, baseAssign(result, value));
		          }
		        } else {
		          if (!cloneableTags[tag]) {
		            return object ? value : {};
		          }
		          result = initCloneByTag(value, tag, isDeep);
		        }
		      }
		      // Check for circular references and return its corresponding clone.
		      stack || (stack = new Stack);
		      var stacked = stack.get(value);
		      if (stacked) {
		        return stacked;
		      }
		      stack.set(value, result);

		      if (isSet(value)) {
		        value.forEach(function(subValue) {
		          result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
		        });
		      } else if (isMap(value)) {
		        value.forEach(function(subValue, key) {
		          result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));
		        });
		      }

		      var keysFunc = isFull
		        ? (isFlat ? getAllKeysIn : getAllKeys)
		        : (isFlat ? keysIn : keys);

		      var props = isArr ? undefined$1 : keysFunc(value);
		      arrayEach(props || value, function(subValue, key) {
		        if (props) {
		          key = subValue;
		          subValue = value[key];
		        }
		        // Recursively populate clone (susceptible to call stack limits).
		        assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
		      });
		      return result;
		    }

		    /**
		     * The base implementation of `_.conforms` which doesn't clone `source`.
		     *
		     * @private
		     * @param {Object} source The object of property predicates to conform to.
		     * @returns {Function} Returns the new spec function.
		     */
		    function baseConforms(source) {
		      var props = keys(source);
		      return function(object) {
		        return baseConformsTo(object, source, props);
		      };
		    }

		    /**
		     * The base implementation of `_.conformsTo` which accepts `props` to check.
		     *
		     * @private
		     * @param {Object} object The object to inspect.
		     * @param {Object} source The object of property predicates to conform to.
		     * @returns {boolean} Returns `true` if `object` conforms, else `false`.
		     */
		    function baseConformsTo(object, source, props) {
		      var length = props.length;
		      if (object == null) {
		        return !length;
		      }
		      object = Object(object);
		      while (length--) {
		        var key = props[length],
		            predicate = source[key],
		            value = object[key];

		        if ((value === undefined$1 && !(key in object)) || !predicate(value)) {
		          return false;
		        }
		      }
		      return true;
		    }

		    /**
		     * The base implementation of `_.delay` and `_.defer` which accepts `args`
		     * to provide to `func`.
		     *
		     * @private
		     * @param {Function} func The function to delay.
		     * @param {number} wait The number of milliseconds to delay invocation.
		     * @param {Array} args The arguments to provide to `func`.
		     * @returns {number|Object} Returns the timer id or timeout object.
		     */
		    function baseDelay(func, wait, args) {
		      if (typeof func != 'function') {
		        throw new TypeError(FUNC_ERROR_TEXT);
		      }
		      return setTimeout(function() { func.apply(undefined$1, args); }, wait);
		    }

		    /**
		     * The base implementation of methods like `_.difference` without support
		     * for excluding multiple arrays or iteratee shorthands.
		     *
		     * @private
		     * @param {Array} array The array to inspect.
		     * @param {Array} values The values to exclude.
		     * @param {Function} [iteratee] The iteratee invoked per element.
		     * @param {Function} [comparator] The comparator invoked per element.
		     * @returns {Array} Returns the new array of filtered values.
		     */
		    function baseDifference(array, values, iteratee, comparator) {
		      var index = -1,
		          includes = arrayIncludes,
		          isCommon = true,
		          length = array.length,
		          result = [],
		          valuesLength = values.length;

		      if (!length) {
		        return result;
		      }
		      if (iteratee) {
		        values = arrayMap(values, baseUnary(iteratee));
		      }
		      if (comparator) {
		        includes = arrayIncludesWith;
		        isCommon = false;
		      }
		      else if (values.length >= LARGE_ARRAY_SIZE) {
		        includes = cacheHas;
		        isCommon = false;
		        values = new SetCache(values);
		      }
		      outer:
		      while (++index < length) {
		        var value = array[index],
		            computed = iteratee == null ? value : iteratee(value);

		        value = (comparator || value !== 0) ? value : 0;
		        if (isCommon && computed === computed) {
		          var valuesIndex = valuesLength;
		          while (valuesIndex--) {
		            if (values[valuesIndex] === computed) {
		              continue outer;
		            }
		          }
		          result.push(value);
		        }
		        else if (!includes(values, computed, comparator)) {
		          result.push(value);
		        }
		      }
		      return result;
		    }

		    /**
		     * The base implementation of `_.forEach` without support for iteratee shorthands.
		     *
		     * @private
		     * @param {Array|Object} collection The collection to iterate over.
		     * @param {Function} iteratee The function invoked per iteration.
		     * @returns {Array|Object} Returns `collection`.
		     */
		    var baseEach = createBaseEach(baseForOwn);

		    /**
		     * The base implementation of `_.forEachRight` without support for iteratee shorthands.
		     *
		     * @private
		     * @param {Array|Object} collection The collection to iterate over.
		     * @param {Function} iteratee The function invoked per iteration.
		     * @returns {Array|Object} Returns `collection`.
		     */
		    var baseEachRight = createBaseEach(baseForOwnRight, true);

		    /**
		     * The base implementation of `_.every` without support for iteratee shorthands.
		     *
		     * @private
		     * @param {Array|Object} collection The collection to iterate over.
		     * @param {Function} predicate The function invoked per iteration.
		     * @returns {boolean} Returns `true` if all elements pass the predicate check,
		     *  else `false`
		     */
		    function baseEvery(collection, predicate) {
		      var result = true;
		      baseEach(collection, function(value, index, collection) {
		        result = !!predicate(value, index, collection);
		        return result;
		      });
		      return result;
		    }

		    /**
		     * The base implementation of methods like `_.max` and `_.min` which accepts a
		     * `comparator` to determine the extremum value.
		     *
		     * @private
		     * @param {Array} array The array to iterate over.
		     * @param {Function} iteratee The iteratee invoked per iteration.
		     * @param {Function} comparator The comparator used to compare values.
		     * @returns {*} Returns the extremum value.
		     */
		    function baseExtremum(array, iteratee, comparator) {
		      var index = -1,
		          length = array.length;

		      while (++index < length) {
		        var value = array[index],
		            current = iteratee(value);

		        if (current != null && (computed === undefined$1
		              ? (current === current && !isSymbol(current))
		              : comparator(current, computed)
		            )) {
		          var computed = current,
		              result = value;
		        }
		      }
		      return result;
		    }

		    /**
		     * The base implementation of `_.fill` without an iteratee call guard.
		     *
		     * @private
		     * @param {Array} array The array to fill.
		     * @param {*} value The value to fill `array` with.
		     * @param {number} [start=0] The start position.
		     * @param {number} [end=array.length] The end position.
		     * @returns {Array} Returns `array`.
		     */
		    function baseFill(array, value, start, end) {
		      var length = array.length;

		      start = toInteger(start);
		      if (start < 0) {
		        start = -start > length ? 0 : (length + start);
		      }
		      end = (end === undefined$1 || end > length) ? length : toInteger(end);
		      if (end < 0) {
		        end += length;
		      }
		      end = start > end ? 0 : toLength(end);
		      while (start < end) {
		        array[start++] = value;
		      }
		      return array;
		    }

		    /**
		     * The base implementation of `_.filter` without support for iteratee shorthands.
		     *
		     * @private
		     * @param {Array|Object} collection The collection to iterate over.
		     * @param {Function} predicate The function invoked per iteration.
		     * @returns {Array} Returns the new filtered array.
		     */
		    function baseFilter(collection, predicate) {
		      var result = [];
		      baseEach(collection, function(value, index, collection) {
		        if (predicate(value, index, collection)) {
		          result.push(value);
		        }
		      });
		      return result;
		    }

		    /**
		     * The base implementation of `_.flatten` with support for restricting flattening.
		     *
		     * @private
		     * @param {Array} array The array to flatten.
		     * @param {number} depth The maximum recursion depth.
		     * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
		     * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
		     * @param {Array} [result=[]] The initial result value.
		     * @returns {Array} Returns the new flattened array.
		     */
		    function baseFlatten(array, depth, predicate, isStrict, result) {
		      var index = -1,
		          length = array.length;

		      predicate || (predicate = isFlattenable);
		      result || (result = []);

		      while (++index < length) {
		        var value = array[index];
		        if (depth > 0 && predicate(value)) {
		          if (depth > 1) {
		            // Recursively flatten arrays (susceptible to call stack limits).
		            baseFlatten(value, depth - 1, predicate, isStrict, result);
		          } else {
		            arrayPush(result, value);
		          }
		        } else if (!isStrict) {
		          result[result.length] = value;
		        }
		      }
		      return result;
		    }

		    /**
		     * The base implementation of `baseForOwn` which iterates over `object`
		     * properties returned by `keysFunc` and invokes `iteratee` for each property.
		     * Iteratee functions may exit iteration early by explicitly returning `false`.
		     *
		     * @private
		     * @param {Object} object The object to iterate over.
		     * @param {Function} iteratee The function invoked per iteration.
		     * @param {Function} keysFunc The function to get the keys of `object`.
		     * @returns {Object} Returns `object`.
		     */
		    var baseFor = createBaseFor();

		    /**
		     * This function is like `baseFor` except that it iterates over properties
		     * in the opposite order.
		     *
		     * @private
		     * @param {Object} object The object to iterate over.
		     * @param {Function} iteratee The function invoked per iteration.
		     * @param {Function} keysFunc The function to get the keys of `object`.
		     * @returns {Object} Returns `object`.
		     */
		    var baseForRight = createBaseFor(true);

		    /**
		     * The base implementation of `_.forOwn` without support for iteratee shorthands.
		     *
		     * @private
		     * @param {Object} object The object to iterate over.
		     * @param {Function} iteratee The function invoked per iteration.
		     * @returns {Object} Returns `object`.
		     */
		    function baseForOwn(object, iteratee) {
		      return object && baseFor(object, iteratee, keys);
		    }

		    /**
		     * The base implementation of `_.forOwnRight` without support for iteratee shorthands.
		     *
		     * @private
		     * @param {Object} object The object to iterate over.
		     * @param {Function} iteratee The function invoked per iteration.
		     * @returns {Object} Returns `object`.
		     */
		    function baseForOwnRight(object, iteratee) {
		      return object && baseForRight(object, iteratee, keys);
		    }

		    /**
		     * The base implementation of `_.functions` which creates an array of
		     * `object` function property names filtered from `props`.
		     *
		     * @private
		     * @param {Object} object The object to inspect.
		     * @param {Array} props The property names to filter.
		     * @returns {Array} Returns the function names.
		     */
		    function baseFunctions(object, props) {
		      return arrayFilter(props, function(key) {
		        return isFunction(object[key]);
		      });
		    }

		    /**
		     * The base implementation of `_.get` without support for default values.
		     *
		     * @private
		     * @param {Object} object The object to query.
		     * @param {Array|string} path The path of the property to get.
		     * @returns {*} Returns the resolved value.
		     */
		    function baseGet(object, path) {
		      path = castPath(path, object);

		      var index = 0,
		          length = path.length;

		      while (object != null && index < length) {
		        object = object[toKey(path[index++])];
		      }
		      return (index && index == length) ? object : undefined$1;
		    }

		    /**
		     * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
		     * `keysFunc` and `symbolsFunc` to get the enumerable property names and
		     * symbols of `object`.
		     *
		     * @private
		     * @param {Object} object The object to query.
		     * @param {Function} keysFunc The function to get the keys of `object`.
		     * @param {Function} symbolsFunc The function to get the symbols of `object`.
		     * @returns {Array} Returns the array of property names and symbols.
		     */
		    function baseGetAllKeys(object, keysFunc, symbolsFunc) {
		      var result = keysFunc(object);
		      return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
		    }

		    /**
		     * The base implementation of `getTag` without fallbacks for buggy environments.
		     *
		     * @private
		     * @param {*} value The value to query.
		     * @returns {string} Returns the `toStringTag`.
		     */
		    function baseGetTag(value) {
		      if (value == null) {
		        return value === undefined$1 ? undefinedTag : nullTag;
		      }
		      return (symToStringTag && symToStringTag in Object(value))
		        ? getRawTag(value)
		        : objectToString(value);
		    }

		    /**
		     * The base implementation of `_.gt` which doesn't coerce arguments.
		     *
		     * @private
		     * @param {*} value The value to compare.
		     * @param {*} other The other value to compare.
		     * @returns {boolean} Returns `true` if `value` is greater than `other`,
		     *  else `false`.
		     */
		    function baseGt(value, other) {
		      return value > other;
		    }

		    /**
		     * The base implementation of `_.has` without support for deep paths.
		     *
		     * @private
		     * @param {Object} [object] The object to query.
		     * @param {Array|string} key The key to check.
		     * @returns {boolean} Returns `true` if `key` exists, else `false`.
		     */
		    function baseHas(object, key) {
		      return object != null && hasOwnProperty.call(object, key);
		    }

		    /**
		     * The base implementation of `_.hasIn` without support for deep paths.
		     *
		     * @private
		     * @param {Object} [object] The object to query.
		     * @param {Array|string} key The key to check.
		     * @returns {boolean} Returns `true` if `key` exists, else `false`.
		     */
		    function baseHasIn(object, key) {
		      return object != null && key in Object(object);
		    }

		    /**
		     * The base implementation of `_.inRange` which doesn't coerce arguments.
		     *
		     * @private
		     * @param {number} number The number to check.
		     * @param {number} start The start of the range.
		     * @param {number} end The end of the range.
		     * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
		     */
		    function baseInRange(number, start, end) {
		      return number >= nativeMin(start, end) && number < nativeMax(start, end);
		    }

		    /**
		     * The base implementation of methods like `_.intersection`, without support
		     * for iteratee shorthands, that accepts an array of arrays to inspect.
		     *
		     * @private
		     * @param {Array} arrays The arrays to inspect.
		     * @param {Function} [iteratee] The iteratee invoked per element.
		     * @param {Function} [comparator] The comparator invoked per element.
		     * @returns {Array} Returns the new array of shared values.
		     */
		    function baseIntersection(arrays, iteratee, comparator) {
		      var includes = comparator ? arrayIncludesWith : arrayIncludes,
		          length = arrays[0].length,
		          othLength = arrays.length,
		          othIndex = othLength,
		          caches = Array(othLength),
		          maxLength = Infinity,
		          result = [];

		      while (othIndex--) {
		        var array = arrays[othIndex];
		        if (othIndex && iteratee) {
		          array = arrayMap(array, baseUnary(iteratee));
		        }
		        maxLength = nativeMin(array.length, maxLength);
		        caches[othIndex] = !comparator && (iteratee || (length >= 120 && array.length >= 120))
		          ? new SetCache(othIndex && array)
		          : undefined$1;
		      }
		      array = arrays[0];

		      var index = -1,
		          seen = caches[0];

		      outer:
		      while (++index < length && result.length < maxLength) {
		        var value = array[index],
		            computed = iteratee ? iteratee(value) : value;

		        value = (comparator || value !== 0) ? value : 0;
		        if (!(seen
		              ? cacheHas(seen, computed)
		              : includes(result, computed, comparator)
		            )) {
		          othIndex = othLength;
		          while (--othIndex) {
		            var cache = caches[othIndex];
		            if (!(cache
		                  ? cacheHas(cache, computed)
		                  : includes(arrays[othIndex], computed, comparator))
		                ) {
		              continue outer;
		            }
		          }
		          if (seen) {
		            seen.push(computed);
		          }
		          result.push(value);
		        }
		      }
		      return result;
		    }

		    /**
		     * The base implementation of `_.invert` and `_.invertBy` which inverts
		     * `object` with values transformed by `iteratee` and set by `setter`.
		     *
		     * @private
		     * @param {Object} object The object to iterate over.
		     * @param {Function} setter The function to set `accumulator` values.
		     * @param {Function} iteratee The iteratee to transform values.
		     * @param {Object} accumulator The initial inverted object.
		     * @returns {Function} Returns `accumulator`.
		     */
		    function baseInverter(object, setter, iteratee, accumulator) {
		      baseForOwn(object, function(value, key, object) {
		        setter(accumulator, iteratee(value), key, object);
		      });
		      return accumulator;
		    }

		    /**
		     * The base implementation of `_.invoke` without support for individual
		     * method arguments.
		     *
		     * @private
		     * @param {Object} object The object to query.
		     * @param {Array|string} path The path of the method to invoke.
		     * @param {Array} args The arguments to invoke the method with.
		     * @returns {*} Returns the result of the invoked method.
		     */
		    function baseInvoke(object, path, args) {
		      path = castPath(path, object);
		      object = parent(object, path);
		      var func = object == null ? object : object[toKey(last(path))];
		      return func == null ? undefined$1 : apply(func, object, args);
		    }

		    /**
		     * The base implementation of `_.isArguments`.
		     *
		     * @private
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
		     */
		    function baseIsArguments(value) {
		      return isObjectLike(value) && baseGetTag(value) == argsTag;
		    }

		    /**
		     * The base implementation of `_.isArrayBuffer` without Node.js optimizations.
		     *
		     * @private
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.
		     */
		    function baseIsArrayBuffer(value) {
		      return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
		    }

		    /**
		     * The base implementation of `_.isDate` without Node.js optimizations.
		     *
		     * @private
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is a date object, else `false`.
		     */
		    function baseIsDate(value) {
		      return isObjectLike(value) && baseGetTag(value) == dateTag;
		    }

		    /**
		     * The base implementation of `_.isEqual` which supports partial comparisons
		     * and tracks traversed objects.
		     *
		     * @private
		     * @param {*} value The value to compare.
		     * @param {*} other The other value to compare.
		     * @param {boolean} bitmask The bitmask flags.
		     *  1 - Unordered comparison
		     *  2 - Partial comparison
		     * @param {Function} [customizer] The function to customize comparisons.
		     * @param {Object} [stack] Tracks traversed `value` and `other` objects.
		     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
		     */
		    function baseIsEqual(value, other, bitmask, customizer, stack) {
		      if (value === other) {
		        return true;
		      }
		      if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {
		        return value !== value && other !== other;
		      }
		      return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
		    }

		    /**
		     * A specialized version of `baseIsEqual` for arrays and objects which performs
		     * deep comparisons and tracks traversed objects enabling objects with circular
		     * references to be compared.
		     *
		     * @private
		     * @param {Object} object The object to compare.
		     * @param {Object} other The other object to compare.
		     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
		     * @param {Function} customizer The function to customize comparisons.
		     * @param {Function} equalFunc The function to determine equivalents of values.
		     * @param {Object} [stack] Tracks traversed `object` and `other` objects.
		     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
		     */
		    function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
		      var objIsArr = isArray(object),
		          othIsArr = isArray(other),
		          objTag = objIsArr ? arrayTag : getTag(object),
		          othTag = othIsArr ? arrayTag : getTag(other);

		      objTag = objTag == argsTag ? objectTag : objTag;
		      othTag = othTag == argsTag ? objectTag : othTag;

		      var objIsObj = objTag == objectTag,
		          othIsObj = othTag == objectTag,
		          isSameTag = objTag == othTag;

		      if (isSameTag && isBuffer(object)) {
		        if (!isBuffer(other)) {
		          return false;
		        }
		        objIsArr = true;
		        objIsObj = false;
		      }
		      if (isSameTag && !objIsObj) {
		        stack || (stack = new Stack);
		        return (objIsArr || isTypedArray(object))
		          ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)
		          : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
		      }
		      if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
		        var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
		            othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

		        if (objIsWrapped || othIsWrapped) {
		          var objUnwrapped = objIsWrapped ? object.value() : object,
		              othUnwrapped = othIsWrapped ? other.value() : other;

		          stack || (stack = new Stack);
		          return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
		        }
		      }
		      if (!isSameTag) {
		        return false;
		      }
		      stack || (stack = new Stack);
		      return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
		    }

		    /**
		     * The base implementation of `_.isMap` without Node.js optimizations.
		     *
		     * @private
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is a map, else `false`.
		     */
		    function baseIsMap(value) {
		      return isObjectLike(value) && getTag(value) == mapTag;
		    }

		    /**
		     * The base implementation of `_.isMatch` without support for iteratee shorthands.
		     *
		     * @private
		     * @param {Object} object The object to inspect.
		     * @param {Object} source The object of property values to match.
		     * @param {Array} matchData The property names, values, and compare flags to match.
		     * @param {Function} [customizer] The function to customize comparisons.
		     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
		     */
		    function baseIsMatch(object, source, matchData, customizer) {
		      var index = matchData.length,
		          length = index,
		          noCustomizer = !customizer;

		      if (object == null) {
		        return !length;
		      }
		      object = Object(object);
		      while (index--) {
		        var data = matchData[index];
		        if ((noCustomizer && data[2])
		              ? data[1] !== object[data[0]]
		              : !(data[0] in object)
		            ) {
		          return false;
		        }
		      }
		      while (++index < length) {
		        data = matchData[index];
		        var key = data[0],
		            objValue = object[key],
		            srcValue = data[1];

		        if (noCustomizer && data[2]) {
		          if (objValue === undefined$1 && !(key in object)) {
		            return false;
		          }
		        } else {
		          var stack = new Stack;
		          if (customizer) {
		            var result = customizer(objValue, srcValue, key, object, source, stack);
		          }
		          if (!(result === undefined$1
		                ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack)
		                : result
		              )) {
		            return false;
		          }
		        }
		      }
		      return true;
		    }

		    /**
		     * The base implementation of `_.isNative` without bad shim checks.
		     *
		     * @private
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is a native function,
		     *  else `false`.
		     */
		    function baseIsNative(value) {
		      if (!isObject(value) || isMasked(value)) {
		        return false;
		      }
		      var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
		      return pattern.test(toSource(value));
		    }

		    /**
		     * The base implementation of `_.isRegExp` without Node.js optimizations.
		     *
		     * @private
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
		     */
		    function baseIsRegExp(value) {
		      return isObjectLike(value) && baseGetTag(value) == regexpTag;
		    }

		    /**
		     * The base implementation of `_.isSet` without Node.js optimizations.
		     *
		     * @private
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is a set, else `false`.
		     */
		    function baseIsSet(value) {
		      return isObjectLike(value) && getTag(value) == setTag;
		    }

		    /**
		     * The base implementation of `_.isTypedArray` without Node.js optimizations.
		     *
		     * @private
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
		     */
		    function baseIsTypedArray(value) {
		      return isObjectLike(value) &&
		        isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
		    }

		    /**
		     * The base implementation of `_.iteratee`.
		     *
		     * @private
		     * @param {*} [value=_.identity] The value to convert to an iteratee.
		     * @returns {Function} Returns the iteratee.
		     */
		    function baseIteratee(value) {
		      // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
		      // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
		      if (typeof value == 'function') {
		        return value;
		      }
		      if (value == null) {
		        return identity;
		      }
		      if (typeof value == 'object') {
		        return isArray(value)
		          ? baseMatchesProperty(value[0], value[1])
		          : baseMatches(value);
		      }
		      return property(value);
		    }

		    /**
		     * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
		     *
		     * @private
		     * @param {Object} object The object to query.
		     * @returns {Array} Returns the array of property names.
		     */
		    function baseKeys(object) {
		      if (!isPrototype(object)) {
		        return nativeKeys(object);
		      }
		      var result = [];
		      for (var key in Object(object)) {
		        if (hasOwnProperty.call(object, key) && key != 'constructor') {
		          result.push(key);
		        }
		      }
		      return result;
		    }

		    /**
		     * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
		     *
		     * @private
		     * @param {Object} object The object to query.
		     * @returns {Array} Returns the array of property names.
		     */
		    function baseKeysIn(object) {
		      if (!isObject(object)) {
		        return nativeKeysIn(object);
		      }
		      var isProto = isPrototype(object),
		          result = [];

		      for (var key in object) {
		        if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
		          result.push(key);
		        }
		      }
		      return result;
		    }

		    /**
		     * The base implementation of `_.lt` which doesn't coerce arguments.
		     *
		     * @private
		     * @param {*} value The value to compare.
		     * @param {*} other The other value to compare.
		     * @returns {boolean} Returns `true` if `value` is less than `other`,
		     *  else `false`.
		     */
		    function baseLt(value, other) {
		      return value < other;
		    }

		    /**
		     * The base implementation of `_.map` without support for iteratee shorthands.
		     *
		     * @private
		     * @param {Array|Object} collection The collection to iterate over.
		     * @param {Function} iteratee The function invoked per iteration.
		     * @returns {Array} Returns the new mapped array.
		     */
		    function baseMap(collection, iteratee) {
		      var index = -1,
		          result = isArrayLike(collection) ? Array(collection.length) : [];

		      baseEach(collection, function(value, key, collection) {
		        result[++index] = iteratee(value, key, collection);
		      });
		      return result;
		    }

		    /**
		     * The base implementation of `_.matches` which doesn't clone `source`.
		     *
		     * @private
		     * @param {Object} source The object of property values to match.
		     * @returns {Function} Returns the new spec function.
		     */
		    function baseMatches(source) {
		      var matchData = getMatchData(source);
		      if (matchData.length == 1 && matchData[0][2]) {
		        return matchesStrictComparable(matchData[0][0], matchData[0][1]);
		      }
		      return function(object) {
		        return object === source || baseIsMatch(object, source, matchData);
		      };
		    }

		    /**
		     * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
		     *
		     * @private
		     * @param {string} path The path of the property to get.
		     * @param {*} srcValue The value to match.
		     * @returns {Function} Returns the new spec function.
		     */
		    function baseMatchesProperty(path, srcValue) {
		      if (isKey(path) && isStrictComparable(srcValue)) {
		        return matchesStrictComparable(toKey(path), srcValue);
		      }
		      return function(object) {
		        var objValue = get(object, path);
		        return (objValue === undefined$1 && objValue === srcValue)
		          ? hasIn(object, path)
		          : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
		      };
		    }

		    /**
		     * The base implementation of `_.merge` without support for multiple sources.
		     *
		     * @private
		     * @param {Object} object The destination object.
		     * @param {Object} source The source object.
		     * @param {number} srcIndex The index of `source`.
		     * @param {Function} [customizer] The function to customize merged values.
		     * @param {Object} [stack] Tracks traversed source values and their merged
		     *  counterparts.
		     */
		    function baseMerge(object, source, srcIndex, customizer, stack) {
		      if (object === source) {
		        return;
		      }
		      baseFor(source, function(srcValue, key) {
		        stack || (stack = new Stack);
		        if (isObject(srcValue)) {
		          baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
		        }
		        else {
		          var newValue = customizer
		            ? customizer(safeGet(object, key), srcValue, (key + ''), object, source, stack)
		            : undefined$1;

		          if (newValue === undefined$1) {
		            newValue = srcValue;
		          }
		          assignMergeValue(object, key, newValue);
		        }
		      }, keysIn);
		    }

		    /**
		     * A specialized version of `baseMerge` for arrays and objects which performs
		     * deep merges and tracks traversed objects enabling objects with circular
		     * references to be merged.
		     *
		     * @private
		     * @param {Object} object The destination object.
		     * @param {Object} source The source object.
		     * @param {string} key The key of the value to merge.
		     * @param {number} srcIndex The index of `source`.
		     * @param {Function} mergeFunc The function to merge values.
		     * @param {Function} [customizer] The function to customize assigned values.
		     * @param {Object} [stack] Tracks traversed source values and their merged
		     *  counterparts.
		     */
		    function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
		      var objValue = safeGet(object, key),
		          srcValue = safeGet(source, key),
		          stacked = stack.get(srcValue);

		      if (stacked) {
		        assignMergeValue(object, key, stacked);
		        return;
		      }
		      var newValue = customizer
		        ? customizer(objValue, srcValue, (key + ''), object, source, stack)
		        : undefined$1;

		      var isCommon = newValue === undefined$1;

		      if (isCommon) {
		        var isArr = isArray(srcValue),
		            isBuff = !isArr && isBuffer(srcValue),
		            isTyped = !isArr && !isBuff && isTypedArray(srcValue);

		        newValue = srcValue;
		        if (isArr || isBuff || isTyped) {
		          if (isArray(objValue)) {
		            newValue = objValue;
		          }
		          else if (isArrayLikeObject(objValue)) {
		            newValue = copyArray(objValue);
		          }
		          else if (isBuff) {
		            isCommon = false;
		            newValue = cloneBuffer(srcValue, true);
		          }
		          else if (isTyped) {
		            isCommon = false;
		            newValue = cloneTypedArray(srcValue, true);
		          }
		          else {
		            newValue = [];
		          }
		        }
		        else if (isPlainObject(srcValue) || isArguments(srcValue)) {
		          newValue = objValue;
		          if (isArguments(objValue)) {
		            newValue = toPlainObject(objValue);
		          }
		          else if (!isObject(objValue) || isFunction(objValue)) {
		            newValue = initCloneObject(srcValue);
		          }
		        }
		        else {
		          isCommon = false;
		        }
		      }
		      if (isCommon) {
		        // Recursively merge objects and arrays (susceptible to call stack limits).
		        stack.set(srcValue, newValue);
		        mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
		        stack['delete'](srcValue);
		      }
		      assignMergeValue(object, key, newValue);
		    }

		    /**
		     * The base implementation of `_.nth` which doesn't coerce arguments.
		     *
		     * @private
		     * @param {Array} array The array to query.
		     * @param {number} n The index of the element to return.
		     * @returns {*} Returns the nth element of `array`.
		     */
		    function baseNth(array, n) {
		      var length = array.length;
		      if (!length) {
		        return;
		      }
		      n += n < 0 ? length : 0;
		      return isIndex(n, length) ? array[n] : undefined$1;
		    }

		    /**
		     * The base implementation of `_.orderBy` without param guards.
		     *
		     * @private
		     * @param {Array|Object} collection The collection to iterate over.
		     * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
		     * @param {string[]} orders The sort orders of `iteratees`.
		     * @returns {Array} Returns the new sorted array.
		     */
		    function baseOrderBy(collection, iteratees, orders) {
		      if (iteratees.length) {
		        iteratees = arrayMap(iteratees, function(iteratee) {
		          if (isArray(iteratee)) {
		            return function(value) {
		              return baseGet(value, iteratee.length === 1 ? iteratee[0] : iteratee);
		            }
		          }
		          return iteratee;
		        });
		      } else {
		        iteratees = [identity];
		      }

		      var index = -1;
		      iteratees = arrayMap(iteratees, baseUnary(getIteratee()));

		      var result = baseMap(collection, function(value, key, collection) {
		        var criteria = arrayMap(iteratees, function(iteratee) {
		          return iteratee(value);
		        });
		        return { 'criteria': criteria, 'index': ++index, 'value': value };
		      });

		      return baseSortBy(result, function(object, other) {
		        return compareMultiple(object, other, orders);
		      });
		    }

		    /**
		     * The base implementation of `_.pick` without support for individual
		     * property identifiers.
		     *
		     * @private
		     * @param {Object} object The source object.
		     * @param {string[]} paths The property paths to pick.
		     * @returns {Object} Returns the new object.
		     */
		    function basePick(object, paths) {
		      return basePickBy(object, paths, function(value, path) {
		        return hasIn(object, path);
		      });
		    }

		    /**
		     * The base implementation of  `_.pickBy` without support for iteratee shorthands.
		     *
		     * @private
		     * @param {Object} object The source object.
		     * @param {string[]} paths The property paths to pick.
		     * @param {Function} predicate The function invoked per property.
		     * @returns {Object} Returns the new object.
		     */
		    function basePickBy(object, paths, predicate) {
		      var index = -1,
		          length = paths.length,
		          result = {};

		      while (++index < length) {
		        var path = paths[index],
		            value = baseGet(object, path);

		        if (predicate(value, path)) {
		          baseSet(result, castPath(path, object), value);
		        }
		      }
		      return result;
		    }

		    /**
		     * A specialized version of `baseProperty` which supports deep paths.
		     *
		     * @private
		     * @param {Array|string} path The path of the property to get.
		     * @returns {Function} Returns the new accessor function.
		     */
		    function basePropertyDeep(path) {
		      return function(object) {
		        return baseGet(object, path);
		      };
		    }

		    /**
		     * The base implementation of `_.pullAllBy` without support for iteratee
		     * shorthands.
		     *
		     * @private
		     * @param {Array} array The array to modify.
		     * @param {Array} values The values to remove.
		     * @param {Function} [iteratee] The iteratee invoked per element.
		     * @param {Function} [comparator] The comparator invoked per element.
		     * @returns {Array} Returns `array`.
		     */
		    function basePullAll(array, values, iteratee, comparator) {
		      var indexOf = comparator ? baseIndexOfWith : baseIndexOf,
		          index = -1,
		          length = values.length,
		          seen = array;

		      if (array === values) {
		        values = copyArray(values);
		      }
		      if (iteratee) {
		        seen = arrayMap(array, baseUnary(iteratee));
		      }
		      while (++index < length) {
		        var fromIndex = 0,
		            value = values[index],
		            computed = iteratee ? iteratee(value) : value;

		        while ((fromIndex = indexOf(seen, computed, fromIndex, comparator)) > -1) {
		          if (seen !== array) {
		            splice.call(seen, fromIndex, 1);
		          }
		          splice.call(array, fromIndex, 1);
		        }
		      }
		      return array;
		    }

		    /**
		     * The base implementation of `_.pullAt` without support for individual
		     * indexes or capturing the removed elements.
		     *
		     * @private
		     * @param {Array} array The array to modify.
		     * @param {number[]} indexes The indexes of elements to remove.
		     * @returns {Array} Returns `array`.
		     */
		    function basePullAt(array, indexes) {
		      var length = array ? indexes.length : 0,
		          lastIndex = length - 1;

		      while (length--) {
		        var index = indexes[length];
		        if (length == lastIndex || index !== previous) {
		          var previous = index;
		          if (isIndex(index)) {
		            splice.call(array, index, 1);
		          } else {
		            baseUnset(array, index);
		          }
		        }
		      }
		      return array;
		    }

		    /**
		     * The base implementation of `_.random` without support for returning
		     * floating-point numbers.
		     *
		     * @private
		     * @param {number} lower The lower bound.
		     * @param {number} upper The upper bound.
		     * @returns {number} Returns the random number.
		     */
		    function baseRandom(lower, upper) {
		      return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
		    }

		    /**
		     * The base implementation of `_.range` and `_.rangeRight` which doesn't
		     * coerce arguments.
		     *
		     * @private
		     * @param {number} start The start of the range.
		     * @param {number} end The end of the range.
		     * @param {number} step The value to increment or decrement by.
		     * @param {boolean} [fromRight] Specify iterating from right to left.
		     * @returns {Array} Returns the range of numbers.
		     */
		    function baseRange(start, end, step, fromRight) {
		      var index = -1,
		          length = nativeMax(nativeCeil((end - start) / (step || 1)), 0),
		          result = Array(length);

		      while (length--) {
		        result[fromRight ? length : ++index] = start;
		        start += step;
		      }
		      return result;
		    }

		    /**
		     * The base implementation of `_.repeat` which doesn't coerce arguments.
		     *
		     * @private
		     * @param {string} string The string to repeat.
		     * @param {number} n The number of times to repeat the string.
		     * @returns {string} Returns the repeated string.
		     */
		    function baseRepeat(string, n) {
		      var result = '';
		      if (!string || n < 1 || n > MAX_SAFE_INTEGER) {
		        return result;
		      }
		      // Leverage the exponentiation by squaring algorithm for a faster repeat.
		      // See https://en.wikipedia.org/wiki/Exponentiation_by_squaring for more details.
		      do {
		        if (n % 2) {
		          result += string;
		        }
		        n = nativeFloor(n / 2);
		        if (n) {
		          string += string;
		        }
		      } while (n);

		      return result;
		    }

		    /**
		     * The base implementation of `_.rest` which doesn't validate or coerce arguments.
		     *
		     * @private
		     * @param {Function} func The function to apply a rest parameter to.
		     * @param {number} [start=func.length-1] The start position of the rest parameter.
		     * @returns {Function} Returns the new function.
		     */
		    function baseRest(func, start) {
		      return setToString(overRest(func, start, identity), func + '');
		    }

		    /**
		     * The base implementation of `_.sample`.
		     *
		     * @private
		     * @param {Array|Object} collection The collection to sample.
		     * @returns {*} Returns the random element.
		     */
		    function baseSample(collection) {
		      return arraySample(values(collection));
		    }

		    /**
		     * The base implementation of `_.sampleSize` without param guards.
		     *
		     * @private
		     * @param {Array|Object} collection The collection to sample.
		     * @param {number} n The number of elements to sample.
		     * @returns {Array} Returns the random elements.
		     */
		    function baseSampleSize(collection, n) {
		      var array = values(collection);
		      return shuffleSelf(array, baseClamp(n, 0, array.length));
		    }

		    /**
		     * The base implementation of `_.set`.
		     *
		     * @private
		     * @param {Object} object The object to modify.
		     * @param {Array|string} path The path of the property to set.
		     * @param {*} value The value to set.
		     * @param {Function} [customizer] The function to customize path creation.
		     * @returns {Object} Returns `object`.
		     */
		    function baseSet(object, path, value, customizer) {
		      if (!isObject(object)) {
		        return object;
		      }
		      path = castPath(path, object);

		      var index = -1,
		          length = path.length,
		          lastIndex = length - 1,
		          nested = object;

		      while (nested != null && ++index < length) {
		        var key = toKey(path[index]),
		            newValue = value;

		        if (key === '__proto__' || key === 'constructor' || key === 'prototype') {
		          return object;
		        }

		        if (index != lastIndex) {
		          var objValue = nested[key];
		          newValue = customizer ? customizer(objValue, key, nested) : undefined$1;
		          if (newValue === undefined$1) {
		            newValue = isObject(objValue)
		              ? objValue
		              : (isIndex(path[index + 1]) ? [] : {});
		          }
		        }
		        assignValue(nested, key, newValue);
		        nested = nested[key];
		      }
		      return object;
		    }

		    /**
		     * The base implementation of `setData` without support for hot loop shorting.
		     *
		     * @private
		     * @param {Function} func The function to associate metadata with.
		     * @param {*} data The metadata.
		     * @returns {Function} Returns `func`.
		     */
		    var baseSetData = !metaMap ? identity : function(func, data) {
		      metaMap.set(func, data);
		      return func;
		    };

		    /**
		     * The base implementation of `setToString` without support for hot loop shorting.
		     *
		     * @private
		     * @param {Function} func The function to modify.
		     * @param {Function} string The `toString` result.
		     * @returns {Function} Returns `func`.
		     */
		    var baseSetToString = !defineProperty ? identity : function(func, string) {
		      return defineProperty(func, 'toString', {
		        'configurable': true,
		        'enumerable': false,
		        'value': constant(string),
		        'writable': true
		      });
		    };

		    /**
		     * The base implementation of `_.shuffle`.
		     *
		     * @private
		     * @param {Array|Object} collection The collection to shuffle.
		     * @returns {Array} Returns the new shuffled array.
		     */
		    function baseShuffle(collection) {
		      return shuffleSelf(values(collection));
		    }

		    /**
		     * The base implementation of `_.slice` without an iteratee call guard.
		     *
		     * @private
		     * @param {Array} array The array to slice.
		     * @param {number} [start=0] The start position.
		     * @param {number} [end=array.length] The end position.
		     * @returns {Array} Returns the slice of `array`.
		     */
		    function baseSlice(array, start, end) {
		      var index = -1,
		          length = array.length;

		      if (start < 0) {
		        start = -start > length ? 0 : (length + start);
		      }
		      end = end > length ? length : end;
		      if (end < 0) {
		        end += length;
		      }
		      length = start > end ? 0 : ((end - start) >>> 0);
		      start >>>= 0;

		      var result = Array(length);
		      while (++index < length) {
		        result[index] = array[index + start];
		      }
		      return result;
		    }

		    /**
		     * The base implementation of `_.some` without support for iteratee shorthands.
		     *
		     * @private
		     * @param {Array|Object} collection The collection to iterate over.
		     * @param {Function} predicate The function invoked per iteration.
		     * @returns {boolean} Returns `true` if any element passes the predicate check,
		     *  else `false`.
		     */
		    function baseSome(collection, predicate) {
		      var result;

		      baseEach(collection, function(value, index, collection) {
		        result = predicate(value, index, collection);
		        return !result;
		      });
		      return !!result;
		    }

		    /**
		     * The base implementation of `_.sortedIndex` and `_.sortedLastIndex` which
		     * performs a binary search of `array` to determine the index at which `value`
		     * should be inserted into `array` in order to maintain its sort order.
		     *
		     * @private
		     * @param {Array} array The sorted array to inspect.
		     * @param {*} value The value to evaluate.
		     * @param {boolean} [retHighest] Specify returning the highest qualified index.
		     * @returns {number} Returns the index at which `value` should be inserted
		     *  into `array`.
		     */
		    function baseSortedIndex(array, value, retHighest) {
		      var low = 0,
		          high = array == null ? low : array.length;

		      if (typeof value == 'number' && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
		        while (low < high) {
		          var mid = (low + high) >>> 1,
		              computed = array[mid];

		          if (computed !== null && !isSymbol(computed) &&
		              (retHighest ? (computed <= value) : (computed < value))) {
		            low = mid + 1;
		          } else {
		            high = mid;
		          }
		        }
		        return high;
		      }
		      return baseSortedIndexBy(array, value, identity, retHighest);
		    }

		    /**
		     * The base implementation of `_.sortedIndexBy` and `_.sortedLastIndexBy`
		     * which invokes `iteratee` for `value` and each element of `array` to compute
		     * their sort ranking. The iteratee is invoked with one argument; (value).
		     *
		     * @private
		     * @param {Array} array The sorted array to inspect.
		     * @param {*} value The value to evaluate.
		     * @param {Function} iteratee The iteratee invoked per element.
		     * @param {boolean} [retHighest] Specify returning the highest qualified index.
		     * @returns {number} Returns the index at which `value` should be inserted
		     *  into `array`.
		     */
		    function baseSortedIndexBy(array, value, iteratee, retHighest) {
		      var low = 0,
		          high = array == null ? 0 : array.length;
		      if (high === 0) {
		        return 0;
		      }

		      value = iteratee(value);
		      var valIsNaN = value !== value,
		          valIsNull = value === null,
		          valIsSymbol = isSymbol(value),
		          valIsUndefined = value === undefined$1;

		      while (low < high) {
		        var mid = nativeFloor((low + high) / 2),
		            computed = iteratee(array[mid]),
		            othIsDefined = computed !== undefined$1,
		            othIsNull = computed === null,
		            othIsReflexive = computed === computed,
		            othIsSymbol = isSymbol(computed);

		        if (valIsNaN) {
		          var setLow = retHighest || othIsReflexive;
		        } else if (valIsUndefined) {
		          setLow = othIsReflexive && (retHighest || othIsDefined);
		        } else if (valIsNull) {
		          setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
		        } else if (valIsSymbol) {
		          setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
		        } else if (othIsNull || othIsSymbol) {
		          setLow = false;
		        } else {
		          setLow = retHighest ? (computed <= value) : (computed < value);
		        }
		        if (setLow) {
		          low = mid + 1;
		        } else {
		          high = mid;
		        }
		      }
		      return nativeMin(high, MAX_ARRAY_INDEX);
		    }

		    /**
		     * The base implementation of `_.sortedUniq` and `_.sortedUniqBy` without
		     * support for iteratee shorthands.
		     *
		     * @private
		     * @param {Array} array The array to inspect.
		     * @param {Function} [iteratee] The iteratee invoked per element.
		     * @returns {Array} Returns the new duplicate free array.
		     */
		    function baseSortedUniq(array, iteratee) {
		      var index = -1,
		          length = array.length,
		          resIndex = 0,
		          result = [];

		      while (++index < length) {
		        var value = array[index],
		            computed = iteratee ? iteratee(value) : value;

		        if (!index || !eq(computed, seen)) {
		          var seen = computed;
		          result[resIndex++] = value === 0 ? 0 : value;
		        }
		      }
		      return result;
		    }

		    /**
		     * The base implementation of `_.toNumber` which doesn't ensure correct
		     * conversions of binary, hexadecimal, or octal string values.
		     *
		     * @private
		     * @param {*} value The value to process.
		     * @returns {number} Returns the number.
		     */
		    function baseToNumber(value) {
		      if (typeof value == 'number') {
		        return value;
		      }
		      if (isSymbol(value)) {
		        return NAN;
		      }
		      return +value;
		    }

		    /**
		     * The base implementation of `_.toString` which doesn't convert nullish
		     * values to empty strings.
		     *
		     * @private
		     * @param {*} value The value to process.
		     * @returns {string} Returns the string.
		     */
		    function baseToString(value) {
		      // Exit early for strings to avoid a performance hit in some environments.
		      if (typeof value == 'string') {
		        return value;
		      }
		      if (isArray(value)) {
		        // Recursively convert values (susceptible to call stack limits).
		        return arrayMap(value, baseToString) + '';
		      }
		      if (isSymbol(value)) {
		        return symbolToString ? symbolToString.call(value) : '';
		      }
		      var result = (value + '');
		      return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
		    }

		    /**
		     * The base implementation of `_.uniqBy` without support for iteratee shorthands.
		     *
		     * @private
		     * @param {Array} array The array to inspect.
		     * @param {Function} [iteratee] The iteratee invoked per element.
		     * @param {Function} [comparator] The comparator invoked per element.
		     * @returns {Array} Returns the new duplicate free array.
		     */
		    function baseUniq(array, iteratee, comparator) {
		      var index = -1,
		          includes = arrayIncludes,
		          length = array.length,
		          isCommon = true,
		          result = [],
		          seen = result;

		      if (comparator) {
		        isCommon = false;
		        includes = arrayIncludesWith;
		      }
		      else if (length >= LARGE_ARRAY_SIZE) {
		        var set = iteratee ? null : createSet(array);
		        if (set) {
		          return setToArray(set);
		        }
		        isCommon = false;
		        includes = cacheHas;
		        seen = new SetCache;
		      }
		      else {
		        seen = iteratee ? [] : result;
		      }
		      outer:
		      while (++index < length) {
		        var value = array[index],
		            computed = iteratee ? iteratee(value) : value;

		        value = (comparator || value !== 0) ? value : 0;
		        if (isCommon && computed === computed) {
		          var seenIndex = seen.length;
		          while (seenIndex--) {
		            if (seen[seenIndex] === computed) {
		              continue outer;
		            }
		          }
		          if (iteratee) {
		            seen.push(computed);
		          }
		          result.push(value);
		        }
		        else if (!includes(seen, computed, comparator)) {
		          if (seen !== result) {
		            seen.push(computed);
		          }
		          result.push(value);
		        }
		      }
		      return result;
		    }

		    /**
		     * The base implementation of `_.unset`.
		     *
		     * @private
		     * @param {Object} object The object to modify.
		     * @param {Array|string} path The property path to unset.
		     * @returns {boolean} Returns `true` if the property is deleted, else `false`.
		     */
		    function baseUnset(object, path) {
		      path = castPath(path, object);
		      object = parent(object, path);
		      return object == null || delete object[toKey(last(path))];
		    }

		    /**
		     * The base implementation of `_.update`.
		     *
		     * @private
		     * @param {Object} object The object to modify.
		     * @param {Array|string} path The path of the property to update.
		     * @param {Function} updater The function to produce the updated value.
		     * @param {Function} [customizer] The function to customize path creation.
		     * @returns {Object} Returns `object`.
		     */
		    function baseUpdate(object, path, updater, customizer) {
		      return baseSet(object, path, updater(baseGet(object, path)), customizer);
		    }

		    /**
		     * The base implementation of methods like `_.dropWhile` and `_.takeWhile`
		     * without support for iteratee shorthands.
		     *
		     * @private
		     * @param {Array} array The array to query.
		     * @param {Function} predicate The function invoked per iteration.
		     * @param {boolean} [isDrop] Specify dropping elements instead of taking them.
		     * @param {boolean} [fromRight] Specify iterating from right to left.
		     * @returns {Array} Returns the slice of `array`.
		     */
		    function baseWhile(array, predicate, isDrop, fromRight) {
		      var length = array.length,
		          index = fromRight ? length : -1;

		      while ((fromRight ? index-- : ++index < length) &&
		        predicate(array[index], index, array)) {}

		      return isDrop
		        ? baseSlice(array, (fromRight ? 0 : index), (fromRight ? index + 1 : length))
		        : baseSlice(array, (fromRight ? index + 1 : 0), (fromRight ? length : index));
		    }

		    /**
		     * The base implementation of `wrapperValue` which returns the result of
		     * performing a sequence of actions on the unwrapped `value`, where each
		     * successive action is supplied the return value of the previous.
		     *
		     * @private
		     * @param {*} value The unwrapped value.
		     * @param {Array} actions Actions to perform to resolve the unwrapped value.
		     * @returns {*} Returns the resolved value.
		     */
		    function baseWrapperValue(value, actions) {
		      var result = value;
		      if (result instanceof LazyWrapper) {
		        result = result.value();
		      }
		      return arrayReduce(actions, function(result, action) {
		        return action.func.apply(action.thisArg, arrayPush([result], action.args));
		      }, result);
		    }

		    /**
		     * The base implementation of methods like `_.xor`, without support for
		     * iteratee shorthands, that accepts an array of arrays to inspect.
		     *
		     * @private
		     * @param {Array} arrays The arrays to inspect.
		     * @param {Function} [iteratee] The iteratee invoked per element.
		     * @param {Function} [comparator] The comparator invoked per element.
		     * @returns {Array} Returns the new array of values.
		     */
		    function baseXor(arrays, iteratee, comparator) {
		      var length = arrays.length;
		      if (length < 2) {
		        return length ? baseUniq(arrays[0]) : [];
		      }
		      var index = -1,
		          result = Array(length);

		      while (++index < length) {
		        var array = arrays[index],
		            othIndex = -1;

		        while (++othIndex < length) {
		          if (othIndex != index) {
		            result[index] = baseDifference(result[index] || array, arrays[othIndex], iteratee, comparator);
		          }
		        }
		      }
		      return baseUniq(baseFlatten(result, 1), iteratee, comparator);
		    }

		    /**
		     * This base implementation of `_.zipObject` which assigns values using `assignFunc`.
		     *
		     * @private
		     * @param {Array} props The property identifiers.
		     * @param {Array} values The property values.
		     * @param {Function} assignFunc The function to assign values.
		     * @returns {Object} Returns the new object.
		     */
		    function baseZipObject(props, values, assignFunc) {
		      var index = -1,
		          length = props.length,
		          valsLength = values.length,
		          result = {};

		      while (++index < length) {
		        var value = index < valsLength ? values[index] : undefined$1;
		        assignFunc(result, props[index], value);
		      }
		      return result;
		    }

		    /**
		     * Casts `value` to an empty array if it's not an array like object.
		     *
		     * @private
		     * @param {*} value The value to inspect.
		     * @returns {Array|Object} Returns the cast array-like object.
		     */
		    function castArrayLikeObject(value) {
		      return isArrayLikeObject(value) ? value : [];
		    }

		    /**
		     * Casts `value` to `identity` if it's not a function.
		     *
		     * @private
		     * @param {*} value The value to inspect.
		     * @returns {Function} Returns cast function.
		     */
		    function castFunction(value) {
		      return typeof value == 'function' ? value : identity;
		    }

		    /**
		     * Casts `value` to a path array if it's not one.
		     *
		     * @private
		     * @param {*} value The value to inspect.
		     * @param {Object} [object] The object to query keys on.
		     * @returns {Array} Returns the cast property path array.
		     */
		    function castPath(value, object) {
		      if (isArray(value)) {
		        return value;
		      }
		      return isKey(value, object) ? [value] : stringToPath(toString(value));
		    }

		    /**
		     * A `baseRest` alias which can be replaced with `identity` by module
		     * replacement plugins.
		     *
		     * @private
		     * @type {Function}
		     * @param {Function} func The function to apply a rest parameter to.
		     * @returns {Function} Returns the new function.
		     */
		    var castRest = baseRest;

		    /**
		     * Casts `array` to a slice if it's needed.
		     *
		     * @private
		     * @param {Array} array The array to inspect.
		     * @param {number} start The start position.
		     * @param {number} [end=array.length] The end position.
		     * @returns {Array} Returns the cast slice.
		     */
		    function castSlice(array, start, end) {
		      var length = array.length;
		      end = end === undefined$1 ? length : end;
		      return (!start && end >= length) ? array : baseSlice(array, start, end);
		    }

		    /**
		     * A simple wrapper around the global [`clearTimeout`](https://mdn.io/clearTimeout).
		     *
		     * @private
		     * @param {number|Object} id The timer id or timeout object of the timer to clear.
		     */
		    var clearTimeout = ctxClearTimeout || function(id) {
		      return root.clearTimeout(id);
		    };

		    /**
		     * Creates a clone of  `buffer`.
		     *
		     * @private
		     * @param {Buffer} buffer The buffer to clone.
		     * @param {boolean} [isDeep] Specify a deep clone.
		     * @returns {Buffer} Returns the cloned buffer.
		     */
		    function cloneBuffer(buffer, isDeep) {
		      if (isDeep) {
		        return buffer.slice();
		      }
		      var length = buffer.length,
		          result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);

		      buffer.copy(result);
		      return result;
		    }

		    /**
		     * Creates a clone of `arrayBuffer`.
		     *
		     * @private
		     * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
		     * @returns {ArrayBuffer} Returns the cloned array buffer.
		     */
		    function cloneArrayBuffer(arrayBuffer) {
		      var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
		      new Uint8Array(result).set(new Uint8Array(arrayBuffer));
		      return result;
		    }

		    /**
		     * Creates a clone of `dataView`.
		     *
		     * @private
		     * @param {Object} dataView The data view to clone.
		     * @param {boolean} [isDeep] Specify a deep clone.
		     * @returns {Object} Returns the cloned data view.
		     */
		    function cloneDataView(dataView, isDeep) {
		      var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
		      return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
		    }

		    /**
		     * Creates a clone of `regexp`.
		     *
		     * @private
		     * @param {Object} regexp The regexp to clone.
		     * @returns {Object} Returns the cloned regexp.
		     */
		    function cloneRegExp(regexp) {
		      var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
		      result.lastIndex = regexp.lastIndex;
		      return result;
		    }

		    /**
		     * Creates a clone of the `symbol` object.
		     *
		     * @private
		     * @param {Object} symbol The symbol object to clone.
		     * @returns {Object} Returns the cloned symbol object.
		     */
		    function cloneSymbol(symbol) {
		      return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
		    }

		    /**
		     * Creates a clone of `typedArray`.
		     *
		     * @private
		     * @param {Object} typedArray The typed array to clone.
		     * @param {boolean} [isDeep] Specify a deep clone.
		     * @returns {Object} Returns the cloned typed array.
		     */
		    function cloneTypedArray(typedArray, isDeep) {
		      var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
		      return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
		    }

		    /**
		     * Compares values to sort them in ascending order.
		     *
		     * @private
		     * @param {*} value The value to compare.
		     * @param {*} other The other value to compare.
		     * @returns {number} Returns the sort order indicator for `value`.
		     */
		    function compareAscending(value, other) {
		      if (value !== other) {
		        var valIsDefined = value !== undefined$1,
		            valIsNull = value === null,
		            valIsReflexive = value === value,
		            valIsSymbol = isSymbol(value);

		        var othIsDefined = other !== undefined$1,
		            othIsNull = other === null,
		            othIsReflexive = other === other,
		            othIsSymbol = isSymbol(other);

		        if ((!othIsNull && !othIsSymbol && !valIsSymbol && value > other) ||
		            (valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol) ||
		            (valIsNull && othIsDefined && othIsReflexive) ||
		            (!valIsDefined && othIsReflexive) ||
		            !valIsReflexive) {
		          return 1;
		        }
		        if ((!valIsNull && !valIsSymbol && !othIsSymbol && value < other) ||
		            (othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol) ||
		            (othIsNull && valIsDefined && valIsReflexive) ||
		            (!othIsDefined && valIsReflexive) ||
		            !othIsReflexive) {
		          return -1;
		        }
		      }
		      return 0;
		    }

		    /**
		     * Used by `_.orderBy` to compare multiple properties of a value to another
		     * and stable sort them.
		     *
		     * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,
		     * specify an order of "desc" for descending or "asc" for ascending sort order
		     * of corresponding values.
		     *
		     * @private
		     * @param {Object} object The object to compare.
		     * @param {Object} other The other object to compare.
		     * @param {boolean[]|string[]} orders The order to sort by for each property.
		     * @returns {number} Returns the sort order indicator for `object`.
		     */
		    function compareMultiple(object, other, orders) {
		      var index = -1,
		          objCriteria = object.criteria,
		          othCriteria = other.criteria,
		          length = objCriteria.length,
		          ordersLength = orders.length;

		      while (++index < length) {
		        var result = compareAscending(objCriteria[index], othCriteria[index]);
		        if (result) {
		          if (index >= ordersLength) {
		            return result;
		          }
		          var order = orders[index];
		          return result * (order == 'desc' ? -1 : 1);
		        }
		      }
		      // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
		      // that causes it, under certain circumstances, to provide the same value for
		      // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247
		      // for more details.
		      //
		      // This also ensures a stable sort in V8 and other engines.
		      // See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.
		      return object.index - other.index;
		    }

		    /**
		     * Creates an array that is the composition of partially applied arguments,
		     * placeholders, and provided arguments into a single array of arguments.
		     *
		     * @private
		     * @param {Array} args The provided arguments.
		     * @param {Array} partials The arguments to prepend to those provided.
		     * @param {Array} holders The `partials` placeholder indexes.
		     * @params {boolean} [isCurried] Specify composing for a curried function.
		     * @returns {Array} Returns the new array of composed arguments.
		     */
		    function composeArgs(args, partials, holders, isCurried) {
		      var argsIndex = -1,
		          argsLength = args.length,
		          holdersLength = holders.length,
		          leftIndex = -1,
		          leftLength = partials.length,
		          rangeLength = nativeMax(argsLength - holdersLength, 0),
		          result = Array(leftLength + rangeLength),
		          isUncurried = !isCurried;

		      while (++leftIndex < leftLength) {
		        result[leftIndex] = partials[leftIndex];
		      }
		      while (++argsIndex < holdersLength) {
		        if (isUncurried || argsIndex < argsLength) {
		          result[holders[argsIndex]] = args[argsIndex];
		        }
		      }
		      while (rangeLength--) {
		        result[leftIndex++] = args[argsIndex++];
		      }
		      return result;
		    }

		    /**
		     * This function is like `composeArgs` except that the arguments composition
		     * is tailored for `_.partialRight`.
		     *
		     * @private
		     * @param {Array} args The provided arguments.
		     * @param {Array} partials The arguments to append to those provided.
		     * @param {Array} holders The `partials` placeholder indexes.
		     * @params {boolean} [isCurried] Specify composing for a curried function.
		     * @returns {Array} Returns the new array of composed arguments.
		     */
		    function composeArgsRight(args, partials, holders, isCurried) {
		      var argsIndex = -1,
		          argsLength = args.length,
		          holdersIndex = -1,
		          holdersLength = holders.length,
		          rightIndex = -1,
		          rightLength = partials.length,
		          rangeLength = nativeMax(argsLength - holdersLength, 0),
		          result = Array(rangeLength + rightLength),
		          isUncurried = !isCurried;

		      while (++argsIndex < rangeLength) {
		        result[argsIndex] = args[argsIndex];
		      }
		      var offset = argsIndex;
		      while (++rightIndex < rightLength) {
		        result[offset + rightIndex] = partials[rightIndex];
		      }
		      while (++holdersIndex < holdersLength) {
		        if (isUncurried || argsIndex < argsLength) {
		          result[offset + holders[holdersIndex]] = args[argsIndex++];
		        }
		      }
		      return result;
		    }

		    /**
		     * Copies the values of `source` to `array`.
		     *
		     * @private
		     * @param {Array} source The array to copy values from.
		     * @param {Array} [array=[]] The array to copy values to.
		     * @returns {Array} Returns `array`.
		     */
		    function copyArray(source, array) {
		      var index = -1,
		          length = source.length;

		      array || (array = Array(length));
		      while (++index < length) {
		        array[index] = source[index];
		      }
		      return array;
		    }

		    /**
		     * Copies properties of `source` to `object`.
		     *
		     * @private
		     * @param {Object} source The object to copy properties from.
		     * @param {Array} props The property identifiers to copy.
		     * @param {Object} [object={}] The object to copy properties to.
		     * @param {Function} [customizer] The function to customize copied values.
		     * @returns {Object} Returns `object`.
		     */
		    function copyObject(source, props, object, customizer) {
		      var isNew = !object;
		      object || (object = {});

		      var index = -1,
		          length = props.length;

		      while (++index < length) {
		        var key = props[index];

		        var newValue = customizer
		          ? customizer(object[key], source[key], key, object, source)
		          : undefined$1;

		        if (newValue === undefined$1) {
		          newValue = source[key];
		        }
		        if (isNew) {
		          baseAssignValue(object, key, newValue);
		        } else {
		          assignValue(object, key, newValue);
		        }
		      }
		      return object;
		    }

		    /**
		     * Copies own symbols of `source` to `object`.
		     *
		     * @private
		     * @param {Object} source The object to copy symbols from.
		     * @param {Object} [object={}] The object to copy symbols to.
		     * @returns {Object} Returns `object`.
		     */
		    function copySymbols(source, object) {
		      return copyObject(source, getSymbols(source), object);
		    }

		    /**
		     * Copies own and inherited symbols of `source` to `object`.
		     *
		     * @private
		     * @param {Object} source The object to copy symbols from.
		     * @param {Object} [object={}] The object to copy symbols to.
		     * @returns {Object} Returns `object`.
		     */
		    function copySymbolsIn(source, object) {
		      return copyObject(source, getSymbolsIn(source), object);
		    }

		    /**
		     * Creates a function like `_.groupBy`.
		     *
		     * @private
		     * @param {Function} setter The function to set accumulator values.
		     * @param {Function} [initializer] The accumulator object initializer.
		     * @returns {Function} Returns the new aggregator function.
		     */
		    function createAggregator(setter, initializer) {
		      return function(collection, iteratee) {
		        var func = isArray(collection) ? arrayAggregator : baseAggregator,
		            accumulator = initializer ? initializer() : {};

		        return func(collection, setter, getIteratee(iteratee, 2), accumulator);
		      };
		    }

		    /**
		     * Creates a function like `_.assign`.
		     *
		     * @private
		     * @param {Function} assigner The function to assign values.
		     * @returns {Function} Returns the new assigner function.
		     */
		    function createAssigner(assigner) {
		      return baseRest(function(object, sources) {
		        var index = -1,
		            length = sources.length,
		            customizer = length > 1 ? sources[length - 1] : undefined$1,
		            guard = length > 2 ? sources[2] : undefined$1;

		        customizer = (assigner.length > 3 && typeof customizer == 'function')
		          ? (length--, customizer)
		          : undefined$1;

		        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
		          customizer = length < 3 ? undefined$1 : customizer;
		          length = 1;
		        }
		        object = Object(object);
		        while (++index < length) {
		          var source = sources[index];
		          if (source) {
		            assigner(object, source, index, customizer);
		          }
		        }
		        return object;
		      });
		    }

		    /**
		     * Creates a `baseEach` or `baseEachRight` function.
		     *
		     * @private
		     * @param {Function} eachFunc The function to iterate over a collection.
		     * @param {boolean} [fromRight] Specify iterating from right to left.
		     * @returns {Function} Returns the new base function.
		     */
		    function createBaseEach(eachFunc, fromRight) {
		      return function(collection, iteratee) {
		        if (collection == null) {
		          return collection;
		        }
		        if (!isArrayLike(collection)) {
		          return eachFunc(collection, iteratee);
		        }
		        var length = collection.length,
		            index = fromRight ? length : -1,
		            iterable = Object(collection);

		        while ((fromRight ? index-- : ++index < length)) {
		          if (iteratee(iterable[index], index, iterable) === false) {
		            break;
		          }
		        }
		        return collection;
		      };
		    }

		    /**
		     * Creates a base function for methods like `_.forIn` and `_.forOwn`.
		     *
		     * @private
		     * @param {boolean} [fromRight] Specify iterating from right to left.
		     * @returns {Function} Returns the new base function.
		     */
		    function createBaseFor(fromRight) {
		      return function(object, iteratee, keysFunc) {
		        var index = -1,
		            iterable = Object(object),
		            props = keysFunc(object),
		            length = props.length;

		        while (length--) {
		          var key = props[fromRight ? length : ++index];
		          if (iteratee(iterable[key], key, iterable) === false) {
		            break;
		          }
		        }
		        return object;
		      };
		    }

		    /**
		     * Creates a function that wraps `func` to invoke it with the optional `this`
		     * binding of `thisArg`.
		     *
		     * @private
		     * @param {Function} func The function to wrap.
		     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
		     * @param {*} [thisArg] The `this` binding of `func`.
		     * @returns {Function} Returns the new wrapped function.
		     */
		    function createBind(func, bitmask, thisArg) {
		      var isBind = bitmask & WRAP_BIND_FLAG,
		          Ctor = createCtor(func);

		      function wrapper() {
		        var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
		        return fn.apply(isBind ? thisArg : this, arguments);
		      }
		      return wrapper;
		    }

		    /**
		     * Creates a function like `_.lowerFirst`.
		     *
		     * @private
		     * @param {string} methodName The name of the `String` case method to use.
		     * @returns {Function} Returns the new case function.
		     */
		    function createCaseFirst(methodName) {
		      return function(string) {
		        string = toString(string);

		        var strSymbols = hasUnicode(string)
		          ? stringToArray(string)
		          : undefined$1;

		        var chr = strSymbols
		          ? strSymbols[0]
		          : string.charAt(0);

		        var trailing = strSymbols
		          ? castSlice(strSymbols, 1).join('')
		          : string.slice(1);

		        return chr[methodName]() + trailing;
		      };
		    }

		    /**
		     * Creates a function like `_.camelCase`.
		     *
		     * @private
		     * @param {Function} callback The function to combine each word.
		     * @returns {Function} Returns the new compounder function.
		     */
		    function createCompounder(callback) {
		      return function(string) {
		        return arrayReduce(words(deburr(string).replace(reApos, '')), callback, '');
		      };
		    }

		    /**
		     * Creates a function that produces an instance of `Ctor` regardless of
		     * whether it was invoked as part of a `new` expression or by `call` or `apply`.
		     *
		     * @private
		     * @param {Function} Ctor The constructor to wrap.
		     * @returns {Function} Returns the new wrapped function.
		     */
		    function createCtor(Ctor) {
		      return function() {
		        // Use a `switch` statement to work with class constructors. See
		        // http://ecma-international.org/ecma-262/7.0/#sec-ecmascript-function-objects-call-thisargument-argumentslist
		        // for more details.
		        var args = arguments;
		        switch (args.length) {
		          case 0: return new Ctor;
		          case 1: return new Ctor(args[0]);
		          case 2: return new Ctor(args[0], args[1]);
		          case 3: return new Ctor(args[0], args[1], args[2]);
		          case 4: return new Ctor(args[0], args[1], args[2], args[3]);
		          case 5: return new Ctor(args[0], args[1], args[2], args[3], args[4]);
		          case 6: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
		          case 7: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
		        }
		        var thisBinding = baseCreate(Ctor.prototype),
		            result = Ctor.apply(thisBinding, args);

		        // Mimic the constructor's `return` behavior.
		        // See https://es5.github.io/#x13.2.2 for more details.
		        return isObject(result) ? result : thisBinding;
		      };
		    }

		    /**
		     * Creates a function that wraps `func` to enable currying.
		     *
		     * @private
		     * @param {Function} func The function to wrap.
		     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
		     * @param {number} arity The arity of `func`.
		     * @returns {Function} Returns the new wrapped function.
		     */
		    function createCurry(func, bitmask, arity) {
		      var Ctor = createCtor(func);

		      function wrapper() {
		        var length = arguments.length,
		            args = Array(length),
		            index = length,
		            placeholder = getHolder(wrapper);

		        while (index--) {
		          args[index] = arguments[index];
		        }
		        var holders = (length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder)
		          ? []
		          : replaceHolders(args, placeholder);

		        length -= holders.length;
		        if (length < arity) {
		          return createRecurry(
		            func, bitmask, createHybrid, wrapper.placeholder, undefined$1,
		            args, holders, undefined$1, undefined$1, arity - length);
		        }
		        var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
		        return apply(fn, this, args);
		      }
		      return wrapper;
		    }

		    /**
		     * Creates a `_.find` or `_.findLast` function.
		     *
		     * @private
		     * @param {Function} findIndexFunc The function to find the collection index.
		     * @returns {Function} Returns the new find function.
		     */
		    function createFind(findIndexFunc) {
		      return function(collection, predicate, fromIndex) {
		        var iterable = Object(collection);
		        if (!isArrayLike(collection)) {
		          var iteratee = getIteratee(predicate, 3);
		          collection = keys(collection);
		          predicate = function(key) { return iteratee(iterable[key], key, iterable); };
		        }
		        var index = findIndexFunc(collection, predicate, fromIndex);
		        return index > -1 ? iterable[iteratee ? collection[index] : index] : undefined$1;
		      };
		    }

		    /**
		     * Creates a `_.flow` or `_.flowRight` function.
		     *
		     * @private
		     * @param {boolean} [fromRight] Specify iterating from right to left.
		     * @returns {Function} Returns the new flow function.
		     */
		    function createFlow(fromRight) {
		      return flatRest(function(funcs) {
		        var length = funcs.length,
		            index = length,
		            prereq = LodashWrapper.prototype.thru;

		        if (fromRight) {
		          funcs.reverse();
		        }
		        while (index--) {
		          var func = funcs[index];
		          if (typeof func != 'function') {
		            throw new TypeError(FUNC_ERROR_TEXT);
		          }
		          if (prereq && !wrapper && getFuncName(func) == 'wrapper') {
		            var wrapper = new LodashWrapper([], true);
		          }
		        }
		        index = wrapper ? index : length;
		        while (++index < length) {
		          func = funcs[index];

		          var funcName = getFuncName(func),
		              data = funcName == 'wrapper' ? getData(func) : undefined$1;

		          if (data && isLaziable(data[0]) &&
		                data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) &&
		                !data[4].length && data[9] == 1
		              ) {
		            wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
		          } else {
		            wrapper = (func.length == 1 && isLaziable(func))
		              ? wrapper[funcName]()
		              : wrapper.thru(func);
		          }
		        }
		        return function() {
		          var args = arguments,
		              value = args[0];

		          if (wrapper && args.length == 1 && isArray(value)) {
		            return wrapper.plant(value).value();
		          }
		          var index = 0,
		              result = length ? funcs[index].apply(this, args) : value;

		          while (++index < length) {
		            result = funcs[index].call(this, result);
		          }
		          return result;
		        };
		      });
		    }

		    /**
		     * Creates a function that wraps `func` to invoke it with optional `this`
		     * binding of `thisArg`, partial application, and currying.
		     *
		     * @private
		     * @param {Function|string} func The function or method name to wrap.
		     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
		     * @param {*} [thisArg] The `this` binding of `func`.
		     * @param {Array} [partials] The arguments to prepend to those provided to
		     *  the new function.
		     * @param {Array} [holders] The `partials` placeholder indexes.
		     * @param {Array} [partialsRight] The arguments to append to those provided
		     *  to the new function.
		     * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.
		     * @param {Array} [argPos] The argument positions of the new function.
		     * @param {number} [ary] The arity cap of `func`.
		     * @param {number} [arity] The arity of `func`.
		     * @returns {Function} Returns the new wrapped function.
		     */
		    function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {
		      var isAry = bitmask & WRAP_ARY_FLAG,
		          isBind = bitmask & WRAP_BIND_FLAG,
		          isBindKey = bitmask & WRAP_BIND_KEY_FLAG,
		          isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG),
		          isFlip = bitmask & WRAP_FLIP_FLAG,
		          Ctor = isBindKey ? undefined$1 : createCtor(func);

		      function wrapper() {
		        var length = arguments.length,
		            args = Array(length),
		            index = length;

		        while (index--) {
		          args[index] = arguments[index];
		        }
		        if (isCurried) {
		          var placeholder = getHolder(wrapper),
		              holdersCount = countHolders(args, placeholder);
		        }
		        if (partials) {
		          args = composeArgs(args, partials, holders, isCurried);
		        }
		        if (partialsRight) {
		          args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
		        }
		        length -= holdersCount;
		        if (isCurried && length < arity) {
		          var newHolders = replaceHolders(args, placeholder);
		          return createRecurry(
		            func, bitmask, createHybrid, wrapper.placeholder, thisArg,
		            args, newHolders, argPos, ary, arity - length
		          );
		        }
		        var thisBinding = isBind ? thisArg : this,
		            fn = isBindKey ? thisBinding[func] : func;

		        length = args.length;
		        if (argPos) {
		          args = reorder(args, argPos);
		        } else if (isFlip && length > 1) {
		          args.reverse();
		        }
		        if (isAry && ary < length) {
		          args.length = ary;
		        }
		        if (this && this !== root && this instanceof wrapper) {
		          fn = Ctor || createCtor(fn);
		        }
		        return fn.apply(thisBinding, args);
		      }
		      return wrapper;
		    }

		    /**
		     * Creates a function like `_.invertBy`.
		     *
		     * @private
		     * @param {Function} setter The function to set accumulator values.
		     * @param {Function} toIteratee The function to resolve iteratees.
		     * @returns {Function} Returns the new inverter function.
		     */
		    function createInverter(setter, toIteratee) {
		      return function(object, iteratee) {
		        return baseInverter(object, setter, toIteratee(iteratee), {});
		      };
		    }

		    /**
		     * Creates a function that performs a mathematical operation on two values.
		     *
		     * @private
		     * @param {Function} operator The function to perform the operation.
		     * @param {number} [defaultValue] The value used for `undefined` arguments.
		     * @returns {Function} Returns the new mathematical operation function.
		     */
		    function createMathOperation(operator, defaultValue) {
		      return function(value, other) {
		        var result;
		        if (value === undefined$1 && other === undefined$1) {
		          return defaultValue;
		        }
		        if (value !== undefined$1) {
		          result = value;
		        }
		        if (other !== undefined$1) {
		          if (result === undefined$1) {
		            return other;
		          }
		          if (typeof value == 'string' || typeof other == 'string') {
		            value = baseToString(value);
		            other = baseToString(other);
		          } else {
		            value = baseToNumber(value);
		            other = baseToNumber(other);
		          }
		          result = operator(value, other);
		        }
		        return result;
		      };
		    }

		    /**
		     * Creates a function like `_.over`.
		     *
		     * @private
		     * @param {Function} arrayFunc The function to iterate over iteratees.
		     * @returns {Function} Returns the new over function.
		     */
		    function createOver(arrayFunc) {
		      return flatRest(function(iteratees) {
		        iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
		        return baseRest(function(args) {
		          var thisArg = this;
		          return arrayFunc(iteratees, function(iteratee) {
		            return apply(iteratee, thisArg, args);
		          });
		        });
		      });
		    }

		    /**
		     * Creates the padding for `string` based on `length`. The `chars` string
		     * is truncated if the number of characters exceeds `length`.
		     *
		     * @private
		     * @param {number} length The padding length.
		     * @param {string} [chars=' '] The string used as padding.
		     * @returns {string} Returns the padding for `string`.
		     */
		    function createPadding(length, chars) {
		      chars = chars === undefined$1 ? ' ' : baseToString(chars);

		      var charsLength = chars.length;
		      if (charsLength < 2) {
		        return charsLength ? baseRepeat(chars, length) : chars;
		      }
		      var result = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
		      return hasUnicode(chars)
		        ? castSlice(stringToArray(result), 0, length).join('')
		        : result.slice(0, length);
		    }

		    /**
		     * Creates a function that wraps `func` to invoke it with the `this` binding
		     * of `thisArg` and `partials` prepended to the arguments it receives.
		     *
		     * @private
		     * @param {Function} func The function to wrap.
		     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
		     * @param {*} thisArg The `this` binding of `func`.
		     * @param {Array} partials The arguments to prepend to those provided to
		     *  the new function.
		     * @returns {Function} Returns the new wrapped function.
		     */
		    function createPartial(func, bitmask, thisArg, partials) {
		      var isBind = bitmask & WRAP_BIND_FLAG,
		          Ctor = createCtor(func);

		      function wrapper() {
		        var argsIndex = -1,
		            argsLength = arguments.length,
		            leftIndex = -1,
		            leftLength = partials.length,
		            args = Array(leftLength + argsLength),
		            fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;

		        while (++leftIndex < leftLength) {
		          args[leftIndex] = partials[leftIndex];
		        }
		        while (argsLength--) {
		          args[leftIndex++] = arguments[++argsIndex];
		        }
		        return apply(fn, isBind ? thisArg : this, args);
		      }
		      return wrapper;
		    }

		    /**
		     * Creates a `_.range` or `_.rangeRight` function.
		     *
		     * @private
		     * @param {boolean} [fromRight] Specify iterating from right to left.
		     * @returns {Function} Returns the new range function.
		     */
		    function createRange(fromRight) {
		      return function(start, end, step) {
		        if (step && typeof step != 'number' && isIterateeCall(start, end, step)) {
		          end = step = undefined$1;
		        }
		        // Ensure the sign of `-0` is preserved.
		        start = toFinite(start);
		        if (end === undefined$1) {
		          end = start;
		          start = 0;
		        } else {
		          end = toFinite(end);
		        }
		        step = step === undefined$1 ? (start < end ? 1 : -1) : toFinite(step);
		        return baseRange(start, end, step, fromRight);
		      };
		    }

		    /**
		     * Creates a function that performs a relational operation on two values.
		     *
		     * @private
		     * @param {Function} operator The function to perform the operation.
		     * @returns {Function} Returns the new relational operation function.
		     */
		    function createRelationalOperation(operator) {
		      return function(value, other) {
		        if (!(typeof value == 'string' && typeof other == 'string')) {
		          value = toNumber(value);
		          other = toNumber(other);
		        }
		        return operator(value, other);
		      };
		    }

		    /**
		     * Creates a function that wraps `func` to continue currying.
		     *
		     * @private
		     * @param {Function} func The function to wrap.
		     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
		     * @param {Function} wrapFunc The function to create the `func` wrapper.
		     * @param {*} placeholder The placeholder value.
		     * @param {*} [thisArg] The `this` binding of `func`.
		     * @param {Array} [partials] The arguments to prepend to those provided to
		     *  the new function.
		     * @param {Array} [holders] The `partials` placeholder indexes.
		     * @param {Array} [argPos] The argument positions of the new function.
		     * @param {number} [ary] The arity cap of `func`.
		     * @param {number} [arity] The arity of `func`.
		     * @returns {Function} Returns the new wrapped function.
		     */
		    function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary, arity) {
		      var isCurry = bitmask & WRAP_CURRY_FLAG,
		          newHolders = isCurry ? holders : undefined$1,
		          newHoldersRight = isCurry ? undefined$1 : holders,
		          newPartials = isCurry ? partials : undefined$1,
		          newPartialsRight = isCurry ? undefined$1 : partials;

		      bitmask |= (isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG);
		      bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);

		      if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
		        bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
		      }
		      var newData = [
		        func, bitmask, thisArg, newPartials, newHolders, newPartialsRight,
		        newHoldersRight, argPos, ary, arity
		      ];

		      var result = wrapFunc.apply(undefined$1, newData);
		      if (isLaziable(func)) {
		        setData(result, newData);
		      }
		      result.placeholder = placeholder;
		      return setWrapToString(result, func, bitmask);
		    }

		    /**
		     * Creates a function like `_.round`.
		     *
		     * @private
		     * @param {string} methodName The name of the `Math` method to use when rounding.
		     * @returns {Function} Returns the new round function.
		     */
		    function createRound(methodName) {
		      var func = Math[methodName];
		      return function(number, precision) {
		        number = toNumber(number);
		        precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
		        if (precision && nativeIsFinite(number)) {
		          // Shift with exponential notation to avoid floating-point issues.
		          // See [MDN](https://mdn.io/round#Examples) for more details.
		          var pair = (toString(number) + 'e').split('e'),
		              value = func(pair[0] + 'e' + (+pair[1] + precision));

		          pair = (toString(value) + 'e').split('e');
		          return +(pair[0] + 'e' + (+pair[1] - precision));
		        }
		        return func(number);
		      };
		    }

		    /**
		     * Creates a set object of `values`.
		     *
		     * @private
		     * @param {Array} values The values to add to the set.
		     * @returns {Object} Returns the new set.
		     */
		    var createSet = !(Set && (1 / setToArray(new Set([,-0]))[1]) == INFINITY) ? noop : function(values) {
		      return new Set(values);
		    };

		    /**
		     * Creates a `_.toPairs` or `_.toPairsIn` function.
		     *
		     * @private
		     * @param {Function} keysFunc The function to get the keys of a given object.
		     * @returns {Function} Returns the new pairs function.
		     */
		    function createToPairs(keysFunc) {
		      return function(object) {
		        var tag = getTag(object);
		        if (tag == mapTag) {
		          return mapToArray(object);
		        }
		        if (tag == setTag) {
		          return setToPairs(object);
		        }
		        return baseToPairs(object, keysFunc(object));
		      };
		    }

		    /**
		     * Creates a function that either curries or invokes `func` with optional
		     * `this` binding and partially applied arguments.
		     *
		     * @private
		     * @param {Function|string} func The function or method name to wrap.
		     * @param {number} bitmask The bitmask flags.
		     *    1 - `_.bind`
		     *    2 - `_.bindKey`
		     *    4 - `_.curry` or `_.curryRight` of a bound function
		     *    8 - `_.curry`
		     *   16 - `_.curryRight`
		     *   32 - `_.partial`
		     *   64 - `_.partialRight`
		     *  128 - `_.rearg`
		     *  256 - `_.ary`
		     *  512 - `_.flip`
		     * @param {*} [thisArg] The `this` binding of `func`.
		     * @param {Array} [partials] The arguments to be partially applied.
		     * @param {Array} [holders] The `partials` placeholder indexes.
		     * @param {Array} [argPos] The argument positions of the new function.
		     * @param {number} [ary] The arity cap of `func`.
		     * @param {number} [arity] The arity of `func`.
		     * @returns {Function} Returns the new wrapped function.
		     */
		    function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {
		      var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
		      if (!isBindKey && typeof func != 'function') {
		        throw new TypeError(FUNC_ERROR_TEXT);
		      }
		      var length = partials ? partials.length : 0;
		      if (!length) {
		        bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
		        partials = holders = undefined$1;
		      }
		      ary = ary === undefined$1 ? ary : nativeMax(toInteger(ary), 0);
		      arity = arity === undefined$1 ? arity : toInteger(arity);
		      length -= holders ? holders.length : 0;

		      if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
		        var partialsRight = partials,
		            holdersRight = holders;

		        partials = holders = undefined$1;
		      }
		      var data = isBindKey ? undefined$1 : getData(func);

		      var newData = [
		        func, bitmask, thisArg, partials, holders, partialsRight, holdersRight,
		        argPos, ary, arity
		      ];

		      if (data) {
		        mergeData(newData, data);
		      }
		      func = newData[0];
		      bitmask = newData[1];
		      thisArg = newData[2];
		      partials = newData[3];
		      holders = newData[4];
		      arity = newData[9] = newData[9] === undefined$1
		        ? (isBindKey ? 0 : func.length)
		        : nativeMax(newData[9] - length, 0);

		      if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
		        bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
		      }
		      if (!bitmask || bitmask == WRAP_BIND_FLAG) {
		        var result = createBind(func, bitmask, thisArg);
		      } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
		        result = createCurry(func, bitmask, arity);
		      } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
		        result = createPartial(func, bitmask, thisArg, partials);
		      } else {
		        result = createHybrid.apply(undefined$1, newData);
		      }
		      var setter = data ? baseSetData : setData;
		      return setWrapToString(setter(result, newData), func, bitmask);
		    }

		    /**
		     * Used by `_.defaults` to customize its `_.assignIn` use to assign properties
		     * of source objects to the destination object for all destination properties
		     * that resolve to `undefined`.
		     *
		     * @private
		     * @param {*} objValue The destination value.
		     * @param {*} srcValue The source value.
		     * @param {string} key The key of the property to assign.
		     * @param {Object} object The parent object of `objValue`.
		     * @returns {*} Returns the value to assign.
		     */
		    function customDefaultsAssignIn(objValue, srcValue, key, object) {
		      if (objValue === undefined$1 ||
		          (eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key))) {
		        return srcValue;
		      }
		      return objValue;
		    }

		    /**
		     * Used by `_.defaultsDeep` to customize its `_.merge` use to merge source
		     * objects into destination objects that are passed thru.
		     *
		     * @private
		     * @param {*} objValue The destination value.
		     * @param {*} srcValue The source value.
		     * @param {string} key The key of the property to merge.
		     * @param {Object} object The parent object of `objValue`.
		     * @param {Object} source The parent object of `srcValue`.
		     * @param {Object} [stack] Tracks traversed source values and their merged
		     *  counterparts.
		     * @returns {*} Returns the value to assign.
		     */
		    function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
		      if (isObject(objValue) && isObject(srcValue)) {
		        // Recursively merge objects and arrays (susceptible to call stack limits).
		        stack.set(srcValue, objValue);
		        baseMerge(objValue, srcValue, undefined$1, customDefaultsMerge, stack);
		        stack['delete'](srcValue);
		      }
		      return objValue;
		    }

		    /**
		     * Used by `_.omit` to customize its `_.cloneDeep` use to only clone plain
		     * objects.
		     *
		     * @private
		     * @param {*} value The value to inspect.
		     * @param {string} key The key of the property to inspect.
		     * @returns {*} Returns the uncloned value or `undefined` to defer cloning to `_.cloneDeep`.
		     */
		    function customOmitClone(value) {
		      return isPlainObject(value) ? undefined$1 : value;
		    }

		    /**
		     * A specialized version of `baseIsEqualDeep` for arrays with support for
		     * partial deep comparisons.
		     *
		     * @private
		     * @param {Array} array The array to compare.
		     * @param {Array} other The other array to compare.
		     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
		     * @param {Function} customizer The function to customize comparisons.
		     * @param {Function} equalFunc The function to determine equivalents of values.
		     * @param {Object} stack Tracks traversed `array` and `other` objects.
		     * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
		     */
		    function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
		      var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
		          arrLength = array.length,
		          othLength = other.length;

		      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
		        return false;
		      }
		      // Check that cyclic values are equal.
		      var arrStacked = stack.get(array);
		      var othStacked = stack.get(other);
		      if (arrStacked && othStacked) {
		        return arrStacked == other && othStacked == array;
		      }
		      var index = -1,
		          result = true,
		          seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined$1;

		      stack.set(array, other);
		      stack.set(other, array);

		      // Ignore non-index properties.
		      while (++index < arrLength) {
		        var arrValue = array[index],
		            othValue = other[index];

		        if (customizer) {
		          var compared = isPartial
		            ? customizer(othValue, arrValue, index, other, array, stack)
		            : customizer(arrValue, othValue, index, array, other, stack);
		        }
		        if (compared !== undefined$1) {
		          if (compared) {
		            continue;
		          }
		          result = false;
		          break;
		        }
		        // Recursively compare arrays (susceptible to call stack limits).
		        if (seen) {
		          if (!arraySome(other, function(othValue, othIndex) {
		                if (!cacheHas(seen, othIndex) &&
		                    (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
		                  return seen.push(othIndex);
		                }
		              })) {
		            result = false;
		            break;
		          }
		        } else if (!(
		              arrValue === othValue ||
		                equalFunc(arrValue, othValue, bitmask, customizer, stack)
		            )) {
		          result = false;
		          break;
		        }
		      }
		      stack['delete'](array);
		      stack['delete'](other);
		      return result;
		    }

		    /**
		     * A specialized version of `baseIsEqualDeep` for comparing objects of
		     * the same `toStringTag`.
		     *
		     * **Note:** This function only supports comparing values with tags of
		     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
		     *
		     * @private
		     * @param {Object} object The object to compare.
		     * @param {Object} other The other object to compare.
		     * @param {string} tag The `toStringTag` of the objects to compare.
		     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
		     * @param {Function} customizer The function to customize comparisons.
		     * @param {Function} equalFunc The function to determine equivalents of values.
		     * @param {Object} stack Tracks traversed `object` and `other` objects.
		     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
		     */
		    function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
		      switch (tag) {
		        case dataViewTag:
		          if ((object.byteLength != other.byteLength) ||
		              (object.byteOffset != other.byteOffset)) {
		            return false;
		          }
		          object = object.buffer;
		          other = other.buffer;

		        case arrayBufferTag:
		          if ((object.byteLength != other.byteLength) ||
		              !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
		            return false;
		          }
		          return true;

		        case boolTag:
		        case dateTag:
		        case numberTag:
		          // Coerce booleans to `1` or `0` and dates to milliseconds.
		          // Invalid dates are coerced to `NaN`.
		          return eq(+object, +other);

		        case errorTag:
		          return object.name == other.name && object.message == other.message;

		        case regexpTag:
		        case stringTag:
		          // Coerce regexes to strings and treat strings, primitives and objects,
		          // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
		          // for more details.
		          return object == (other + '');

		        case mapTag:
		          var convert = mapToArray;

		        case setTag:
		          var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
		          convert || (convert = setToArray);

		          if (object.size != other.size && !isPartial) {
		            return false;
		          }
		          // Assume cyclic values are equal.
		          var stacked = stack.get(object);
		          if (stacked) {
		            return stacked == other;
		          }
		          bitmask |= COMPARE_UNORDERED_FLAG;

		          // Recursively compare objects (susceptible to call stack limits).
		          stack.set(object, other);
		          var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
		          stack['delete'](object);
		          return result;

		        case symbolTag:
		          if (symbolValueOf) {
		            return symbolValueOf.call(object) == symbolValueOf.call(other);
		          }
		      }
		      return false;
		    }

		    /**
		     * A specialized version of `baseIsEqualDeep` for objects with support for
		     * partial deep comparisons.
		     *
		     * @private
		     * @param {Object} object The object to compare.
		     * @param {Object} other The other object to compare.
		     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
		     * @param {Function} customizer The function to customize comparisons.
		     * @param {Function} equalFunc The function to determine equivalents of values.
		     * @param {Object} stack Tracks traversed `object` and `other` objects.
		     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
		     */
		    function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
		      var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
		          objProps = getAllKeys(object),
		          objLength = objProps.length,
		          othProps = getAllKeys(other),
		          othLength = othProps.length;

		      if (objLength != othLength && !isPartial) {
		        return false;
		      }
		      var index = objLength;
		      while (index--) {
		        var key = objProps[index];
		        if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
		          return false;
		        }
		      }
		      // Check that cyclic values are equal.
		      var objStacked = stack.get(object);
		      var othStacked = stack.get(other);
		      if (objStacked && othStacked) {
		        return objStacked == other && othStacked == object;
		      }
		      var result = true;
		      stack.set(object, other);
		      stack.set(other, object);

		      var skipCtor = isPartial;
		      while (++index < objLength) {
		        key = objProps[index];
		        var objValue = object[key],
		            othValue = other[key];

		        if (customizer) {
		          var compared = isPartial
		            ? customizer(othValue, objValue, key, other, object, stack)
		            : customizer(objValue, othValue, key, object, other, stack);
		        }
		        // Recursively compare objects (susceptible to call stack limits).
		        if (!(compared === undefined$1
		              ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))
		              : compared
		            )) {
		          result = false;
		          break;
		        }
		        skipCtor || (skipCtor = key == 'constructor');
		      }
		      if (result && !skipCtor) {
		        var objCtor = object.constructor,
		            othCtor = other.constructor;

		        // Non `Object` object instances with different constructors are not equal.
		        if (objCtor != othCtor &&
		            ('constructor' in object && 'constructor' in other) &&
		            !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
		              typeof othCtor == 'function' && othCtor instanceof othCtor)) {
		          result = false;
		        }
		      }
		      stack['delete'](object);
		      stack['delete'](other);
		      return result;
		    }

		    /**
		     * A specialized version of `baseRest` which flattens the rest array.
		     *
		     * @private
		     * @param {Function} func The function to apply a rest parameter to.
		     * @returns {Function} Returns the new function.
		     */
		    function flatRest(func) {
		      return setToString(overRest(func, undefined$1, flatten), func + '');
		    }

		    /**
		     * Creates an array of own enumerable property names and symbols of `object`.
		     *
		     * @private
		     * @param {Object} object The object to query.
		     * @returns {Array} Returns the array of property names and symbols.
		     */
		    function getAllKeys(object) {
		      return baseGetAllKeys(object, keys, getSymbols);
		    }

		    /**
		     * Creates an array of own and inherited enumerable property names and
		     * symbols of `object`.
		     *
		     * @private
		     * @param {Object} object The object to query.
		     * @returns {Array} Returns the array of property names and symbols.
		     */
		    function getAllKeysIn(object) {
		      return baseGetAllKeys(object, keysIn, getSymbolsIn);
		    }

		    /**
		     * Gets metadata for `func`.
		     *
		     * @private
		     * @param {Function} func The function to query.
		     * @returns {*} Returns the metadata for `func`.
		     */
		    var getData = !metaMap ? noop : function(func) {
		      return metaMap.get(func);
		    };

		    /**
		     * Gets the name of `func`.
		     *
		     * @private
		     * @param {Function} func The function to query.
		     * @returns {string} Returns the function name.
		     */
		    function getFuncName(func) {
		      var result = (func.name + ''),
		          array = realNames[result],
		          length = hasOwnProperty.call(realNames, result) ? array.length : 0;

		      while (length--) {
		        var data = array[length],
		            otherFunc = data.func;
		        if (otherFunc == null || otherFunc == func) {
		          return data.name;
		        }
		      }
		      return result;
		    }

		    /**
		     * Gets the argument placeholder value for `func`.
		     *
		     * @private
		     * @param {Function} func The function to inspect.
		     * @returns {*} Returns the placeholder value.
		     */
		    function getHolder(func) {
		      var object = hasOwnProperty.call(lodash, 'placeholder') ? lodash : func;
		      return object.placeholder;
		    }

		    /**
		     * Gets the appropriate "iteratee" function. If `_.iteratee` is customized,
		     * this function returns the custom method, otherwise it returns `baseIteratee`.
		     * If arguments are provided, the chosen function is invoked with them and
		     * its result is returned.
		     *
		     * @private
		     * @param {*} [value] The value to convert to an iteratee.
		     * @param {number} [arity] The arity of the created iteratee.
		     * @returns {Function} Returns the chosen function or its result.
		     */
		    function getIteratee() {
		      var result = lodash.iteratee || iteratee;
		      result = result === iteratee ? baseIteratee : result;
		      return arguments.length ? result(arguments[0], arguments[1]) : result;
		    }

		    /**
		     * Gets the data for `map`.
		     *
		     * @private
		     * @param {Object} map The map to query.
		     * @param {string} key The reference key.
		     * @returns {*} Returns the map data.
		     */
		    function getMapData(map, key) {
		      var data = map.__data__;
		      return isKeyable(key)
		        ? data[typeof key == 'string' ? 'string' : 'hash']
		        : data.map;
		    }

		    /**
		     * Gets the property names, values, and compare flags of `object`.
		     *
		     * @private
		     * @param {Object} object The object to query.
		     * @returns {Array} Returns the match data of `object`.
		     */
		    function getMatchData(object) {
		      var result = keys(object),
		          length = result.length;

		      while (length--) {
		        var key = result[length],
		            value = object[key];

		        result[length] = [key, value, isStrictComparable(value)];
		      }
		      return result;
		    }

		    /**
		     * Gets the native function at `key` of `object`.
		     *
		     * @private
		     * @param {Object} object The object to query.
		     * @param {string} key The key of the method to get.
		     * @returns {*} Returns the function if it's native, else `undefined`.
		     */
		    function getNative(object, key) {
		      var value = getValue(object, key);
		      return baseIsNative(value) ? value : undefined$1;
		    }

		    /**
		     * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
		     *
		     * @private
		     * @param {*} value The value to query.
		     * @returns {string} Returns the raw `toStringTag`.
		     */
		    function getRawTag(value) {
		      var isOwn = hasOwnProperty.call(value, symToStringTag),
		          tag = value[symToStringTag];

		      try {
		        value[symToStringTag] = undefined$1;
		        var unmasked = true;
		      } catch (e) {}

		      var result = nativeObjectToString.call(value);
		      if (unmasked) {
		        if (isOwn) {
		          value[symToStringTag] = tag;
		        } else {
		          delete value[symToStringTag];
		        }
		      }
		      return result;
		    }

		    /**
		     * Creates an array of the own enumerable symbols of `object`.
		     *
		     * @private
		     * @param {Object} object The object to query.
		     * @returns {Array} Returns the array of symbols.
		     */
		    var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
		      if (object == null) {
		        return [];
		      }
		      object = Object(object);
		      return arrayFilter(nativeGetSymbols(object), function(symbol) {
		        return propertyIsEnumerable.call(object, symbol);
		      });
		    };

		    /**
		     * Creates an array of the own and inherited enumerable symbols of `object`.
		     *
		     * @private
		     * @param {Object} object The object to query.
		     * @returns {Array} Returns the array of symbols.
		     */
		    var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
		      var result = [];
		      while (object) {
		        arrayPush(result, getSymbols(object));
		        object = getPrototype(object);
		      }
		      return result;
		    };

		    /**
		     * Gets the `toStringTag` of `value`.
		     *
		     * @private
		     * @param {*} value The value to query.
		     * @returns {string} Returns the `toStringTag`.
		     */
		    var getTag = baseGetTag;

		    // Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
		    if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
		        (Map && getTag(new Map) != mapTag) ||
		        (Promise && getTag(Promise.resolve()) != promiseTag) ||
		        (Set && getTag(new Set) != setTag) ||
		        (WeakMap && getTag(new WeakMap) != weakMapTag)) {
		      getTag = function(value) {
		        var result = baseGetTag(value),
		            Ctor = result == objectTag ? value.constructor : undefined$1,
		            ctorString = Ctor ? toSource(Ctor) : '';

		        if (ctorString) {
		          switch (ctorString) {
		            case dataViewCtorString: return dataViewTag;
		            case mapCtorString: return mapTag;
		            case promiseCtorString: return promiseTag;
		            case setCtorString: return setTag;
		            case weakMapCtorString: return weakMapTag;
		          }
		        }
		        return result;
		      };
		    }

		    /**
		     * Gets the view, applying any `transforms` to the `start` and `end` positions.
		     *
		     * @private
		     * @param {number} start The start of the view.
		     * @param {number} end The end of the view.
		     * @param {Array} transforms The transformations to apply to the view.
		     * @returns {Object} Returns an object containing the `start` and `end`
		     *  positions of the view.
		     */
		    function getView(start, end, transforms) {
		      var index = -1,
		          length = transforms.length;

		      while (++index < length) {
		        var data = transforms[index],
		            size = data.size;

		        switch (data.type) {
		          case 'drop':      start += size; break;
		          case 'dropRight': end -= size; break;
		          case 'take':      end = nativeMin(end, start + size); break;
		          case 'takeRight': start = nativeMax(start, end - size); break;
		        }
		      }
		      return { 'start': start, 'end': end };
		    }

		    /**
		     * Extracts wrapper details from the `source` body comment.
		     *
		     * @private
		     * @param {string} source The source to inspect.
		     * @returns {Array} Returns the wrapper details.
		     */
		    function getWrapDetails(source) {
		      var match = source.match(reWrapDetails);
		      return match ? match[1].split(reSplitDetails) : [];
		    }

		    /**
		     * Checks if `path` exists on `object`.
		     *
		     * @private
		     * @param {Object} object The object to query.
		     * @param {Array|string} path The path to check.
		     * @param {Function} hasFunc The function to check properties.
		     * @returns {boolean} Returns `true` if `path` exists, else `false`.
		     */
		    function hasPath(object, path, hasFunc) {
		      path = castPath(path, object);

		      var index = -1,
		          length = path.length,
		          result = false;

		      while (++index < length) {
		        var key = toKey(path[index]);
		        if (!(result = object != null && hasFunc(object, key))) {
		          break;
		        }
		        object = object[key];
		      }
		      if (result || ++index != length) {
		        return result;
		      }
		      length = object == null ? 0 : object.length;
		      return !!length && isLength(length) && isIndex(key, length) &&
		        (isArray(object) || isArguments(object));
		    }

		    /**
		     * Initializes an array clone.
		     *
		     * @private
		     * @param {Array} array The array to clone.
		     * @returns {Array} Returns the initialized clone.
		     */
		    function initCloneArray(array) {
		      var length = array.length,
		          result = new array.constructor(length);

		      // Add properties assigned by `RegExp#exec`.
		      if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
		        result.index = array.index;
		        result.input = array.input;
		      }
		      return result;
		    }

		    /**
		     * Initializes an object clone.
		     *
		     * @private
		     * @param {Object} object The object to clone.
		     * @returns {Object} Returns the initialized clone.
		     */
		    function initCloneObject(object) {
		      return (typeof object.constructor == 'function' && !isPrototype(object))
		        ? baseCreate(getPrototype(object))
		        : {};
		    }

		    /**
		     * Initializes an object clone based on its `toStringTag`.
		     *
		     * **Note:** This function only supports cloning values with tags of
		     * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.
		     *
		     * @private
		     * @param {Object} object The object to clone.
		     * @param {string} tag The `toStringTag` of the object to clone.
		     * @param {boolean} [isDeep] Specify a deep clone.
		     * @returns {Object} Returns the initialized clone.
		     */
		    function initCloneByTag(object, tag, isDeep) {
		      var Ctor = object.constructor;
		      switch (tag) {
		        case arrayBufferTag:
		          return cloneArrayBuffer(object);

		        case boolTag:
		        case dateTag:
		          return new Ctor(+object);

		        case dataViewTag:
		          return cloneDataView(object, isDeep);

		        case float32Tag: case float64Tag:
		        case int8Tag: case int16Tag: case int32Tag:
		        case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:
		          return cloneTypedArray(object, isDeep);

		        case mapTag:
		          return new Ctor;

		        case numberTag:
		        case stringTag:
		          return new Ctor(object);

		        case regexpTag:
		          return cloneRegExp(object);

		        case setTag:
		          return new Ctor;

		        case symbolTag:
		          return cloneSymbol(object);
		      }
		    }

		    /**
		     * Inserts wrapper `details` in a comment at the top of the `source` body.
		     *
		     * @private
		     * @param {string} source The source to modify.
		     * @returns {Array} details The details to insert.
		     * @returns {string} Returns the modified source.
		     */
		    function insertWrapDetails(source, details) {
		      var length = details.length;
		      if (!length) {
		        return source;
		      }
		      var lastIndex = length - 1;
		      details[lastIndex] = (length > 1 ? '& ' : '') + details[lastIndex];
		      details = details.join(length > 2 ? ', ' : ' ');
		      return source.replace(reWrapComment, '{\n/* [wrapped with ' + details + '] */\n');
		    }

		    /**
		     * Checks if `value` is a flattenable `arguments` object or array.
		     *
		     * @private
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
		     */
		    function isFlattenable(value) {
		      return isArray(value) || isArguments(value) ||
		        !!(spreadableSymbol && value && value[spreadableSymbol]);
		    }

		    /**
		     * Checks if `value` is a valid array-like index.
		     *
		     * @private
		     * @param {*} value The value to check.
		     * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
		     * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
		     */
		    function isIndex(value, length) {
		      var type = typeof value;
		      length = length == null ? MAX_SAFE_INTEGER : length;

		      return !!length &&
		        (type == 'number' ||
		          (type != 'symbol' && reIsUint.test(value))) &&
		            (value > -1 && value % 1 == 0 && value < length);
		    }

		    /**
		     * Checks if the given arguments are from an iteratee call.
		     *
		     * @private
		     * @param {*} value The potential iteratee value argument.
		     * @param {*} index The potential iteratee index or key argument.
		     * @param {*} object The potential iteratee object argument.
		     * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
		     *  else `false`.
		     */
		    function isIterateeCall(value, index, object) {
		      if (!isObject(object)) {
		        return false;
		      }
		      var type = typeof index;
		      if (type == 'number'
		            ? (isArrayLike(object) && isIndex(index, object.length))
		            : (type == 'string' && index in object)
		          ) {
		        return eq(object[index], value);
		      }
		      return false;
		    }

		    /**
		     * Checks if `value` is a property name and not a property path.
		     *
		     * @private
		     * @param {*} value The value to check.
		     * @param {Object} [object] The object to query keys on.
		     * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
		     */
		    function isKey(value, object) {
		      if (isArray(value)) {
		        return false;
		      }
		      var type = typeof value;
		      if (type == 'number' || type == 'symbol' || type == 'boolean' ||
		          value == null || isSymbol(value)) {
		        return true;
		      }
		      return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
		        (object != null && value in Object(object));
		    }

		    /**
		     * Checks if `value` is suitable for use as unique object key.
		     *
		     * @private
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
		     */
		    function isKeyable(value) {
		      var type = typeof value;
		      return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
		        ? (value !== '__proto__')
		        : (value === null);
		    }

		    /**
		     * Checks if `func` has a lazy counterpart.
		     *
		     * @private
		     * @param {Function} func The function to check.
		     * @returns {boolean} Returns `true` if `func` has a lazy counterpart,
		     *  else `false`.
		     */
		    function isLaziable(func) {
		      var funcName = getFuncName(func),
		          other = lodash[funcName];

		      if (typeof other != 'function' || !(funcName in LazyWrapper.prototype)) {
		        return false;
		      }
		      if (func === other) {
		        return true;
		      }
		      var data = getData(other);
		      return !!data && func === data[0];
		    }

		    /**
		     * Checks if `func` has its source masked.
		     *
		     * @private
		     * @param {Function} func The function to check.
		     * @returns {boolean} Returns `true` if `func` is masked, else `false`.
		     */
		    function isMasked(func) {
		      return !!maskSrcKey && (maskSrcKey in func);
		    }

		    /**
		     * Checks if `func` is capable of being masked.
		     *
		     * @private
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `func` is maskable, else `false`.
		     */
		    var isMaskable = coreJsData ? isFunction : stubFalse;

		    /**
		     * Checks if `value` is likely a prototype object.
		     *
		     * @private
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
		     */
		    function isPrototype(value) {
		      var Ctor = value && value.constructor,
		          proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

		      return value === proto;
		    }

		    /**
		     * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
		     *
		     * @private
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` if suitable for strict
		     *  equality comparisons, else `false`.
		     */
		    function isStrictComparable(value) {
		      return value === value && !isObject(value);
		    }

		    /**
		     * A specialized version of `matchesProperty` for source values suitable
		     * for strict equality comparisons, i.e. `===`.
		     *
		     * @private
		     * @param {string} key The key of the property to get.
		     * @param {*} srcValue The value to match.
		     * @returns {Function} Returns the new spec function.
		     */
		    function matchesStrictComparable(key, srcValue) {
		      return function(object) {
		        if (object == null) {
		          return false;
		        }
		        return object[key] === srcValue &&
		          (srcValue !== undefined$1 || (key in Object(object)));
		      };
		    }

		    /**
		     * A specialized version of `_.memoize` which clears the memoized function's
		     * cache when it exceeds `MAX_MEMOIZE_SIZE`.
		     *
		     * @private
		     * @param {Function} func The function to have its output memoized.
		     * @returns {Function} Returns the new memoized function.
		     */
		    function memoizeCapped(func) {
		      var result = memoize(func, function(key) {
		        if (cache.size === MAX_MEMOIZE_SIZE) {
		          cache.clear();
		        }
		        return key;
		      });

		      var cache = result.cache;
		      return result;
		    }

		    /**
		     * Merges the function metadata of `source` into `data`.
		     *
		     * Merging metadata reduces the number of wrappers used to invoke a function.
		     * This is possible because methods like `_.bind`, `_.curry`, and `_.partial`
		     * may be applied regardless of execution order. Methods like `_.ary` and
		     * `_.rearg` modify function arguments, making the order in which they are
		     * executed important, preventing the merging of metadata. However, we make
		     * an exception for a safe combined case where curried functions have `_.ary`
		     * and or `_.rearg` applied.
		     *
		     * @private
		     * @param {Array} data The destination metadata.
		     * @param {Array} source The source metadata.
		     * @returns {Array} Returns `data`.
		     */
		    function mergeData(data, source) {
		      var bitmask = data[1],
		          srcBitmask = source[1],
		          newBitmask = bitmask | srcBitmask,
		          isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);

		      var isCombo =
		        ((srcBitmask == WRAP_ARY_FLAG) && (bitmask == WRAP_CURRY_FLAG)) ||
		        ((srcBitmask == WRAP_ARY_FLAG) && (bitmask == WRAP_REARG_FLAG) && (data[7].length <= source[8])) ||
		        ((srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG)) && (source[7].length <= source[8]) && (bitmask == WRAP_CURRY_FLAG));

		      // Exit early if metadata can't be merged.
		      if (!(isCommon || isCombo)) {
		        return data;
		      }
		      // Use source `thisArg` if available.
		      if (srcBitmask & WRAP_BIND_FLAG) {
		        data[2] = source[2];
		        // Set when currying a bound function.
		        newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
		      }
		      // Compose partial arguments.
		      var value = source[3];
		      if (value) {
		        var partials = data[3];
		        data[3] = partials ? composeArgs(partials, value, source[4]) : value;
		        data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
		      }
		      // Compose partial right arguments.
		      value = source[5];
		      if (value) {
		        partials = data[5];
		        data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
		        data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
		      }
		      // Use source `argPos` if available.
		      value = source[7];
		      if (value) {
		        data[7] = value;
		      }
		      // Use source `ary` if it's smaller.
		      if (srcBitmask & WRAP_ARY_FLAG) {
		        data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
		      }
		      // Use source `arity` if one is not provided.
		      if (data[9] == null) {
		        data[9] = source[9];
		      }
		      // Use source `func` and merge bitmasks.
		      data[0] = source[0];
		      data[1] = newBitmask;

		      return data;
		    }

		    /**
		     * This function is like
		     * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
		     * except that it includes inherited enumerable properties.
		     *
		     * @private
		     * @param {Object} object The object to query.
		     * @returns {Array} Returns the array of property names.
		     */
		    function nativeKeysIn(object) {
		      var result = [];
		      if (object != null) {
		        for (var key in Object(object)) {
		          result.push(key);
		        }
		      }
		      return result;
		    }

		    /**
		     * Converts `value` to a string using `Object.prototype.toString`.
		     *
		     * @private
		     * @param {*} value The value to convert.
		     * @returns {string} Returns the converted string.
		     */
		    function objectToString(value) {
		      return nativeObjectToString.call(value);
		    }

		    /**
		     * A specialized version of `baseRest` which transforms the rest array.
		     *
		     * @private
		     * @param {Function} func The function to apply a rest parameter to.
		     * @param {number} [start=func.length-1] The start position of the rest parameter.
		     * @param {Function} transform The rest array transform.
		     * @returns {Function} Returns the new function.
		     */
		    function overRest(func, start, transform) {
		      start = nativeMax(start === undefined$1 ? (func.length - 1) : start, 0);
		      return function() {
		        var args = arguments,
		            index = -1,
		            length = nativeMax(args.length - start, 0),
		            array = Array(length);

		        while (++index < length) {
		          array[index] = args[start + index];
		        }
		        index = -1;
		        var otherArgs = Array(start + 1);
		        while (++index < start) {
		          otherArgs[index] = args[index];
		        }
		        otherArgs[start] = transform(array);
		        return apply(func, this, otherArgs);
		      };
		    }

		    /**
		     * Gets the parent value at `path` of `object`.
		     *
		     * @private
		     * @param {Object} object The object to query.
		     * @param {Array} path The path to get the parent value of.
		     * @returns {*} Returns the parent value.
		     */
		    function parent(object, path) {
		      return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
		    }

		    /**
		     * Reorder `array` according to the specified indexes where the element at
		     * the first index is assigned as the first element, the element at
		     * the second index is assigned as the second element, and so on.
		     *
		     * @private
		     * @param {Array} array The array to reorder.
		     * @param {Array} indexes The arranged array indexes.
		     * @returns {Array} Returns `array`.
		     */
		    function reorder(array, indexes) {
		      var arrLength = array.length,
		          length = nativeMin(indexes.length, arrLength),
		          oldArray = copyArray(array);

		      while (length--) {
		        var index = indexes[length];
		        array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined$1;
		      }
		      return array;
		    }

		    /**
		     * Gets the value at `key`, unless `key` is "__proto__" or "constructor".
		     *
		     * @private
		     * @param {Object} object The object to query.
		     * @param {string} key The key of the property to get.
		     * @returns {*} Returns the property value.
		     */
		    function safeGet(object, key) {
		      if (key === 'constructor' && typeof object[key] === 'function') {
		        return;
		      }

		      if (key == '__proto__') {
		        return;
		      }

		      return object[key];
		    }

		    /**
		     * Sets metadata for `func`.
		     *
		     * **Note:** If this function becomes hot, i.e. is invoked a lot in a short
		     * period of time, it will trip its breaker and transition to an identity
		     * function to avoid garbage collection pauses in V8. See
		     * [V8 issue 2070](https://bugs.chromium.org/p/v8/issues/detail?id=2070)
		     * for more details.
		     *
		     * @private
		     * @param {Function} func The function to associate metadata with.
		     * @param {*} data The metadata.
		     * @returns {Function} Returns `func`.
		     */
		    var setData = shortOut(baseSetData);

		    /**
		     * A simple wrapper around the global [`setTimeout`](https://mdn.io/setTimeout).
		     *
		     * @private
		     * @param {Function} func The function to delay.
		     * @param {number} wait The number of milliseconds to delay invocation.
		     * @returns {number|Object} Returns the timer id or timeout object.
		     */
		    var setTimeout = ctxSetTimeout || function(func, wait) {
		      return root.setTimeout(func, wait);
		    };

		    /**
		     * Sets the `toString` method of `func` to return `string`.
		     *
		     * @private
		     * @param {Function} func The function to modify.
		     * @param {Function} string The `toString` result.
		     * @returns {Function} Returns `func`.
		     */
		    var setToString = shortOut(baseSetToString);

		    /**
		     * Sets the `toString` method of `wrapper` to mimic the source of `reference`
		     * with wrapper details in a comment at the top of the source body.
		     *
		     * @private
		     * @param {Function} wrapper The function to modify.
		     * @param {Function} reference The reference function.
		     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
		     * @returns {Function} Returns `wrapper`.
		     */
		    function setWrapToString(wrapper, reference, bitmask) {
		      var source = (reference + '');
		      return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
		    }

		    /**
		     * Creates a function that'll short out and invoke `identity` instead
		     * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
		     * milliseconds.
		     *
		     * @private
		     * @param {Function} func The function to restrict.
		     * @returns {Function} Returns the new shortable function.
		     */
		    function shortOut(func) {
		      var count = 0,
		          lastCalled = 0;

		      return function() {
		        var stamp = nativeNow(),
		            remaining = HOT_SPAN - (stamp - lastCalled);

		        lastCalled = stamp;
		        if (remaining > 0) {
		          if (++count >= HOT_COUNT) {
		            return arguments[0];
		          }
		        } else {
		          count = 0;
		        }
		        return func.apply(undefined$1, arguments);
		      };
		    }

		    /**
		     * A specialized version of `_.shuffle` which mutates and sets the size of `array`.
		     *
		     * @private
		     * @param {Array} array The array to shuffle.
		     * @param {number} [size=array.length] The size of `array`.
		     * @returns {Array} Returns `array`.
		     */
		    function shuffleSelf(array, size) {
		      var index = -1,
		          length = array.length,
		          lastIndex = length - 1;

		      size = size === undefined$1 ? length : size;
		      while (++index < size) {
		        var rand = baseRandom(index, lastIndex),
		            value = array[rand];

		        array[rand] = array[index];
		        array[index] = value;
		      }
		      array.length = size;
		      return array;
		    }

		    /**
		     * Converts `string` to a property path array.
		     *
		     * @private
		     * @param {string} string The string to convert.
		     * @returns {Array} Returns the property path array.
		     */
		    var stringToPath = memoizeCapped(function(string) {
		      var result = [];
		      if (string.charCodeAt(0) === 46 /* . */) {
		        result.push('');
		      }
		      string.replace(rePropName, function(match, number, quote, subString) {
		        result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));
		      });
		      return result;
		    });

		    /**
		     * Converts `value` to a string key if it's not a string or symbol.
		     *
		     * @private
		     * @param {*} value The value to inspect.
		     * @returns {string|symbol} Returns the key.
		     */
		    function toKey(value) {
		      if (typeof value == 'string' || isSymbol(value)) {
		        return value;
		      }
		      var result = (value + '');
		      return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
		    }

		    /**
		     * Converts `func` to its source code.
		     *
		     * @private
		     * @param {Function} func The function to convert.
		     * @returns {string} Returns the source code.
		     */
		    function toSource(func) {
		      if (func != null) {
		        try {
		          return funcToString.call(func);
		        } catch (e) {}
		        try {
		          return (func + '');
		        } catch (e) {}
		      }
		      return '';
		    }

		    /**
		     * Updates wrapper `details` based on `bitmask` flags.
		     *
		     * @private
		     * @returns {Array} details The details to modify.
		     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
		     * @returns {Array} Returns `details`.
		     */
		    function updateWrapDetails(details, bitmask) {
		      arrayEach(wrapFlags, function(pair) {
		        var value = '_.' + pair[0];
		        if ((bitmask & pair[1]) && !arrayIncludes(details, value)) {
		          details.push(value);
		        }
		      });
		      return details.sort();
		    }

		    /**
		     * Creates a clone of `wrapper`.
		     *
		     * @private
		     * @param {Object} wrapper The wrapper to clone.
		     * @returns {Object} Returns the cloned wrapper.
		     */
		    function wrapperClone(wrapper) {
		      if (wrapper instanceof LazyWrapper) {
		        return wrapper.clone();
		      }
		      var result = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
		      result.__actions__ = copyArray(wrapper.__actions__);
		      result.__index__  = wrapper.__index__;
		      result.__values__ = wrapper.__values__;
		      return result;
		    }

		    /*------------------------------------------------------------------------*/

		    /**
		     * Creates an array of elements split into groups the length of `size`.
		     * If `array` can't be split evenly, the final chunk will be the remaining
		     * elements.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category Array
		     * @param {Array} array The array to process.
		     * @param {number} [size=1] The length of each chunk
		     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
		     * @returns {Array} Returns the new array of chunks.
		     * @example
		     *
		     * _.chunk(['a', 'b', 'c', 'd'], 2);
		     * // => [['a', 'b'], ['c', 'd']]
		     *
		     * _.chunk(['a', 'b', 'c', 'd'], 3);
		     * // => [['a', 'b', 'c'], ['d']]
		     */
		    function chunk(array, size, guard) {
		      if ((guard ? isIterateeCall(array, size, guard) : size === undefined$1)) {
		        size = 1;
		      } else {
		        size = nativeMax(toInteger(size), 0);
		      }
		      var length = array == null ? 0 : array.length;
		      if (!length || size < 1) {
		        return [];
		      }
		      var index = 0,
		          resIndex = 0,
		          result = Array(nativeCeil(length / size));

		      while (index < length) {
		        result[resIndex++] = baseSlice(array, index, (index += size));
		      }
		      return result;
		    }

		    /**
		     * Creates an array with all falsey values removed. The values `false`, `null`,
		     * `0`, `""`, `undefined`, and `NaN` are falsey.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Array
		     * @param {Array} array The array to compact.
		     * @returns {Array} Returns the new array of filtered values.
		     * @example
		     *
		     * _.compact([0, 1, false, 2, '', 3]);
		     * // => [1, 2, 3]
		     */
		    function compact(array) {
		      var index = -1,
		          length = array == null ? 0 : array.length,
		          resIndex = 0,
		          result = [];

		      while (++index < length) {
		        var value = array[index];
		        if (value) {
		          result[resIndex++] = value;
		        }
		      }
		      return result;
		    }

		    /**
		     * Creates a new array concatenating `array` with any additional arrays
		     * and/or values.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Array
		     * @param {Array} array The array to concatenate.
		     * @param {...*} [values] The values to concatenate.
		     * @returns {Array} Returns the new concatenated array.
		     * @example
		     *
		     * var array = [1];
		     * var other = _.concat(array, 2, [3], [[4]]);
		     *
		     * console.log(other);
		     * // => [1, 2, 3, [4]]
		     *
		     * console.log(array);
		     * // => [1]
		     */
		    function concat() {
		      var length = arguments.length;
		      if (!length) {
		        return [];
		      }
		      var args = Array(length - 1),
		          array = arguments[0],
		          index = length;

		      while (index--) {
		        args[index - 1] = arguments[index];
		      }
		      return arrayPush(isArray(array) ? copyArray(array) : [array], baseFlatten(args, 1));
		    }

		    /**
		     * Creates an array of `array` values not included in the other given arrays
		     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
		     * for equality comparisons. The order and references of result values are
		     * determined by the first array.
		     *
		     * **Note:** Unlike `_.pullAll`, this method returns a new array.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Array
		     * @param {Array} array The array to inspect.
		     * @param {...Array} [values] The values to exclude.
		     * @returns {Array} Returns the new array of filtered values.
		     * @see _.without, _.xor
		     * @example
		     *
		     * _.difference([2, 1], [2, 3]);
		     * // => [1]
		     */
		    var difference = baseRest(function(array, values) {
		      return isArrayLikeObject(array)
		        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true))
		        : [];
		    });

		    /**
		     * This method is like `_.difference` except that it accepts `iteratee` which
		     * is invoked for each element of `array` and `values` to generate the criterion
		     * by which they're compared. The order and references of result values are
		     * determined by the first array. The iteratee is invoked with one argument:
		     * (value).
		     *
		     * **Note:** Unlike `_.pullAllBy`, this method returns a new array.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Array
		     * @param {Array} array The array to inspect.
		     * @param {...Array} [values] The values to exclude.
		     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
		     * @returns {Array} Returns the new array of filtered values.
		     * @example
		     *
		     * _.differenceBy([2.1, 1.2], [2.3, 3.4], Math.floor);
		     * // => [1.2]
		     *
		     * // The `_.property` iteratee shorthand.
		     * _.differenceBy([{ 'x': 2 }, { 'x': 1 }], [{ 'x': 1 }], 'x');
		     * // => [{ 'x': 2 }]
		     */
		    var differenceBy = baseRest(function(array, values) {
		      var iteratee = last(values);
		      if (isArrayLikeObject(iteratee)) {
		        iteratee = undefined$1;
		      }
		      return isArrayLikeObject(array)
		        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), getIteratee(iteratee, 2))
		        : [];
		    });

		    /**
		     * This method is like `_.difference` except that it accepts `comparator`
		     * which is invoked to compare elements of `array` to `values`. The order and
		     * references of result values are determined by the first array. The comparator
		     * is invoked with two arguments: (arrVal, othVal).
		     *
		     * **Note:** Unlike `_.pullAllWith`, this method returns a new array.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Array
		     * @param {Array} array The array to inspect.
		     * @param {...Array} [values] The values to exclude.
		     * @param {Function} [comparator] The comparator invoked per element.
		     * @returns {Array} Returns the new array of filtered values.
		     * @example
		     *
		     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
		     *
		     * _.differenceWith(objects, [{ 'x': 1, 'y': 2 }], _.isEqual);
		     * // => [{ 'x': 2, 'y': 1 }]
		     */
		    var differenceWith = baseRest(function(array, values) {
		      var comparator = last(values);
		      if (isArrayLikeObject(comparator)) {
		        comparator = undefined$1;
		      }
		      return isArrayLikeObject(array)
		        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), undefined$1, comparator)
		        : [];
		    });

		    /**
		     * Creates a slice of `array` with `n` elements dropped from the beginning.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.5.0
		     * @category Array
		     * @param {Array} array The array to query.
		     * @param {number} [n=1] The number of elements to drop.
		     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
		     * @returns {Array} Returns the slice of `array`.
		     * @example
		     *
		     * _.drop([1, 2, 3]);
		     * // => [2, 3]
		     *
		     * _.drop([1, 2, 3], 2);
		     * // => [3]
		     *
		     * _.drop([1, 2, 3], 5);
		     * // => []
		     *
		     * _.drop([1, 2, 3], 0);
		     * // => [1, 2, 3]
		     */
		    function drop(array, n, guard) {
		      var length = array == null ? 0 : array.length;
		      if (!length) {
		        return [];
		      }
		      n = (guard || n === undefined$1) ? 1 : toInteger(n);
		      return baseSlice(array, n < 0 ? 0 : n, length);
		    }

		    /**
		     * Creates a slice of `array` with `n` elements dropped from the end.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category Array
		     * @param {Array} array The array to query.
		     * @param {number} [n=1] The number of elements to drop.
		     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
		     * @returns {Array} Returns the slice of `array`.
		     * @example
		     *
		     * _.dropRight([1, 2, 3]);
		     * // => [1, 2]
		     *
		     * _.dropRight([1, 2, 3], 2);
		     * // => [1]
		     *
		     * _.dropRight([1, 2, 3], 5);
		     * // => []
		     *
		     * _.dropRight([1, 2, 3], 0);
		     * // => [1, 2, 3]
		     */
		    function dropRight(array, n, guard) {
		      var length = array == null ? 0 : array.length;
		      if (!length) {
		        return [];
		      }
		      n = (guard || n === undefined$1) ? 1 : toInteger(n);
		      n = length - n;
		      return baseSlice(array, 0, n < 0 ? 0 : n);
		    }

		    /**
		     * Creates a slice of `array` excluding elements dropped from the end.
		     * Elements are dropped until `predicate` returns falsey. The predicate is
		     * invoked with three arguments: (value, index, array).
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category Array
		     * @param {Array} array The array to query.
		     * @param {Function} [predicate=_.identity] The function invoked per iteration.
		     * @returns {Array} Returns the slice of `array`.
		     * @example
		     *
		     * var users = [
		     *   { 'user': 'barney',  'active': true },
		     *   { 'user': 'fred',    'active': false },
		     *   { 'user': 'pebbles', 'active': false }
		     * ];
		     *
		     * _.dropRightWhile(users, function(o) { return !o.active; });
		     * // => objects for ['barney']
		     *
		     * // The `_.matches` iteratee shorthand.
		     * _.dropRightWhile(users, { 'user': 'pebbles', 'active': false });
		     * // => objects for ['barney', 'fred']
		     *
		     * // The `_.matchesProperty` iteratee shorthand.
		     * _.dropRightWhile(users, ['active', false]);
		     * // => objects for ['barney']
		     *
		     * // The `_.property` iteratee shorthand.
		     * _.dropRightWhile(users, 'active');
		     * // => objects for ['barney', 'fred', 'pebbles']
		     */
		    function dropRightWhile(array, predicate) {
		      return (array && array.length)
		        ? baseWhile(array, getIteratee(predicate, 3), true, true)
		        : [];
		    }

		    /**
		     * Creates a slice of `array` excluding elements dropped from the beginning.
		     * Elements are dropped until `predicate` returns falsey. The predicate is
		     * invoked with three arguments: (value, index, array).
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category Array
		     * @param {Array} array The array to query.
		     * @param {Function} [predicate=_.identity] The function invoked per iteration.
		     * @returns {Array} Returns the slice of `array`.
		     * @example
		     *
		     * var users = [
		     *   { 'user': 'barney',  'active': false },
		     *   { 'user': 'fred',    'active': false },
		     *   { 'user': 'pebbles', 'active': true }
		     * ];
		     *
		     * _.dropWhile(users, function(o) { return !o.active; });
		     * // => objects for ['pebbles']
		     *
		     * // The `_.matches` iteratee shorthand.
		     * _.dropWhile(users, { 'user': 'barney', 'active': false });
		     * // => objects for ['fred', 'pebbles']
		     *
		     * // The `_.matchesProperty` iteratee shorthand.
		     * _.dropWhile(users, ['active', false]);
		     * // => objects for ['pebbles']
		     *
		     * // The `_.property` iteratee shorthand.
		     * _.dropWhile(users, 'active');
		     * // => objects for ['barney', 'fred', 'pebbles']
		     */
		    function dropWhile(array, predicate) {
		      return (array && array.length)
		        ? baseWhile(array, getIteratee(predicate, 3), true)
		        : [];
		    }

		    /**
		     * Fills elements of `array` with `value` from `start` up to, but not
		     * including, `end`.
		     *
		     * **Note:** This method mutates `array`.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.2.0
		     * @category Array
		     * @param {Array} array The array to fill.
		     * @param {*} value The value to fill `array` with.
		     * @param {number} [start=0] The start position.
		     * @param {number} [end=array.length] The end position.
		     * @returns {Array} Returns `array`.
		     * @example
		     *
		     * var array = [1, 2, 3];
		     *
		     * _.fill(array, 'a');
		     * console.log(array);
		     * // => ['a', 'a', 'a']
		     *
		     * _.fill(Array(3), 2);
		     * // => [2, 2, 2]
		     *
		     * _.fill([4, 6, 8, 10], '*', 1, 3);
		     * // => [4, '*', '*', 10]
		     */
		    function fill(array, value, start, end) {
		      var length = array == null ? 0 : array.length;
		      if (!length) {
		        return [];
		      }
		      if (start && typeof start != 'number' && isIterateeCall(array, value, start)) {
		        start = 0;
		        end = length;
		      }
		      return baseFill(array, value, start, end);
		    }

		    /**
		     * This method is like `_.find` except that it returns the index of the first
		     * element `predicate` returns truthy for instead of the element itself.
		     *
		     * @static
		     * @memberOf _
		     * @since 1.1.0
		     * @category Array
		     * @param {Array} array The array to inspect.
		     * @param {Function} [predicate=_.identity] The function invoked per iteration.
		     * @param {number} [fromIndex=0] The index to search from.
		     * @returns {number} Returns the index of the found element, else `-1`.
		     * @example
		     *
		     * var users = [
		     *   { 'user': 'barney',  'active': false },
		     *   { 'user': 'fred',    'active': false },
		     *   { 'user': 'pebbles', 'active': true }
		     * ];
		     *
		     * _.findIndex(users, function(o) { return o.user == 'barney'; });
		     * // => 0
		     *
		     * // The `_.matches` iteratee shorthand.
		     * _.findIndex(users, { 'user': 'fred', 'active': false });
		     * // => 1
		     *
		     * // The `_.matchesProperty` iteratee shorthand.
		     * _.findIndex(users, ['active', false]);
		     * // => 0
		     *
		     * // The `_.property` iteratee shorthand.
		     * _.findIndex(users, 'active');
		     * // => 2
		     */
		    function findIndex(array, predicate, fromIndex) {
		      var length = array == null ? 0 : array.length;
		      if (!length) {
		        return -1;
		      }
		      var index = fromIndex == null ? 0 : toInteger(fromIndex);
		      if (index < 0) {
		        index = nativeMax(length + index, 0);
		      }
		      return baseFindIndex(array, getIteratee(predicate, 3), index);
		    }

		    /**
		     * This method is like `_.findIndex` except that it iterates over elements
		     * of `collection` from right to left.
		     *
		     * @static
		     * @memberOf _
		     * @since 2.0.0
		     * @category Array
		     * @param {Array} array The array to inspect.
		     * @param {Function} [predicate=_.identity] The function invoked per iteration.
		     * @param {number} [fromIndex=array.length-1] The index to search from.
		     * @returns {number} Returns the index of the found element, else `-1`.
		     * @example
		     *
		     * var users = [
		     *   { 'user': 'barney',  'active': true },
		     *   { 'user': 'fred',    'active': false },
		     *   { 'user': 'pebbles', 'active': false }
		     * ];
		     *
		     * _.findLastIndex(users, function(o) { return o.user == 'pebbles'; });
		     * // => 2
		     *
		     * // The `_.matches` iteratee shorthand.
		     * _.findLastIndex(users, { 'user': 'barney', 'active': true });
		     * // => 0
		     *
		     * // The `_.matchesProperty` iteratee shorthand.
		     * _.findLastIndex(users, ['active', false]);
		     * // => 2
		     *
		     * // The `_.property` iteratee shorthand.
		     * _.findLastIndex(users, 'active');
		     * // => 0
		     */
		    function findLastIndex(array, predicate, fromIndex) {
		      var length = array == null ? 0 : array.length;
		      if (!length) {
		        return -1;
		      }
		      var index = length - 1;
		      if (fromIndex !== undefined$1) {
		        index = toInteger(fromIndex);
		        index = fromIndex < 0
		          ? nativeMax(length + index, 0)
		          : nativeMin(index, length - 1);
		      }
		      return baseFindIndex(array, getIteratee(predicate, 3), index, true);
		    }

		    /**
		     * Flattens `array` a single level deep.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Array
		     * @param {Array} array The array to flatten.
		     * @returns {Array} Returns the new flattened array.
		     * @example
		     *
		     * _.flatten([1, [2, [3, [4]], 5]]);
		     * // => [1, 2, [3, [4]], 5]
		     */
		    function flatten(array) {
		      var length = array == null ? 0 : array.length;
		      return length ? baseFlatten(array, 1) : [];
		    }

		    /**
		     * Recursively flattens `array`.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category Array
		     * @param {Array} array The array to flatten.
		     * @returns {Array} Returns the new flattened array.
		     * @example
		     *
		     * _.flattenDeep([1, [2, [3, [4]], 5]]);
		     * // => [1, 2, 3, 4, 5]
		     */
		    function flattenDeep(array) {
		      var length = array == null ? 0 : array.length;
		      return length ? baseFlatten(array, INFINITY) : [];
		    }

		    /**
		     * Recursively flatten `array` up to `depth` times.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.4.0
		     * @category Array
		     * @param {Array} array The array to flatten.
		     * @param {number} [depth=1] The maximum recursion depth.
		     * @returns {Array} Returns the new flattened array.
		     * @example
		     *
		     * var array = [1, [2, [3, [4]], 5]];
		     *
		     * _.flattenDepth(array, 1);
		     * // => [1, 2, [3, [4]], 5]
		     *
		     * _.flattenDepth(array, 2);
		     * // => [1, 2, 3, [4], 5]
		     */
		    function flattenDepth(array, depth) {
		      var length = array == null ? 0 : array.length;
		      if (!length) {
		        return [];
		      }
		      depth = depth === undefined$1 ? 1 : toInteger(depth);
		      return baseFlatten(array, depth);
		    }

		    /**
		     * The inverse of `_.toPairs`; this method returns an object composed
		     * from key-value `pairs`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Array
		     * @param {Array} pairs The key-value pairs.
		     * @returns {Object} Returns the new object.
		     * @example
		     *
		     * _.fromPairs([['a', 1], ['b', 2]]);
		     * // => { 'a': 1, 'b': 2 }
		     */
		    function fromPairs(pairs) {
		      var index = -1,
		          length = pairs == null ? 0 : pairs.length,
		          result = {};

		      while (++index < length) {
		        var pair = pairs[index];
		        result[pair[0]] = pair[1];
		      }
		      return result;
		    }

		    /**
		     * Gets the first element of `array`.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @alias first
		     * @category Array
		     * @param {Array} array The array to query.
		     * @returns {*} Returns the first element of `array`.
		     * @example
		     *
		     * _.head([1, 2, 3]);
		     * // => 1
		     *
		     * _.head([]);
		     * // => undefined
		     */
		    function head(array) {
		      return (array && array.length) ? array[0] : undefined$1;
		    }

		    /**
		     * Gets the index at which the first occurrence of `value` is found in `array`
		     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
		     * for equality comparisons. If `fromIndex` is negative, it's used as the
		     * offset from the end of `array`.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Array
		     * @param {Array} array The array to inspect.
		     * @param {*} value The value to search for.
		     * @param {number} [fromIndex=0] The index to search from.
		     * @returns {number} Returns the index of the matched value, else `-1`.
		     * @example
		     *
		     * _.indexOf([1, 2, 1, 2], 2);
		     * // => 1
		     *
		     * // Search from the `fromIndex`.
		     * _.indexOf([1, 2, 1, 2], 2, 2);
		     * // => 3
		     */
		    function indexOf(array, value, fromIndex) {
		      var length = array == null ? 0 : array.length;
		      if (!length) {
		        return -1;
		      }
		      var index = fromIndex == null ? 0 : toInteger(fromIndex);
		      if (index < 0) {
		        index = nativeMax(length + index, 0);
		      }
		      return baseIndexOf(array, value, index);
		    }

		    /**
		     * Gets all but the last element of `array`.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Array
		     * @param {Array} array The array to query.
		     * @returns {Array} Returns the slice of `array`.
		     * @example
		     *
		     * _.initial([1, 2, 3]);
		     * // => [1, 2]
		     */
		    function initial(array) {
		      var length = array == null ? 0 : array.length;
		      return length ? baseSlice(array, 0, -1) : [];
		    }

		    /**
		     * Creates an array of unique values that are included in all given arrays
		     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
		     * for equality comparisons. The order and references of result values are
		     * determined by the first array.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Array
		     * @param {...Array} [arrays] The arrays to inspect.
		     * @returns {Array} Returns the new array of intersecting values.
		     * @example
		     *
		     * _.intersection([2, 1], [2, 3]);
		     * // => [2]
		     */
		    var intersection = baseRest(function(arrays) {
		      var mapped = arrayMap(arrays, castArrayLikeObject);
		      return (mapped.length && mapped[0] === arrays[0])
		        ? baseIntersection(mapped)
		        : [];
		    });

		    /**
		     * This method is like `_.intersection` except that it accepts `iteratee`
		     * which is invoked for each element of each `arrays` to generate the criterion
		     * by which they're compared. The order and references of result values are
		     * determined by the first array. The iteratee is invoked with one argument:
		     * (value).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Array
		     * @param {...Array} [arrays] The arrays to inspect.
		     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
		     * @returns {Array} Returns the new array of intersecting values.
		     * @example
		     *
		     * _.intersectionBy([2.1, 1.2], [2.3, 3.4], Math.floor);
		     * // => [2.1]
		     *
		     * // The `_.property` iteratee shorthand.
		     * _.intersectionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
		     * // => [{ 'x': 1 }]
		     */
		    var intersectionBy = baseRest(function(arrays) {
		      var iteratee = last(arrays),
		          mapped = arrayMap(arrays, castArrayLikeObject);

		      if (iteratee === last(mapped)) {
		        iteratee = undefined$1;
		      } else {
		        mapped.pop();
		      }
		      return (mapped.length && mapped[0] === arrays[0])
		        ? baseIntersection(mapped, getIteratee(iteratee, 2))
		        : [];
		    });

		    /**
		     * This method is like `_.intersection` except that it accepts `comparator`
		     * which is invoked to compare elements of `arrays`. The order and references
		     * of result values are determined by the first array. The comparator is
		     * invoked with two arguments: (arrVal, othVal).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Array
		     * @param {...Array} [arrays] The arrays to inspect.
		     * @param {Function} [comparator] The comparator invoked per element.
		     * @returns {Array} Returns the new array of intersecting values.
		     * @example
		     *
		     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
		     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
		     *
		     * _.intersectionWith(objects, others, _.isEqual);
		     * // => [{ 'x': 1, 'y': 2 }]
		     */
		    var intersectionWith = baseRest(function(arrays) {
		      var comparator = last(arrays),
		          mapped = arrayMap(arrays, castArrayLikeObject);

		      comparator = typeof comparator == 'function' ? comparator : undefined$1;
		      if (comparator) {
		        mapped.pop();
		      }
		      return (mapped.length && mapped[0] === arrays[0])
		        ? baseIntersection(mapped, undefined$1, comparator)
		        : [];
		    });

		    /**
		     * Converts all elements in `array` into a string separated by `separator`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Array
		     * @param {Array} array The array to convert.
		     * @param {string} [separator=','] The element separator.
		     * @returns {string} Returns the joined string.
		     * @example
		     *
		     * _.join(['a', 'b', 'c'], '~');
		     * // => 'a~b~c'
		     */
		    function join(array, separator) {
		      return array == null ? '' : nativeJoin.call(array, separator);
		    }

		    /**
		     * Gets the last element of `array`.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Array
		     * @param {Array} array The array to query.
		     * @returns {*} Returns the last element of `array`.
		     * @example
		     *
		     * _.last([1, 2, 3]);
		     * // => 3
		     */
		    function last(array) {
		      var length = array == null ? 0 : array.length;
		      return length ? array[length - 1] : undefined$1;
		    }

		    /**
		     * This method is like `_.indexOf` except that it iterates over elements of
		     * `array` from right to left.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Array
		     * @param {Array} array The array to inspect.
		     * @param {*} value The value to search for.
		     * @param {number} [fromIndex=array.length-1] The index to search from.
		     * @returns {number} Returns the index of the matched value, else `-1`.
		     * @example
		     *
		     * _.lastIndexOf([1, 2, 1, 2], 2);
		     * // => 3
		     *
		     * // Search from the `fromIndex`.
		     * _.lastIndexOf([1, 2, 1, 2], 2, 2);
		     * // => 1
		     */
		    function lastIndexOf(array, value, fromIndex) {
		      var length = array == null ? 0 : array.length;
		      if (!length) {
		        return -1;
		      }
		      var index = length;
		      if (fromIndex !== undefined$1) {
		        index = toInteger(fromIndex);
		        index = index < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
		      }
		      return value === value
		        ? strictLastIndexOf(array, value, index)
		        : baseFindIndex(array, baseIsNaN, index, true);
		    }

		    /**
		     * Gets the element at index `n` of `array`. If `n` is negative, the nth
		     * element from the end is returned.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.11.0
		     * @category Array
		     * @param {Array} array The array to query.
		     * @param {number} [n=0] The index of the element to return.
		     * @returns {*} Returns the nth element of `array`.
		     * @example
		     *
		     * var array = ['a', 'b', 'c', 'd'];
		     *
		     * _.nth(array, 1);
		     * // => 'b'
		     *
		     * _.nth(array, -2);
		     * // => 'c';
		     */
		    function nth(array, n) {
		      return (array && array.length) ? baseNth(array, toInteger(n)) : undefined$1;
		    }

		    /**
		     * Removes all given values from `array` using
		     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
		     * for equality comparisons.
		     *
		     * **Note:** Unlike `_.without`, this method mutates `array`. Use `_.remove`
		     * to remove elements from an array by predicate.
		     *
		     * @static
		     * @memberOf _
		     * @since 2.0.0
		     * @category Array
		     * @param {Array} array The array to modify.
		     * @param {...*} [values] The values to remove.
		     * @returns {Array} Returns `array`.
		     * @example
		     *
		     * var array = ['a', 'b', 'c', 'a', 'b', 'c'];
		     *
		     * _.pull(array, 'a', 'c');
		     * console.log(array);
		     * // => ['b', 'b']
		     */
		    var pull = baseRest(pullAll);

		    /**
		     * This method is like `_.pull` except that it accepts an array of values to remove.
		     *
		     * **Note:** Unlike `_.difference`, this method mutates `array`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Array
		     * @param {Array} array The array to modify.
		     * @param {Array} values The values to remove.
		     * @returns {Array} Returns `array`.
		     * @example
		     *
		     * var array = ['a', 'b', 'c', 'a', 'b', 'c'];
		     *
		     * _.pullAll(array, ['a', 'c']);
		     * console.log(array);
		     * // => ['b', 'b']
		     */
		    function pullAll(array, values) {
		      return (array && array.length && values && values.length)
		        ? basePullAll(array, values)
		        : array;
		    }

		    /**
		     * This method is like `_.pullAll` except that it accepts `iteratee` which is
		     * invoked for each element of `array` and `values` to generate the criterion
		     * by which they're compared. The iteratee is invoked with one argument: (value).
		     *
		     * **Note:** Unlike `_.differenceBy`, this method mutates `array`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Array
		     * @param {Array} array The array to modify.
		     * @param {Array} values The values to remove.
		     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
		     * @returns {Array} Returns `array`.
		     * @example
		     *
		     * var array = [{ 'x': 1 }, { 'x': 2 }, { 'x': 3 }, { 'x': 1 }];
		     *
		     * _.pullAllBy(array, [{ 'x': 1 }, { 'x': 3 }], 'x');
		     * console.log(array);
		     * // => [{ 'x': 2 }]
		     */
		    function pullAllBy(array, values, iteratee) {
		      return (array && array.length && values && values.length)
		        ? basePullAll(array, values, getIteratee(iteratee, 2))
		        : array;
		    }

		    /**
		     * This method is like `_.pullAll` except that it accepts `comparator` which
		     * is invoked to compare elements of `array` to `values`. The comparator is
		     * invoked with two arguments: (arrVal, othVal).
		     *
		     * **Note:** Unlike `_.differenceWith`, this method mutates `array`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.6.0
		     * @category Array
		     * @param {Array} array The array to modify.
		     * @param {Array} values The values to remove.
		     * @param {Function} [comparator] The comparator invoked per element.
		     * @returns {Array} Returns `array`.
		     * @example
		     *
		     * var array = [{ 'x': 1, 'y': 2 }, { 'x': 3, 'y': 4 }, { 'x': 5, 'y': 6 }];
		     *
		     * _.pullAllWith(array, [{ 'x': 3, 'y': 4 }], _.isEqual);
		     * console.log(array);
		     * // => [{ 'x': 1, 'y': 2 }, { 'x': 5, 'y': 6 }]
		     */
		    function pullAllWith(array, values, comparator) {
		      return (array && array.length && values && values.length)
		        ? basePullAll(array, values, undefined$1, comparator)
		        : array;
		    }

		    /**
		     * Removes elements from `array` corresponding to `indexes` and returns an
		     * array of removed elements.
		     *
		     * **Note:** Unlike `_.at`, this method mutates `array`.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category Array
		     * @param {Array} array The array to modify.
		     * @param {...(number|number[])} [indexes] The indexes of elements to remove.
		     * @returns {Array} Returns the new array of removed elements.
		     * @example
		     *
		     * var array = ['a', 'b', 'c', 'd'];
		     * var pulled = _.pullAt(array, [1, 3]);
		     *
		     * console.log(array);
		     * // => ['a', 'c']
		     *
		     * console.log(pulled);
		     * // => ['b', 'd']
		     */
		    var pullAt = flatRest(function(array, indexes) {
		      var length = array == null ? 0 : array.length,
		          result = baseAt(array, indexes);

		      basePullAt(array, arrayMap(indexes, function(index) {
		        return isIndex(index, length) ? +index : index;
		      }).sort(compareAscending));

		      return result;
		    });

		    /**
		     * Removes all elements from `array` that `predicate` returns truthy for
		     * and returns an array of the removed elements. The predicate is invoked
		     * with three arguments: (value, index, array).
		     *
		     * **Note:** Unlike `_.filter`, this method mutates `array`. Use `_.pull`
		     * to pull elements from an array by value.
		     *
		     * @static
		     * @memberOf _
		     * @since 2.0.0
		     * @category Array
		     * @param {Array} array The array to modify.
		     * @param {Function} [predicate=_.identity] The function invoked per iteration.
		     * @returns {Array} Returns the new array of removed elements.
		     * @example
		     *
		     * var array = [1, 2, 3, 4];
		     * var evens = _.remove(array, function(n) {
		     *   return n % 2 == 0;
		     * });
		     *
		     * console.log(array);
		     * // => [1, 3]
		     *
		     * console.log(evens);
		     * // => [2, 4]
		     */
		    function remove(array, predicate) {
		      var result = [];
		      if (!(array && array.length)) {
		        return result;
		      }
		      var index = -1,
		          indexes = [],
		          length = array.length;

		      predicate = getIteratee(predicate, 3);
		      while (++index < length) {
		        var value = array[index];
		        if (predicate(value, index, array)) {
		          result.push(value);
		          indexes.push(index);
		        }
		      }
		      basePullAt(array, indexes);
		      return result;
		    }

		    /**
		     * Reverses `array` so that the first element becomes the last, the second
		     * element becomes the second to last, and so on.
		     *
		     * **Note:** This method mutates `array` and is based on
		     * [`Array#reverse`](https://mdn.io/Array/reverse).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Array
		     * @param {Array} array The array to modify.
		     * @returns {Array} Returns `array`.
		     * @example
		     *
		     * var array = [1, 2, 3];
		     *
		     * _.reverse(array);
		     * // => [3, 2, 1]
		     *
		     * console.log(array);
		     * // => [3, 2, 1]
		     */
		    function reverse(array) {
		      return array == null ? array : nativeReverse.call(array);
		    }

		    /**
		     * Creates a slice of `array` from `start` up to, but not including, `end`.
		     *
		     * **Note:** This method is used instead of
		     * [`Array#slice`](https://mdn.io/Array/slice) to ensure dense arrays are
		     * returned.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category Array
		     * @param {Array} array The array to slice.
		     * @param {number} [start=0] The start position.
		     * @param {number} [end=array.length] The end position.
		     * @returns {Array} Returns the slice of `array`.
		     */
		    function slice(array, start, end) {
		      var length = array == null ? 0 : array.length;
		      if (!length) {
		        return [];
		      }
		      if (end && typeof end != 'number' && isIterateeCall(array, start, end)) {
		        start = 0;
		        end = length;
		      }
		      else {
		        start = start == null ? 0 : toInteger(start);
		        end = end === undefined$1 ? length : toInteger(end);
		      }
		      return baseSlice(array, start, end);
		    }

		    /**
		     * Uses a binary search to determine the lowest index at which `value`
		     * should be inserted into `array` in order to maintain its sort order.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Array
		     * @param {Array} array The sorted array to inspect.
		     * @param {*} value The value to evaluate.
		     * @returns {number} Returns the index at which `value` should be inserted
		     *  into `array`.
		     * @example
		     *
		     * _.sortedIndex([30, 50], 40);
		     * // => 1
		     */
		    function sortedIndex(array, value) {
		      return baseSortedIndex(array, value);
		    }

		    /**
		     * This method is like `_.sortedIndex` except that it accepts `iteratee`
		     * which is invoked for `value` and each element of `array` to compute their
		     * sort ranking. The iteratee is invoked with one argument: (value).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Array
		     * @param {Array} array The sorted array to inspect.
		     * @param {*} value The value to evaluate.
		     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
		     * @returns {number} Returns the index at which `value` should be inserted
		     *  into `array`.
		     * @example
		     *
		     * var objects = [{ 'x': 4 }, { 'x': 5 }];
		     *
		     * _.sortedIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });
		     * // => 0
		     *
		     * // The `_.property` iteratee shorthand.
		     * _.sortedIndexBy(objects, { 'x': 4 }, 'x');
		     * // => 0
		     */
		    function sortedIndexBy(array, value, iteratee) {
		      return baseSortedIndexBy(array, value, getIteratee(iteratee, 2));
		    }

		    /**
		     * This method is like `_.indexOf` except that it performs a binary
		     * search on a sorted `array`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Array
		     * @param {Array} array The array to inspect.
		     * @param {*} value The value to search for.
		     * @returns {number} Returns the index of the matched value, else `-1`.
		     * @example
		     *
		     * _.sortedIndexOf([4, 5, 5, 5, 6], 5);
		     * // => 1
		     */
		    function sortedIndexOf(array, value) {
		      var length = array == null ? 0 : array.length;
		      if (length) {
		        var index = baseSortedIndex(array, value);
		        if (index < length && eq(array[index], value)) {
		          return index;
		        }
		      }
		      return -1;
		    }

		    /**
		     * This method is like `_.sortedIndex` except that it returns the highest
		     * index at which `value` should be inserted into `array` in order to
		     * maintain its sort order.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category Array
		     * @param {Array} array The sorted array to inspect.
		     * @param {*} value The value to evaluate.
		     * @returns {number} Returns the index at which `value` should be inserted
		     *  into `array`.
		     * @example
		     *
		     * _.sortedLastIndex([4, 5, 5, 5, 6], 5);
		     * // => 4
		     */
		    function sortedLastIndex(array, value) {
		      return baseSortedIndex(array, value, true);
		    }

		    /**
		     * This method is like `_.sortedLastIndex` except that it accepts `iteratee`
		     * which is invoked for `value` and each element of `array` to compute their
		     * sort ranking. The iteratee is invoked with one argument: (value).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Array
		     * @param {Array} array The sorted array to inspect.
		     * @param {*} value The value to evaluate.
		     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
		     * @returns {number} Returns the index at which `value` should be inserted
		     *  into `array`.
		     * @example
		     *
		     * var objects = [{ 'x': 4 }, { 'x': 5 }];
		     *
		     * _.sortedLastIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });
		     * // => 1
		     *
		     * // The `_.property` iteratee shorthand.
		     * _.sortedLastIndexBy(objects, { 'x': 4 }, 'x');
		     * // => 1
		     */
		    function sortedLastIndexBy(array, value, iteratee) {
		      return baseSortedIndexBy(array, value, getIteratee(iteratee, 2), true);
		    }

		    /**
		     * This method is like `_.lastIndexOf` except that it performs a binary
		     * search on a sorted `array`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Array
		     * @param {Array} array The array to inspect.
		     * @param {*} value The value to search for.
		     * @returns {number} Returns the index of the matched value, else `-1`.
		     * @example
		     *
		     * _.sortedLastIndexOf([4, 5, 5, 5, 6], 5);
		     * // => 3
		     */
		    function sortedLastIndexOf(array, value) {
		      var length = array == null ? 0 : array.length;
		      if (length) {
		        var index = baseSortedIndex(array, value, true) - 1;
		        if (eq(array[index], value)) {
		          return index;
		        }
		      }
		      return -1;
		    }

		    /**
		     * This method is like `_.uniq` except that it's designed and optimized
		     * for sorted arrays.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Array
		     * @param {Array} array The array to inspect.
		     * @returns {Array} Returns the new duplicate free array.
		     * @example
		     *
		     * _.sortedUniq([1, 1, 2]);
		     * // => [1, 2]
		     */
		    function sortedUniq(array) {
		      return (array && array.length)
		        ? baseSortedUniq(array)
		        : [];
		    }

		    /**
		     * This method is like `_.uniqBy` except that it's designed and optimized
		     * for sorted arrays.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Array
		     * @param {Array} array The array to inspect.
		     * @param {Function} [iteratee] The iteratee invoked per element.
		     * @returns {Array} Returns the new duplicate free array.
		     * @example
		     *
		     * _.sortedUniqBy([1.1, 1.2, 2.3, 2.4], Math.floor);
		     * // => [1.1, 2.3]
		     */
		    function sortedUniqBy(array, iteratee) {
		      return (array && array.length)
		        ? baseSortedUniq(array, getIteratee(iteratee, 2))
		        : [];
		    }

		    /**
		     * Gets all but the first element of `array`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Array
		     * @param {Array} array The array to query.
		     * @returns {Array} Returns the slice of `array`.
		     * @example
		     *
		     * _.tail([1, 2, 3]);
		     * // => [2, 3]
		     */
		    function tail(array) {
		      var length = array == null ? 0 : array.length;
		      return length ? baseSlice(array, 1, length) : [];
		    }

		    /**
		     * Creates a slice of `array` with `n` elements taken from the beginning.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Array
		     * @param {Array} array The array to query.
		     * @param {number} [n=1] The number of elements to take.
		     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
		     * @returns {Array} Returns the slice of `array`.
		     * @example
		     *
		     * _.take([1, 2, 3]);
		     * // => [1]
		     *
		     * _.take([1, 2, 3], 2);
		     * // => [1, 2]
		     *
		     * _.take([1, 2, 3], 5);
		     * // => [1, 2, 3]
		     *
		     * _.take([1, 2, 3], 0);
		     * // => []
		     */
		    function take(array, n, guard) {
		      if (!(array && array.length)) {
		        return [];
		      }
		      n = (guard || n === undefined$1) ? 1 : toInteger(n);
		      return baseSlice(array, 0, n < 0 ? 0 : n);
		    }

		    /**
		     * Creates a slice of `array` with `n` elements taken from the end.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category Array
		     * @param {Array} array The array to query.
		     * @param {number} [n=1] The number of elements to take.
		     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
		     * @returns {Array} Returns the slice of `array`.
		     * @example
		     *
		     * _.takeRight([1, 2, 3]);
		     * // => [3]
		     *
		     * _.takeRight([1, 2, 3], 2);
		     * // => [2, 3]
		     *
		     * _.takeRight([1, 2, 3], 5);
		     * // => [1, 2, 3]
		     *
		     * _.takeRight([1, 2, 3], 0);
		     * // => []
		     */
		    function takeRight(array, n, guard) {
		      var length = array == null ? 0 : array.length;
		      if (!length) {
		        return [];
		      }
		      n = (guard || n === undefined$1) ? 1 : toInteger(n);
		      n = length - n;
		      return baseSlice(array, n < 0 ? 0 : n, length);
		    }

		    /**
		     * Creates a slice of `array` with elements taken from the end. Elements are
		     * taken until `predicate` returns falsey. The predicate is invoked with
		     * three arguments: (value, index, array).
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category Array
		     * @param {Array} array The array to query.
		     * @param {Function} [predicate=_.identity] The function invoked per iteration.
		     * @returns {Array} Returns the slice of `array`.
		     * @example
		     *
		     * var users = [
		     *   { 'user': 'barney',  'active': true },
		     *   { 'user': 'fred',    'active': false },
		     *   { 'user': 'pebbles', 'active': false }
		     * ];
		     *
		     * _.takeRightWhile(users, function(o) { return !o.active; });
		     * // => objects for ['fred', 'pebbles']
		     *
		     * // The `_.matches` iteratee shorthand.
		     * _.takeRightWhile(users, { 'user': 'pebbles', 'active': false });
		     * // => objects for ['pebbles']
		     *
		     * // The `_.matchesProperty` iteratee shorthand.
		     * _.takeRightWhile(users, ['active', false]);
		     * // => objects for ['fred', 'pebbles']
		     *
		     * // The `_.property` iteratee shorthand.
		     * _.takeRightWhile(users, 'active');
		     * // => []
		     */
		    function takeRightWhile(array, predicate) {
		      return (array && array.length)
		        ? baseWhile(array, getIteratee(predicate, 3), false, true)
		        : [];
		    }

		    /**
		     * Creates a slice of `array` with elements taken from the beginning. Elements
		     * are taken until `predicate` returns falsey. The predicate is invoked with
		     * three arguments: (value, index, array).
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category Array
		     * @param {Array} array The array to query.
		     * @param {Function} [predicate=_.identity] The function invoked per iteration.
		     * @returns {Array} Returns the slice of `array`.
		     * @example
		     *
		     * var users = [
		     *   { 'user': 'barney',  'active': false },
		     *   { 'user': 'fred',    'active': false },
		     *   { 'user': 'pebbles', 'active': true }
		     * ];
		     *
		     * _.takeWhile(users, function(o) { return !o.active; });
		     * // => objects for ['barney', 'fred']
		     *
		     * // The `_.matches` iteratee shorthand.
		     * _.takeWhile(users, { 'user': 'barney', 'active': false });
		     * // => objects for ['barney']
		     *
		     * // The `_.matchesProperty` iteratee shorthand.
		     * _.takeWhile(users, ['active', false]);
		     * // => objects for ['barney', 'fred']
		     *
		     * // The `_.property` iteratee shorthand.
		     * _.takeWhile(users, 'active');
		     * // => []
		     */
		    function takeWhile(array, predicate) {
		      return (array && array.length)
		        ? baseWhile(array, getIteratee(predicate, 3))
		        : [];
		    }

		    /**
		     * Creates an array of unique values, in order, from all given arrays using
		     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
		     * for equality comparisons.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Array
		     * @param {...Array} [arrays] The arrays to inspect.
		     * @returns {Array} Returns the new array of combined values.
		     * @example
		     *
		     * _.union([2], [1, 2]);
		     * // => [2, 1]
		     */
		    var union = baseRest(function(arrays) {
		      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
		    });

		    /**
		     * This method is like `_.union` except that it accepts `iteratee` which is
		     * invoked for each element of each `arrays` to generate the criterion by
		     * which uniqueness is computed. Result values are chosen from the first
		     * array in which the value occurs. The iteratee is invoked with one argument:
		     * (value).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Array
		     * @param {...Array} [arrays] The arrays to inspect.
		     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
		     * @returns {Array} Returns the new array of combined values.
		     * @example
		     *
		     * _.unionBy([2.1], [1.2, 2.3], Math.floor);
		     * // => [2.1, 1.2]
		     *
		     * // The `_.property` iteratee shorthand.
		     * _.unionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
		     * // => [{ 'x': 1 }, { 'x': 2 }]
		     */
		    var unionBy = baseRest(function(arrays) {
		      var iteratee = last(arrays);
		      if (isArrayLikeObject(iteratee)) {
		        iteratee = undefined$1;
		      }
		      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee, 2));
		    });

		    /**
		     * This method is like `_.union` except that it accepts `comparator` which
		     * is invoked to compare elements of `arrays`. Result values are chosen from
		     * the first array in which the value occurs. The comparator is invoked
		     * with two arguments: (arrVal, othVal).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Array
		     * @param {...Array} [arrays] The arrays to inspect.
		     * @param {Function} [comparator] The comparator invoked per element.
		     * @returns {Array} Returns the new array of combined values.
		     * @example
		     *
		     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
		     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
		     *
		     * _.unionWith(objects, others, _.isEqual);
		     * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
		     */
		    var unionWith = baseRest(function(arrays) {
		      var comparator = last(arrays);
		      comparator = typeof comparator == 'function' ? comparator : undefined$1;
		      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined$1, comparator);
		    });

		    /**
		     * Creates a duplicate-free version of an array, using
		     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
		     * for equality comparisons, in which only the first occurrence of each element
		     * is kept. The order of result values is determined by the order they occur
		     * in the array.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Array
		     * @param {Array} array The array to inspect.
		     * @returns {Array} Returns the new duplicate free array.
		     * @example
		     *
		     * _.uniq([2, 1, 2]);
		     * // => [2, 1]
		     */
		    function uniq(array) {
		      return (array && array.length) ? baseUniq(array) : [];
		    }

		    /**
		     * This method is like `_.uniq` except that it accepts `iteratee` which is
		     * invoked for each element in `array` to generate the criterion by which
		     * uniqueness is computed. The order of result values is determined by the
		     * order they occur in the array. The iteratee is invoked with one argument:
		     * (value).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Array
		     * @param {Array} array The array to inspect.
		     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
		     * @returns {Array} Returns the new duplicate free array.
		     * @example
		     *
		     * _.uniqBy([2.1, 1.2, 2.3], Math.floor);
		     * // => [2.1, 1.2]
		     *
		     * // The `_.property` iteratee shorthand.
		     * _.uniqBy([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
		     * // => [{ 'x': 1 }, { 'x': 2 }]
		     */
		    function uniqBy(array, iteratee) {
		      return (array && array.length) ? baseUniq(array, getIteratee(iteratee, 2)) : [];
		    }

		    /**
		     * This method is like `_.uniq` except that it accepts `comparator` which
		     * is invoked to compare elements of `array`. The order of result values is
		     * determined by the order they occur in the array.The comparator is invoked
		     * with two arguments: (arrVal, othVal).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Array
		     * @param {Array} array The array to inspect.
		     * @param {Function} [comparator] The comparator invoked per element.
		     * @returns {Array} Returns the new duplicate free array.
		     * @example
		     *
		     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 2 }];
		     *
		     * _.uniqWith(objects, _.isEqual);
		     * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }]
		     */
		    function uniqWith(array, comparator) {
		      comparator = typeof comparator == 'function' ? comparator : undefined$1;
		      return (array && array.length) ? baseUniq(array, undefined$1, comparator) : [];
		    }

		    /**
		     * This method is like `_.zip` except that it accepts an array of grouped
		     * elements and creates an array regrouping the elements to their pre-zip
		     * configuration.
		     *
		     * @static
		     * @memberOf _
		     * @since 1.2.0
		     * @category Array
		     * @param {Array} array The array of grouped elements to process.
		     * @returns {Array} Returns the new array of regrouped elements.
		     * @example
		     *
		     * var zipped = _.zip(['a', 'b'], [1, 2], [true, false]);
		     * // => [['a', 1, true], ['b', 2, false]]
		     *
		     * _.unzip(zipped);
		     * // => [['a', 'b'], [1, 2], [true, false]]
		     */
		    function unzip(array) {
		      if (!(array && array.length)) {
		        return [];
		      }
		      var length = 0;
		      array = arrayFilter(array, function(group) {
		        if (isArrayLikeObject(group)) {
		          length = nativeMax(group.length, length);
		          return true;
		        }
		      });
		      return baseTimes(length, function(index) {
		        return arrayMap(array, baseProperty(index));
		      });
		    }

		    /**
		     * This method is like `_.unzip` except that it accepts `iteratee` to specify
		     * how regrouped values should be combined. The iteratee is invoked with the
		     * elements of each group: (...group).
		     *
		     * @static
		     * @memberOf _
		     * @since 3.8.0
		     * @category Array
		     * @param {Array} array The array of grouped elements to process.
		     * @param {Function} [iteratee=_.identity] The function to combine
		     *  regrouped values.
		     * @returns {Array} Returns the new array of regrouped elements.
		     * @example
		     *
		     * var zipped = _.zip([1, 2], [10, 20], [100, 200]);
		     * // => [[1, 10, 100], [2, 20, 200]]
		     *
		     * _.unzipWith(zipped, _.add);
		     * // => [3, 30, 300]
		     */
		    function unzipWith(array, iteratee) {
		      if (!(array && array.length)) {
		        return [];
		      }
		      var result = unzip(array);
		      if (iteratee == null) {
		        return result;
		      }
		      return arrayMap(result, function(group) {
		        return apply(iteratee, undefined$1, group);
		      });
		    }

		    /**
		     * Creates an array excluding all given values using
		     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
		     * for equality comparisons.
		     *
		     * **Note:** Unlike `_.pull`, this method returns a new array.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Array
		     * @param {Array} array The array to inspect.
		     * @param {...*} [values] The values to exclude.
		     * @returns {Array} Returns the new array of filtered values.
		     * @see _.difference, _.xor
		     * @example
		     *
		     * _.without([2, 1, 2, 3], 1, 2);
		     * // => [3]
		     */
		    var without = baseRest(function(array, values) {
		      return isArrayLikeObject(array)
		        ? baseDifference(array, values)
		        : [];
		    });

		    /**
		     * Creates an array of unique values that is the
		     * [symmetric difference](https://en.wikipedia.org/wiki/Symmetric_difference)
		     * of the given arrays. The order of result values is determined by the order
		     * they occur in the arrays.
		     *
		     * @static
		     * @memberOf _
		     * @since 2.4.0
		     * @category Array
		     * @param {...Array} [arrays] The arrays to inspect.
		     * @returns {Array} Returns the new array of filtered values.
		     * @see _.difference, _.without
		     * @example
		     *
		     * _.xor([2, 1], [2, 3]);
		     * // => [1, 3]
		     */
		    var xor = baseRest(function(arrays) {
		      return baseXor(arrayFilter(arrays, isArrayLikeObject));
		    });

		    /**
		     * This method is like `_.xor` except that it accepts `iteratee` which is
		     * invoked for each element of each `arrays` to generate the criterion by
		     * which by which they're compared. The order of result values is determined
		     * by the order they occur in the arrays. The iteratee is invoked with one
		     * argument: (value).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Array
		     * @param {...Array} [arrays] The arrays to inspect.
		     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
		     * @returns {Array} Returns the new array of filtered values.
		     * @example
		     *
		     * _.xorBy([2.1, 1.2], [2.3, 3.4], Math.floor);
		     * // => [1.2, 3.4]
		     *
		     * // The `_.property` iteratee shorthand.
		     * _.xorBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
		     * // => [{ 'x': 2 }]
		     */
		    var xorBy = baseRest(function(arrays) {
		      var iteratee = last(arrays);
		      if (isArrayLikeObject(iteratee)) {
		        iteratee = undefined$1;
		      }
		      return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee, 2));
		    });

		    /**
		     * This method is like `_.xor` except that it accepts `comparator` which is
		     * invoked to compare elements of `arrays`. The order of result values is
		     * determined by the order they occur in the arrays. The comparator is invoked
		     * with two arguments: (arrVal, othVal).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Array
		     * @param {...Array} [arrays] The arrays to inspect.
		     * @param {Function} [comparator] The comparator invoked per element.
		     * @returns {Array} Returns the new array of filtered values.
		     * @example
		     *
		     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
		     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
		     *
		     * _.xorWith(objects, others, _.isEqual);
		     * // => [{ 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
		     */
		    var xorWith = baseRest(function(arrays) {
		      var comparator = last(arrays);
		      comparator = typeof comparator == 'function' ? comparator : undefined$1;
		      return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined$1, comparator);
		    });

		    /**
		     * Creates an array of grouped elements, the first of which contains the
		     * first elements of the given arrays, the second of which contains the
		     * second elements of the given arrays, and so on.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Array
		     * @param {...Array} [arrays] The arrays to process.
		     * @returns {Array} Returns the new array of grouped elements.
		     * @example
		     *
		     * _.zip(['a', 'b'], [1, 2], [true, false]);
		     * // => [['a', 1, true], ['b', 2, false]]
		     */
		    var zip = baseRest(unzip);

		    /**
		     * This method is like `_.fromPairs` except that it accepts two arrays,
		     * one of property identifiers and one of corresponding values.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.4.0
		     * @category Array
		     * @param {Array} [props=[]] The property identifiers.
		     * @param {Array} [values=[]] The property values.
		     * @returns {Object} Returns the new object.
		     * @example
		     *
		     * _.zipObject(['a', 'b'], [1, 2]);
		     * // => { 'a': 1, 'b': 2 }
		     */
		    function zipObject(props, values) {
		      return baseZipObject(props || [], values || [], assignValue);
		    }

		    /**
		     * This method is like `_.zipObject` except that it supports property paths.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.1.0
		     * @category Array
		     * @param {Array} [props=[]] The property identifiers.
		     * @param {Array} [values=[]] The property values.
		     * @returns {Object} Returns the new object.
		     * @example
		     *
		     * _.zipObjectDeep(['a.b[0].c', 'a.b[1].d'], [1, 2]);
		     * // => { 'a': { 'b': [{ 'c': 1 }, { 'd': 2 }] } }
		     */
		    function zipObjectDeep(props, values) {
		      return baseZipObject(props || [], values || [], baseSet);
		    }

		    /**
		     * This method is like `_.zip` except that it accepts `iteratee` to specify
		     * how grouped values should be combined. The iteratee is invoked with the
		     * elements of each group: (...group).
		     *
		     * @static
		     * @memberOf _
		     * @since 3.8.0
		     * @category Array
		     * @param {...Array} [arrays] The arrays to process.
		     * @param {Function} [iteratee=_.identity] The function to combine
		     *  grouped values.
		     * @returns {Array} Returns the new array of grouped elements.
		     * @example
		     *
		     * _.zipWith([1, 2], [10, 20], [100, 200], function(a, b, c) {
		     *   return a + b + c;
		     * });
		     * // => [111, 222]
		     */
		    var zipWith = baseRest(function(arrays) {
		      var length = arrays.length,
		          iteratee = length > 1 ? arrays[length - 1] : undefined$1;

		      iteratee = typeof iteratee == 'function' ? (arrays.pop(), iteratee) : undefined$1;
		      return unzipWith(arrays, iteratee);
		    });

		    /*------------------------------------------------------------------------*/

		    /**
		     * Creates a `lodash` wrapper instance that wraps `value` with explicit method
		     * chain sequences enabled. The result of such sequences must be unwrapped
		     * with `_#value`.
		     *
		     * @static
		     * @memberOf _
		     * @since 1.3.0
		     * @category Seq
		     * @param {*} value The value to wrap.
		     * @returns {Object} Returns the new `lodash` wrapper instance.
		     * @example
		     *
		     * var users = [
		     *   { 'user': 'barney',  'age': 36 },
		     *   { 'user': 'fred',    'age': 40 },
		     *   { 'user': 'pebbles', 'age': 1 }
		     * ];
		     *
		     * var youngest = _
		     *   .chain(users)
		     *   .sortBy('age')
		     *   .map(function(o) {
		     *     return o.user + ' is ' + o.age;
		     *   })
		     *   .head()
		     *   .value();
		     * // => 'pebbles is 1'
		     */
		    function chain(value) {
		      var result = lodash(value);
		      result.__chain__ = true;
		      return result;
		    }

		    /**
		     * This method invokes `interceptor` and returns `value`. The interceptor
		     * is invoked with one argument; (value). The purpose of this method is to
		     * "tap into" a method chain sequence in order to modify intermediate results.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Seq
		     * @param {*} value The value to provide to `interceptor`.
		     * @param {Function} interceptor The function to invoke.
		     * @returns {*} Returns `value`.
		     * @example
		     *
		     * _([1, 2, 3])
		     *  .tap(function(array) {
		     *    // Mutate input array.
		     *    array.pop();
		     *  })
		     *  .reverse()
		     *  .value();
		     * // => [2, 1]
		     */
		    function tap(value, interceptor) {
		      interceptor(value);
		      return value;
		    }

		    /**
		     * This method is like `_.tap` except that it returns the result of `interceptor`.
		     * The purpose of this method is to "pass thru" values replacing intermediate
		     * results in a method chain sequence.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category Seq
		     * @param {*} value The value to provide to `interceptor`.
		     * @param {Function} interceptor The function to invoke.
		     * @returns {*} Returns the result of `interceptor`.
		     * @example
		     *
		     * _('  abc  ')
		     *  .chain()
		     *  .trim()
		     *  .thru(function(value) {
		     *    return [value];
		     *  })
		     *  .value();
		     * // => ['abc']
		     */
		    function thru(value, interceptor) {
		      return interceptor(value);
		    }

		    /**
		     * This method is the wrapper version of `_.at`.
		     *
		     * @name at
		     * @memberOf _
		     * @since 1.0.0
		     * @category Seq
		     * @param {...(string|string[])} [paths] The property paths to pick.
		     * @returns {Object} Returns the new `lodash` wrapper instance.
		     * @example
		     *
		     * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
		     *
		     * _(object).at(['a[0].b.c', 'a[1]']).value();
		     * // => [3, 4]
		     */
		    var wrapperAt = flatRest(function(paths) {
		      var length = paths.length,
		          start = length ? paths[0] : 0,
		          value = this.__wrapped__,
		          interceptor = function(object) { return baseAt(object, paths); };

		      if (length > 1 || this.__actions__.length ||
		          !(value instanceof LazyWrapper) || !isIndex(start)) {
		        return this.thru(interceptor);
		      }
		      value = value.slice(start, +start + (length ? 1 : 0));
		      value.__actions__.push({
		        'func': thru,
		        'args': [interceptor],
		        'thisArg': undefined$1
		      });
		      return new LodashWrapper(value, this.__chain__).thru(function(array) {
		        if (length && !array.length) {
		          array.push(undefined$1);
		        }
		        return array;
		      });
		    });

		    /**
		     * Creates a `lodash` wrapper instance with explicit method chain sequences enabled.
		     *
		     * @name chain
		     * @memberOf _
		     * @since 0.1.0
		     * @category Seq
		     * @returns {Object} Returns the new `lodash` wrapper instance.
		     * @example
		     *
		     * var users = [
		     *   { 'user': 'barney', 'age': 36 },
		     *   { 'user': 'fred',   'age': 40 }
		     * ];
		     *
		     * // A sequence without explicit chaining.
		     * _(users).head();
		     * // => { 'user': 'barney', 'age': 36 }
		     *
		     * // A sequence with explicit chaining.
		     * _(users)
		     *   .chain()
		     *   .head()
		     *   .pick('user')
		     *   .value();
		     * // => { 'user': 'barney' }
		     */
		    function wrapperChain() {
		      return chain(this);
		    }

		    /**
		     * Executes the chain sequence and returns the wrapped result.
		     *
		     * @name commit
		     * @memberOf _
		     * @since 3.2.0
		     * @category Seq
		     * @returns {Object} Returns the new `lodash` wrapper instance.
		     * @example
		     *
		     * var array = [1, 2];
		     * var wrapped = _(array).push(3);
		     *
		     * console.log(array);
		     * // => [1, 2]
		     *
		     * wrapped = wrapped.commit();
		     * console.log(array);
		     * // => [1, 2, 3]
		     *
		     * wrapped.last();
		     * // => 3
		     *
		     * console.log(array);
		     * // => [1, 2, 3]
		     */
		    function wrapperCommit() {
		      return new LodashWrapper(this.value(), this.__chain__);
		    }

		    /**
		     * Gets the next value on a wrapped object following the
		     * [iterator protocol](https://mdn.io/iteration_protocols#iterator).
		     *
		     * @name next
		     * @memberOf _
		     * @since 4.0.0
		     * @category Seq
		     * @returns {Object} Returns the next iterator value.
		     * @example
		     *
		     * var wrapped = _([1, 2]);
		     *
		     * wrapped.next();
		     * // => { 'done': false, 'value': 1 }
		     *
		     * wrapped.next();
		     * // => { 'done': false, 'value': 2 }
		     *
		     * wrapped.next();
		     * // => { 'done': true, 'value': undefined }
		     */
		    function wrapperNext() {
		      if (this.__values__ === undefined$1) {
		        this.__values__ = toArray(this.value());
		      }
		      var done = this.__index__ >= this.__values__.length,
		          value = done ? undefined$1 : this.__values__[this.__index__++];

		      return { 'done': done, 'value': value };
		    }

		    /**
		     * Enables the wrapper to be iterable.
		     *
		     * @name Symbol.iterator
		     * @memberOf _
		     * @since 4.0.0
		     * @category Seq
		     * @returns {Object} Returns the wrapper object.
		     * @example
		     *
		     * var wrapped = _([1, 2]);
		     *
		     * wrapped[Symbol.iterator]() === wrapped;
		     * // => true
		     *
		     * Array.from(wrapped);
		     * // => [1, 2]
		     */
		    function wrapperToIterator() {
		      return this;
		    }

		    /**
		     * Creates a clone of the chain sequence planting `value` as the wrapped value.
		     *
		     * @name plant
		     * @memberOf _
		     * @since 3.2.0
		     * @category Seq
		     * @param {*} value The value to plant.
		     * @returns {Object} Returns the new `lodash` wrapper instance.
		     * @example
		     *
		     * function square(n) {
		     *   return n * n;
		     * }
		     *
		     * var wrapped = _([1, 2]).map(square);
		     * var other = wrapped.plant([3, 4]);
		     *
		     * other.value();
		     * // => [9, 16]
		     *
		     * wrapped.value();
		     * // => [1, 4]
		     */
		    function wrapperPlant(value) {
		      var result,
		          parent = this;

		      while (parent instanceof baseLodash) {
		        var clone = wrapperClone(parent);
		        clone.__index__ = 0;
		        clone.__values__ = undefined$1;
		        if (result) {
		          previous.__wrapped__ = clone;
		        } else {
		          result = clone;
		        }
		        var previous = clone;
		        parent = parent.__wrapped__;
		      }
		      previous.__wrapped__ = value;
		      return result;
		    }

		    /**
		     * This method is the wrapper version of `_.reverse`.
		     *
		     * **Note:** This method mutates the wrapped array.
		     *
		     * @name reverse
		     * @memberOf _
		     * @since 0.1.0
		     * @category Seq
		     * @returns {Object} Returns the new `lodash` wrapper instance.
		     * @example
		     *
		     * var array = [1, 2, 3];
		     *
		     * _(array).reverse().value()
		     * // => [3, 2, 1]
		     *
		     * console.log(array);
		     * // => [3, 2, 1]
		     */
		    function wrapperReverse() {
		      var value = this.__wrapped__;
		      if (value instanceof LazyWrapper) {
		        var wrapped = value;
		        if (this.__actions__.length) {
		          wrapped = new LazyWrapper(this);
		        }
		        wrapped = wrapped.reverse();
		        wrapped.__actions__.push({
		          'func': thru,
		          'args': [reverse],
		          'thisArg': undefined$1
		        });
		        return new LodashWrapper(wrapped, this.__chain__);
		      }
		      return this.thru(reverse);
		    }

		    /**
		     * Executes the chain sequence to resolve the unwrapped value.
		     *
		     * @name value
		     * @memberOf _
		     * @since 0.1.0
		     * @alias toJSON, valueOf
		     * @category Seq
		     * @returns {*} Returns the resolved unwrapped value.
		     * @example
		     *
		     * _([1, 2, 3]).value();
		     * // => [1, 2, 3]
		     */
		    function wrapperValue() {
		      return baseWrapperValue(this.__wrapped__, this.__actions__);
		    }

		    /*------------------------------------------------------------------------*/

		    /**
		     * Creates an object composed of keys generated from the results of running
		     * each element of `collection` thru `iteratee`. The corresponding value of
		     * each key is the number of times the key was returned by `iteratee`. The
		     * iteratee is invoked with one argument: (value).
		     *
		     * @static
		     * @memberOf _
		     * @since 0.5.0
		     * @category Collection
		     * @param {Array|Object} collection The collection to iterate over.
		     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
		     * @returns {Object} Returns the composed aggregate object.
		     * @example
		     *
		     * _.countBy([6.1, 4.2, 6.3], Math.floor);
		     * // => { '4': 1, '6': 2 }
		     *
		     * // The `_.property` iteratee shorthand.
		     * _.countBy(['one', 'two', 'three'], 'length');
		     * // => { '3': 2, '5': 1 }
		     */
		    var countBy = createAggregator(function(result, value, key) {
		      if (hasOwnProperty.call(result, key)) {
		        ++result[key];
		      } else {
		        baseAssignValue(result, key, 1);
		      }
		    });

		    /**
		     * Checks if `predicate` returns truthy for **all** elements of `collection`.
		     * Iteration is stopped once `predicate` returns falsey. The predicate is
		     * invoked with three arguments: (value, index|key, collection).
		     *
		     * **Note:** This method returns `true` for
		     * [empty collections](https://en.wikipedia.org/wiki/Empty_set) because
		     * [everything is true](https://en.wikipedia.org/wiki/Vacuous_truth) of
		     * elements of empty collections.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Collection
		     * @param {Array|Object} collection The collection to iterate over.
		     * @param {Function} [predicate=_.identity] The function invoked per iteration.
		     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
		     * @returns {boolean} Returns `true` if all elements pass the predicate check,
		     *  else `false`.
		     * @example
		     *
		     * _.every([true, 1, null, 'yes'], Boolean);
		     * // => false
		     *
		     * var users = [
		     *   { 'user': 'barney', 'age': 36, 'active': false },
		     *   { 'user': 'fred',   'age': 40, 'active': false }
		     * ];
		     *
		     * // The `_.matches` iteratee shorthand.
		     * _.every(users, { 'user': 'barney', 'active': false });
		     * // => false
		     *
		     * // The `_.matchesProperty` iteratee shorthand.
		     * _.every(users, ['active', false]);
		     * // => true
		     *
		     * // The `_.property` iteratee shorthand.
		     * _.every(users, 'active');
		     * // => false
		     */
		    function every(collection, predicate, guard) {
		      var func = isArray(collection) ? arrayEvery : baseEvery;
		      if (guard && isIterateeCall(collection, predicate, guard)) {
		        predicate = undefined$1;
		      }
		      return func(collection, getIteratee(predicate, 3));
		    }

		    /**
		     * Iterates over elements of `collection`, returning an array of all elements
		     * `predicate` returns truthy for. The predicate is invoked with three
		     * arguments: (value, index|key, collection).
		     *
		     * **Note:** Unlike `_.remove`, this method returns a new array.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Collection
		     * @param {Array|Object} collection The collection to iterate over.
		     * @param {Function} [predicate=_.identity] The function invoked per iteration.
		     * @returns {Array} Returns the new filtered array.
		     * @see _.reject
		     * @example
		     *
		     * var users = [
		     *   { 'user': 'barney', 'age': 36, 'active': true },
		     *   { 'user': 'fred',   'age': 40, 'active': false }
		     * ];
		     *
		     * _.filter(users, function(o) { return !o.active; });
		     * // => objects for ['fred']
		     *
		     * // The `_.matches` iteratee shorthand.
		     * _.filter(users, { 'age': 36, 'active': true });
		     * // => objects for ['barney']
		     *
		     * // The `_.matchesProperty` iteratee shorthand.
		     * _.filter(users, ['active', false]);
		     * // => objects for ['fred']
		     *
		     * // The `_.property` iteratee shorthand.
		     * _.filter(users, 'active');
		     * // => objects for ['barney']
		     *
		     * // Combining several predicates using `_.overEvery` or `_.overSome`.
		     * _.filter(users, _.overSome([{ 'age': 36 }, ['age', 40]]));
		     * // => objects for ['fred', 'barney']
		     */
		    function filter(collection, predicate) {
		      var func = isArray(collection) ? arrayFilter : baseFilter;
		      return func(collection, getIteratee(predicate, 3));
		    }

		    /**
		     * Iterates over elements of `collection`, returning the first element
		     * `predicate` returns truthy for. The predicate is invoked with three
		     * arguments: (value, index|key, collection).
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Collection
		     * @param {Array|Object} collection The collection to inspect.
		     * @param {Function} [predicate=_.identity] The function invoked per iteration.
		     * @param {number} [fromIndex=0] The index to search from.
		     * @returns {*} Returns the matched element, else `undefined`.
		     * @example
		     *
		     * var users = [
		     *   { 'user': 'barney',  'age': 36, 'active': true },
		     *   { 'user': 'fred',    'age': 40, 'active': false },
		     *   { 'user': 'pebbles', 'age': 1,  'active': true }
		     * ];
		     *
		     * _.find(users, function(o) { return o.age < 40; });
		     * // => object for 'barney'
		     *
		     * // The `_.matches` iteratee shorthand.
		     * _.find(users, { 'age': 1, 'active': true });
		     * // => object for 'pebbles'
		     *
		     * // The `_.matchesProperty` iteratee shorthand.
		     * _.find(users, ['active', false]);
		     * // => object for 'fred'
		     *
		     * // The `_.property` iteratee shorthand.
		     * _.find(users, 'active');
		     * // => object for 'barney'
		     */
		    var find = createFind(findIndex);

		    /**
		     * This method is like `_.find` except that it iterates over elements of
		     * `collection` from right to left.
		     *
		     * @static
		     * @memberOf _
		     * @since 2.0.0
		     * @category Collection
		     * @param {Array|Object} collection The collection to inspect.
		     * @param {Function} [predicate=_.identity] The function invoked per iteration.
		     * @param {number} [fromIndex=collection.length-1] The index to search from.
		     * @returns {*} Returns the matched element, else `undefined`.
		     * @example
		     *
		     * _.findLast([1, 2, 3, 4], function(n) {
		     *   return n % 2 == 1;
		     * });
		     * // => 3
		     */
		    var findLast = createFind(findLastIndex);

		    /**
		     * Creates a flattened array of values by running each element in `collection`
		     * thru `iteratee` and flattening the mapped results. The iteratee is invoked
		     * with three arguments: (value, index|key, collection).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Collection
		     * @param {Array|Object} collection The collection to iterate over.
		     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
		     * @returns {Array} Returns the new flattened array.
		     * @example
		     *
		     * function duplicate(n) {
		     *   return [n, n];
		     * }
		     *
		     * _.flatMap([1, 2], duplicate);
		     * // => [1, 1, 2, 2]
		     */
		    function flatMap(collection, iteratee) {
		      return baseFlatten(map(collection, iteratee), 1);
		    }

		    /**
		     * This method is like `_.flatMap` except that it recursively flattens the
		     * mapped results.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.7.0
		     * @category Collection
		     * @param {Array|Object} collection The collection to iterate over.
		     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
		     * @returns {Array} Returns the new flattened array.
		     * @example
		     *
		     * function duplicate(n) {
		     *   return [[[n, n]]];
		     * }
		     *
		     * _.flatMapDeep([1, 2], duplicate);
		     * // => [1, 1, 2, 2]
		     */
		    function flatMapDeep(collection, iteratee) {
		      return baseFlatten(map(collection, iteratee), INFINITY);
		    }

		    /**
		     * This method is like `_.flatMap` except that it recursively flattens the
		     * mapped results up to `depth` times.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.7.0
		     * @category Collection
		     * @param {Array|Object} collection The collection to iterate over.
		     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
		     * @param {number} [depth=1] The maximum recursion depth.
		     * @returns {Array} Returns the new flattened array.
		     * @example
		     *
		     * function duplicate(n) {
		     *   return [[[n, n]]];
		     * }
		     *
		     * _.flatMapDepth([1, 2], duplicate, 2);
		     * // => [[1, 1], [2, 2]]
		     */
		    function flatMapDepth(collection, iteratee, depth) {
		      depth = depth === undefined$1 ? 1 : toInteger(depth);
		      return baseFlatten(map(collection, iteratee), depth);
		    }

		    /**
		     * Iterates over elements of `collection` and invokes `iteratee` for each element.
		     * The iteratee is invoked with three arguments: (value, index|key, collection).
		     * Iteratee functions may exit iteration early by explicitly returning `false`.
		     *
		     * **Note:** As with other "Collections" methods, objects with a "length"
		     * property are iterated like arrays. To avoid this behavior use `_.forIn`
		     * or `_.forOwn` for object iteration.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @alias each
		     * @category Collection
		     * @param {Array|Object} collection The collection to iterate over.
		     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
		     * @returns {Array|Object} Returns `collection`.
		     * @see _.forEachRight
		     * @example
		     *
		     * _.forEach([1, 2], function(value) {
		     *   console.log(value);
		     * });
		     * // => Logs `1` then `2`.
		     *
		     * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {
		     *   console.log(key);
		     * });
		     * // => Logs 'a' then 'b' (iteration order is not guaranteed).
		     */
		    function forEach(collection, iteratee) {
		      var func = isArray(collection) ? arrayEach : baseEach;
		      return func(collection, getIteratee(iteratee, 3));
		    }

		    /**
		     * This method is like `_.forEach` except that it iterates over elements of
		     * `collection` from right to left.
		     *
		     * @static
		     * @memberOf _
		     * @since 2.0.0
		     * @alias eachRight
		     * @category Collection
		     * @param {Array|Object} collection The collection to iterate over.
		     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
		     * @returns {Array|Object} Returns `collection`.
		     * @see _.forEach
		     * @example
		     *
		     * _.forEachRight([1, 2], function(value) {
		     *   console.log(value);
		     * });
		     * // => Logs `2` then `1`.
		     */
		    function forEachRight(collection, iteratee) {
		      var func = isArray(collection) ? arrayEachRight : baseEachRight;
		      return func(collection, getIteratee(iteratee, 3));
		    }

		    /**
		     * Creates an object composed of keys generated from the results of running
		     * each element of `collection` thru `iteratee`. The order of grouped values
		     * is determined by the order they occur in `collection`. The corresponding
		     * value of each key is an array of elements responsible for generating the
		     * key. The iteratee is invoked with one argument: (value).
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Collection
		     * @param {Array|Object} collection The collection to iterate over.
		     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
		     * @returns {Object} Returns the composed aggregate object.
		     * @example
		     *
		     * _.groupBy([6.1, 4.2, 6.3], Math.floor);
		     * // => { '4': [4.2], '6': [6.1, 6.3] }
		     *
		     * // The `_.property` iteratee shorthand.
		     * _.groupBy(['one', 'two', 'three'], 'length');
		     * // => { '3': ['one', 'two'], '5': ['three'] }
		     */
		    var groupBy = createAggregator(function(result, value, key) {
		      if (hasOwnProperty.call(result, key)) {
		        result[key].push(value);
		      } else {
		        baseAssignValue(result, key, [value]);
		      }
		    });

		    /**
		     * Checks if `value` is in `collection`. If `collection` is a string, it's
		     * checked for a substring of `value`, otherwise
		     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
		     * is used for equality comparisons. If `fromIndex` is negative, it's used as
		     * the offset from the end of `collection`.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Collection
		     * @param {Array|Object|string} collection The collection to inspect.
		     * @param {*} value The value to search for.
		     * @param {number} [fromIndex=0] The index to search from.
		     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
		     * @returns {boolean} Returns `true` if `value` is found, else `false`.
		     * @example
		     *
		     * _.includes([1, 2, 3], 1);
		     * // => true
		     *
		     * _.includes([1, 2, 3], 1, 2);
		     * // => false
		     *
		     * _.includes({ 'a': 1, 'b': 2 }, 1);
		     * // => true
		     *
		     * _.includes('abcd', 'bc');
		     * // => true
		     */
		    function includes(collection, value, fromIndex, guard) {
		      collection = isArrayLike(collection) ? collection : values(collection);
		      fromIndex = (fromIndex && !guard) ? toInteger(fromIndex) : 0;

		      var length = collection.length;
		      if (fromIndex < 0) {
		        fromIndex = nativeMax(length + fromIndex, 0);
		      }
		      return isString(collection)
		        ? (fromIndex <= length && collection.indexOf(value, fromIndex) > -1)
		        : (!!length && baseIndexOf(collection, value, fromIndex) > -1);
		    }

		    /**
		     * Invokes the method at `path` of each element in `collection`, returning
		     * an array of the results of each invoked method. Any additional arguments
		     * are provided to each invoked method. If `path` is a function, it's invoked
		     * for, and `this` bound to, each element in `collection`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Collection
		     * @param {Array|Object} collection The collection to iterate over.
		     * @param {Array|Function|string} path The path of the method to invoke or
		     *  the function invoked per iteration.
		     * @param {...*} [args] The arguments to invoke each method with.
		     * @returns {Array} Returns the array of results.
		     * @example
		     *
		     * _.invokeMap([[5, 1, 7], [3, 2, 1]], 'sort');
		     * // => [[1, 5, 7], [1, 2, 3]]
		     *
		     * _.invokeMap([123, 456], String.prototype.split, '');
		     * // => [['1', '2', '3'], ['4', '5', '6']]
		     */
		    var invokeMap = baseRest(function(collection, path, args) {
		      var index = -1,
		          isFunc = typeof path == 'function',
		          result = isArrayLike(collection) ? Array(collection.length) : [];

		      baseEach(collection, function(value) {
		        result[++index] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);
		      });
		      return result;
		    });

		    /**
		     * Creates an object composed of keys generated from the results of running
		     * each element of `collection` thru `iteratee`. The corresponding value of
		     * each key is the last element responsible for generating the key. The
		     * iteratee is invoked with one argument: (value).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Collection
		     * @param {Array|Object} collection The collection to iterate over.
		     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
		     * @returns {Object} Returns the composed aggregate object.
		     * @example
		     *
		     * var array = [
		     *   { 'dir': 'left', 'code': 97 },
		     *   { 'dir': 'right', 'code': 100 }
		     * ];
		     *
		     * _.keyBy(array, function(o) {
		     *   return String.fromCharCode(o.code);
		     * });
		     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
		     *
		     * _.keyBy(array, 'dir');
		     * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }
		     */
		    var keyBy = createAggregator(function(result, value, key) {
		      baseAssignValue(result, key, value);
		    });

		    /**
		     * Creates an array of values by running each element in `collection` thru
		     * `iteratee`. The iteratee is invoked with three arguments:
		     * (value, index|key, collection).
		     *
		     * Many lodash methods are guarded to work as iteratees for methods like
		     * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
		     *
		     * The guarded methods are:
		     * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,
		     * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,
		     * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,
		     * `template`, `trim`, `trimEnd`, `trimStart`, and `words`
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Collection
		     * @param {Array|Object} collection The collection to iterate over.
		     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
		     * @returns {Array} Returns the new mapped array.
		     * @example
		     *
		     * function square(n) {
		     *   return n * n;
		     * }
		     *
		     * _.map([4, 8], square);
		     * // => [16, 64]
		     *
		     * _.map({ 'a': 4, 'b': 8 }, square);
		     * // => [16, 64] (iteration order is not guaranteed)
		     *
		     * var users = [
		     *   { 'user': 'barney' },
		     *   { 'user': 'fred' }
		     * ];
		     *
		     * // The `_.property` iteratee shorthand.
		     * _.map(users, 'user');
		     * // => ['barney', 'fred']
		     */
		    function map(collection, iteratee) {
		      var func = isArray(collection) ? arrayMap : baseMap;
		      return func(collection, getIteratee(iteratee, 3));
		    }

		    /**
		     * This method is like `_.sortBy` except that it allows specifying the sort
		     * orders of the iteratees to sort by. If `orders` is unspecified, all values
		     * are sorted in ascending order. Otherwise, specify an order of "desc" for
		     * descending or "asc" for ascending sort order of corresponding values.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Collection
		     * @param {Array|Object} collection The collection to iterate over.
		     * @param {Array[]|Function[]|Object[]|string[]} [iteratees=[_.identity]]
		     *  The iteratees to sort by.
		     * @param {string[]} [orders] The sort orders of `iteratees`.
		     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
		     * @returns {Array} Returns the new sorted array.
		     * @example
		     *
		     * var users = [
		     *   { 'user': 'fred',   'age': 48 },
		     *   { 'user': 'barney', 'age': 34 },
		     *   { 'user': 'fred',   'age': 40 },
		     *   { 'user': 'barney', 'age': 36 }
		     * ];
		     *
		     * // Sort by `user` in ascending order and by `age` in descending order.
		     * _.orderBy(users, ['user', 'age'], ['asc', 'desc']);
		     * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]
		     */
		    function orderBy(collection, iteratees, orders, guard) {
		      if (collection == null) {
		        return [];
		      }
		      if (!isArray(iteratees)) {
		        iteratees = iteratees == null ? [] : [iteratees];
		      }
		      orders = guard ? undefined$1 : orders;
		      if (!isArray(orders)) {
		        orders = orders == null ? [] : [orders];
		      }
		      return baseOrderBy(collection, iteratees, orders);
		    }

		    /**
		     * Creates an array of elements split into two groups, the first of which
		     * contains elements `predicate` returns truthy for, the second of which
		     * contains elements `predicate` returns falsey for. The predicate is
		     * invoked with one argument: (value).
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category Collection
		     * @param {Array|Object} collection The collection to iterate over.
		     * @param {Function} [predicate=_.identity] The function invoked per iteration.
		     * @returns {Array} Returns the array of grouped elements.
		     * @example
		     *
		     * var users = [
		     *   { 'user': 'barney',  'age': 36, 'active': false },
		     *   { 'user': 'fred',    'age': 40, 'active': true },
		     *   { 'user': 'pebbles', 'age': 1,  'active': false }
		     * ];
		     *
		     * _.partition(users, function(o) { return o.active; });
		     * // => objects for [['fred'], ['barney', 'pebbles']]
		     *
		     * // The `_.matches` iteratee shorthand.
		     * _.partition(users, { 'age': 1, 'active': false });
		     * // => objects for [['pebbles'], ['barney', 'fred']]
		     *
		     * // The `_.matchesProperty` iteratee shorthand.
		     * _.partition(users, ['active', false]);
		     * // => objects for [['barney', 'pebbles'], ['fred']]
		     *
		     * // The `_.property` iteratee shorthand.
		     * _.partition(users, 'active');
		     * // => objects for [['fred'], ['barney', 'pebbles']]
		     */
		    var partition = createAggregator(function(result, value, key) {
		      result[key ? 0 : 1].push(value);
		    }, function() { return [[], []]; });

		    /**
		     * Reduces `collection` to a value which is the accumulated result of running
		     * each element in `collection` thru `iteratee`, where each successive
		     * invocation is supplied the return value of the previous. If `accumulator`
		     * is not given, the first element of `collection` is used as the initial
		     * value. The iteratee is invoked with four arguments:
		     * (accumulator, value, index|key, collection).
		     *
		     * Many lodash methods are guarded to work as iteratees for methods like
		     * `_.reduce`, `_.reduceRight`, and `_.transform`.
		     *
		     * The guarded methods are:
		     * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `orderBy`,
		     * and `sortBy`
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Collection
		     * @param {Array|Object} collection The collection to iterate over.
		     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
		     * @param {*} [accumulator] The initial value.
		     * @returns {*} Returns the accumulated value.
		     * @see _.reduceRight
		     * @example
		     *
		     * _.reduce([1, 2], function(sum, n) {
		     *   return sum + n;
		     * }, 0);
		     * // => 3
		     *
		     * _.reduce({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
		     *   (result[value] || (result[value] = [])).push(key);
		     *   return result;
		     * }, {});
		     * // => { '1': ['a', 'c'], '2': ['b'] } (iteration order is not guaranteed)
		     */
		    function reduce(collection, iteratee, accumulator) {
		      var func = isArray(collection) ? arrayReduce : baseReduce,
		          initAccum = arguments.length < 3;

		      return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEach);
		    }

		    /**
		     * This method is like `_.reduce` except that it iterates over elements of
		     * `collection` from right to left.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Collection
		     * @param {Array|Object} collection The collection to iterate over.
		     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
		     * @param {*} [accumulator] The initial value.
		     * @returns {*} Returns the accumulated value.
		     * @see _.reduce
		     * @example
		     *
		     * var array = [[0, 1], [2, 3], [4, 5]];
		     *
		     * _.reduceRight(array, function(flattened, other) {
		     *   return flattened.concat(other);
		     * }, []);
		     * // => [4, 5, 2, 3, 0, 1]
		     */
		    function reduceRight(collection, iteratee, accumulator) {
		      var func = isArray(collection) ? arrayReduceRight : baseReduce,
		          initAccum = arguments.length < 3;

		      return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEachRight);
		    }

		    /**
		     * The opposite of `_.filter`; this method returns the elements of `collection`
		     * that `predicate` does **not** return truthy for.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Collection
		     * @param {Array|Object} collection The collection to iterate over.
		     * @param {Function} [predicate=_.identity] The function invoked per iteration.
		     * @returns {Array} Returns the new filtered array.
		     * @see _.filter
		     * @example
		     *
		     * var users = [
		     *   { 'user': 'barney', 'age': 36, 'active': false },
		     *   { 'user': 'fred',   'age': 40, 'active': true }
		     * ];
		     *
		     * _.reject(users, function(o) { return !o.active; });
		     * // => objects for ['fred']
		     *
		     * // The `_.matches` iteratee shorthand.
		     * _.reject(users, { 'age': 40, 'active': true });
		     * // => objects for ['barney']
		     *
		     * // The `_.matchesProperty` iteratee shorthand.
		     * _.reject(users, ['active', false]);
		     * // => objects for ['fred']
		     *
		     * // The `_.property` iteratee shorthand.
		     * _.reject(users, 'active');
		     * // => objects for ['barney']
		     */
		    function reject(collection, predicate) {
		      var func = isArray(collection) ? arrayFilter : baseFilter;
		      return func(collection, negate(getIteratee(predicate, 3)));
		    }

		    /**
		     * Gets a random element from `collection`.
		     *
		     * @static
		     * @memberOf _
		     * @since 2.0.0
		     * @category Collection
		     * @param {Array|Object} collection The collection to sample.
		     * @returns {*} Returns the random element.
		     * @example
		     *
		     * _.sample([1, 2, 3, 4]);
		     * // => 2
		     */
		    function sample(collection) {
		      var func = isArray(collection) ? arraySample : baseSample;
		      return func(collection);
		    }

		    /**
		     * Gets `n` random elements at unique keys from `collection` up to the
		     * size of `collection`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Collection
		     * @param {Array|Object} collection The collection to sample.
		     * @param {number} [n=1] The number of elements to sample.
		     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
		     * @returns {Array} Returns the random elements.
		     * @example
		     *
		     * _.sampleSize([1, 2, 3], 2);
		     * // => [3, 1]
		     *
		     * _.sampleSize([1, 2, 3], 4);
		     * // => [2, 3, 1]
		     */
		    function sampleSize(collection, n, guard) {
		      if ((guard ? isIterateeCall(collection, n, guard) : n === undefined$1)) {
		        n = 1;
		      } else {
		        n = toInteger(n);
		      }
		      var func = isArray(collection) ? arraySampleSize : baseSampleSize;
		      return func(collection, n);
		    }

		    /**
		     * Creates an array of shuffled values, using a version of the
		     * [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle).
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Collection
		     * @param {Array|Object} collection The collection to shuffle.
		     * @returns {Array} Returns the new shuffled array.
		     * @example
		     *
		     * _.shuffle([1, 2, 3, 4]);
		     * // => [4, 1, 3, 2]
		     */
		    function shuffle(collection) {
		      var func = isArray(collection) ? arrayShuffle : baseShuffle;
		      return func(collection);
		    }

		    /**
		     * Gets the size of `collection` by returning its length for array-like
		     * values or the number of own enumerable string keyed properties for objects.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Collection
		     * @param {Array|Object|string} collection The collection to inspect.
		     * @returns {number} Returns the collection size.
		     * @example
		     *
		     * _.size([1, 2, 3]);
		     * // => 3
		     *
		     * _.size({ 'a': 1, 'b': 2 });
		     * // => 2
		     *
		     * _.size('pebbles');
		     * // => 7
		     */
		    function size(collection) {
		      if (collection == null) {
		        return 0;
		      }
		      if (isArrayLike(collection)) {
		        return isString(collection) ? stringSize(collection) : collection.length;
		      }
		      var tag = getTag(collection);
		      if (tag == mapTag || tag == setTag) {
		        return collection.size;
		      }
		      return baseKeys(collection).length;
		    }

		    /**
		     * Checks if `predicate` returns truthy for **any** element of `collection`.
		     * Iteration is stopped once `predicate` returns truthy. The predicate is
		     * invoked with three arguments: (value, index|key, collection).
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Collection
		     * @param {Array|Object} collection The collection to iterate over.
		     * @param {Function} [predicate=_.identity] The function invoked per iteration.
		     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
		     * @returns {boolean} Returns `true` if any element passes the predicate check,
		     *  else `false`.
		     * @example
		     *
		     * _.some([null, 0, 'yes', false], Boolean);
		     * // => true
		     *
		     * var users = [
		     *   { 'user': 'barney', 'active': true },
		     *   { 'user': 'fred',   'active': false }
		     * ];
		     *
		     * // The `_.matches` iteratee shorthand.
		     * _.some(users, { 'user': 'barney', 'active': false });
		     * // => false
		     *
		     * // The `_.matchesProperty` iteratee shorthand.
		     * _.some(users, ['active', false]);
		     * // => true
		     *
		     * // The `_.property` iteratee shorthand.
		     * _.some(users, 'active');
		     * // => true
		     */
		    function some(collection, predicate, guard) {
		      var func = isArray(collection) ? arraySome : baseSome;
		      if (guard && isIterateeCall(collection, predicate, guard)) {
		        predicate = undefined$1;
		      }
		      return func(collection, getIteratee(predicate, 3));
		    }

		    /**
		     * Creates an array of elements, sorted in ascending order by the results of
		     * running each element in a collection thru each iteratee. This method
		     * performs a stable sort, that is, it preserves the original sort order of
		     * equal elements. The iteratees are invoked with one argument: (value).
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Collection
		     * @param {Array|Object} collection The collection to iterate over.
		     * @param {...(Function|Function[])} [iteratees=[_.identity]]
		     *  The iteratees to sort by.
		     * @returns {Array} Returns the new sorted array.
		     * @example
		     *
		     * var users = [
		     *   { 'user': 'fred',   'age': 48 },
		     *   { 'user': 'barney', 'age': 36 },
		     *   { 'user': 'fred',   'age': 30 },
		     *   { 'user': 'barney', 'age': 34 }
		     * ];
		     *
		     * _.sortBy(users, [function(o) { return o.user; }]);
		     * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 30]]
		     *
		     * _.sortBy(users, ['user', 'age']);
		     * // => objects for [['barney', 34], ['barney', 36], ['fred', 30], ['fred', 48]]
		     */
		    var sortBy = baseRest(function(collection, iteratees) {
		      if (collection == null) {
		        return [];
		      }
		      var length = iteratees.length;
		      if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
		        iteratees = [];
		      } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
		        iteratees = [iteratees[0]];
		      }
		      return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
		    });

		    /*------------------------------------------------------------------------*/

		    /**
		     * Gets the timestamp of the number of milliseconds that have elapsed since
		     * the Unix epoch (1 January 1970 00:00:00 UTC).
		     *
		     * @static
		     * @memberOf _
		     * @since 2.4.0
		     * @category Date
		     * @returns {number} Returns the timestamp.
		     * @example
		     *
		     * _.defer(function(stamp) {
		     *   console.log(_.now() - stamp);
		     * }, _.now());
		     * // => Logs the number of milliseconds it took for the deferred invocation.
		     */
		    var now = ctxNow || function() {
		      return root.Date.now();
		    };

		    /*------------------------------------------------------------------------*/

		    /**
		     * The opposite of `_.before`; this method creates a function that invokes
		     * `func` once it's called `n` or more times.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Function
		     * @param {number} n The number of calls before `func` is invoked.
		     * @param {Function} func The function to restrict.
		     * @returns {Function} Returns the new restricted function.
		     * @example
		     *
		     * var saves = ['profile', 'settings'];
		     *
		     * var done = _.after(saves.length, function() {
		     *   console.log('done saving!');
		     * });
		     *
		     * _.forEach(saves, function(type) {
		     *   asyncSave({ 'type': type, 'complete': done });
		     * });
		     * // => Logs 'done saving!' after the two async saves have completed.
		     */
		    function after(n, func) {
		      if (typeof func != 'function') {
		        throw new TypeError(FUNC_ERROR_TEXT);
		      }
		      n = toInteger(n);
		      return function() {
		        if (--n < 1) {
		          return func.apply(this, arguments);
		        }
		      };
		    }

		    /**
		     * Creates a function that invokes `func`, with up to `n` arguments,
		     * ignoring any additional arguments.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category Function
		     * @param {Function} func The function to cap arguments for.
		     * @param {number} [n=func.length] The arity cap.
		     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
		     * @returns {Function} Returns the new capped function.
		     * @example
		     *
		     * _.map(['6', '8', '10'], _.ary(parseInt, 1));
		     * // => [6, 8, 10]
		     */
		    function ary(func, n, guard) {
		      n = guard ? undefined$1 : n;
		      n = (func && n == null) ? func.length : n;
		      return createWrap(func, WRAP_ARY_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, n);
		    }

		    /**
		     * Creates a function that invokes `func`, with the `this` binding and arguments
		     * of the created function, while it's called less than `n` times. Subsequent
		     * calls to the created function return the result of the last `func` invocation.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category Function
		     * @param {number} n The number of calls at which `func` is no longer invoked.
		     * @param {Function} func The function to restrict.
		     * @returns {Function} Returns the new restricted function.
		     * @example
		     *
		     * jQuery(element).on('click', _.before(5, addContactToList));
		     * // => Allows adding up to 4 contacts to the list.
		     */
		    function before(n, func) {
		      var result;
		      if (typeof func != 'function') {
		        throw new TypeError(FUNC_ERROR_TEXT);
		      }
		      n = toInteger(n);
		      return function() {
		        if (--n > 0) {
		          result = func.apply(this, arguments);
		        }
		        if (n <= 1) {
		          func = undefined$1;
		        }
		        return result;
		      };
		    }

		    /**
		     * Creates a function that invokes `func` with the `this` binding of `thisArg`
		     * and `partials` prepended to the arguments it receives.
		     *
		     * The `_.bind.placeholder` value, which defaults to `_` in monolithic builds,
		     * may be used as a placeholder for partially applied arguments.
		     *
		     * **Note:** Unlike native `Function#bind`, this method doesn't set the "length"
		     * property of bound functions.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Function
		     * @param {Function} func The function to bind.
		     * @param {*} thisArg The `this` binding of `func`.
		     * @param {...*} [partials] The arguments to be partially applied.
		     * @returns {Function} Returns the new bound function.
		     * @example
		     *
		     * function greet(greeting, punctuation) {
		     *   return greeting + ' ' + this.user + punctuation;
		     * }
		     *
		     * var object = { 'user': 'fred' };
		     *
		     * var bound = _.bind(greet, object, 'hi');
		     * bound('!');
		     * // => 'hi fred!'
		     *
		     * // Bound with placeholders.
		     * var bound = _.bind(greet, object, _, '!');
		     * bound('hi');
		     * // => 'hi fred!'
		     */
		    var bind = baseRest(function(func, thisArg, partials) {
		      var bitmask = WRAP_BIND_FLAG;
		      if (partials.length) {
		        var holders = replaceHolders(partials, getHolder(bind));
		        bitmask |= WRAP_PARTIAL_FLAG;
		      }
		      return createWrap(func, bitmask, thisArg, partials, holders);
		    });

		    /**
		     * Creates a function that invokes the method at `object[key]` with `partials`
		     * prepended to the arguments it receives.
		     *
		     * This method differs from `_.bind` by allowing bound functions to reference
		     * methods that may be redefined or don't yet exist. See
		     * [Peter Michaux's article](http://peter.michaux.ca/articles/lazy-function-definition-pattern)
		     * for more details.
		     *
		     * The `_.bindKey.placeholder` value, which defaults to `_` in monolithic
		     * builds, may be used as a placeholder for partially applied arguments.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.10.0
		     * @category Function
		     * @param {Object} object The object to invoke the method on.
		     * @param {string} key The key of the method.
		     * @param {...*} [partials] The arguments to be partially applied.
		     * @returns {Function} Returns the new bound function.
		     * @example
		     *
		     * var object = {
		     *   'user': 'fred',
		     *   'greet': function(greeting, punctuation) {
		     *     return greeting + ' ' + this.user + punctuation;
		     *   }
		     * };
		     *
		     * var bound = _.bindKey(object, 'greet', 'hi');
		     * bound('!');
		     * // => 'hi fred!'
		     *
		     * object.greet = function(greeting, punctuation) {
		     *   return greeting + 'ya ' + this.user + punctuation;
		     * };
		     *
		     * bound('!');
		     * // => 'hiya fred!'
		     *
		     * // Bound with placeholders.
		     * var bound = _.bindKey(object, 'greet', _, '!');
		     * bound('hi');
		     * // => 'hiya fred!'
		     */
		    var bindKey = baseRest(function(object, key, partials) {
		      var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
		      if (partials.length) {
		        var holders = replaceHolders(partials, getHolder(bindKey));
		        bitmask |= WRAP_PARTIAL_FLAG;
		      }
		      return createWrap(key, bitmask, object, partials, holders);
		    });

		    /**
		     * Creates a function that accepts arguments of `func` and either invokes
		     * `func` returning its result, if at least `arity` number of arguments have
		     * been provided, or returns a function that accepts the remaining `func`
		     * arguments, and so on. The arity of `func` may be specified if `func.length`
		     * is not sufficient.
		     *
		     * The `_.curry.placeholder` value, which defaults to `_` in monolithic builds,
		     * may be used as a placeholder for provided arguments.
		     *
		     * **Note:** This method doesn't set the "length" property of curried functions.
		     *
		     * @static
		     * @memberOf _
		     * @since 2.0.0
		     * @category Function
		     * @param {Function} func The function to curry.
		     * @param {number} [arity=func.length] The arity of `func`.
		     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
		     * @returns {Function} Returns the new curried function.
		     * @example
		     *
		     * var abc = function(a, b, c) {
		     *   return [a, b, c];
		     * };
		     *
		     * var curried = _.curry(abc);
		     *
		     * curried(1)(2)(3);
		     * // => [1, 2, 3]
		     *
		     * curried(1, 2)(3);
		     * // => [1, 2, 3]
		     *
		     * curried(1, 2, 3);
		     * // => [1, 2, 3]
		     *
		     * // Curried with placeholders.
		     * curried(1)(_, 3)(2);
		     * // => [1, 2, 3]
		     */
		    function curry(func, arity, guard) {
		      arity = guard ? undefined$1 : arity;
		      var result = createWrap(func, WRAP_CURRY_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, undefined$1, arity);
		      result.placeholder = curry.placeholder;
		      return result;
		    }

		    /**
		     * This method is like `_.curry` except that arguments are applied to `func`
		     * in the manner of `_.partialRight` instead of `_.partial`.
		     *
		     * The `_.curryRight.placeholder` value, which defaults to `_` in monolithic
		     * builds, may be used as a placeholder for provided arguments.
		     *
		     * **Note:** This method doesn't set the "length" property of curried functions.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category Function
		     * @param {Function} func The function to curry.
		     * @param {number} [arity=func.length] The arity of `func`.
		     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
		     * @returns {Function} Returns the new curried function.
		     * @example
		     *
		     * var abc = function(a, b, c) {
		     *   return [a, b, c];
		     * };
		     *
		     * var curried = _.curryRight(abc);
		     *
		     * curried(3)(2)(1);
		     * // => [1, 2, 3]
		     *
		     * curried(2, 3)(1);
		     * // => [1, 2, 3]
		     *
		     * curried(1, 2, 3);
		     * // => [1, 2, 3]
		     *
		     * // Curried with placeholders.
		     * curried(3)(1, _)(2);
		     * // => [1, 2, 3]
		     */
		    function curryRight(func, arity, guard) {
		      arity = guard ? undefined$1 : arity;
		      var result = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, undefined$1, arity);
		      result.placeholder = curryRight.placeholder;
		      return result;
		    }

		    /**
		     * Creates a debounced function that delays invoking `func` until after `wait`
		     * milliseconds have elapsed since the last time the debounced function was
		     * invoked. The debounced function comes with a `cancel` method to cancel
		     * delayed `func` invocations and a `flush` method to immediately invoke them.
		     * Provide `options` to indicate whether `func` should be invoked on the
		     * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
		     * with the last arguments provided to the debounced function. Subsequent
		     * calls to the debounced function return the result of the last `func`
		     * invocation.
		     *
		     * **Note:** If `leading` and `trailing` options are `true`, `func` is
		     * invoked on the trailing edge of the timeout only if the debounced function
		     * is invoked more than once during the `wait` timeout.
		     *
		     * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
		     * until to the next tick, similar to `setTimeout` with a timeout of `0`.
		     *
		     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
		     * for details over the differences between `_.debounce` and `_.throttle`.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Function
		     * @param {Function} func The function to debounce.
		     * @param {number} [wait=0] The number of milliseconds to delay.
		     * @param {Object} [options={}] The options object.
		     * @param {boolean} [options.leading=false]
		     *  Specify invoking on the leading edge of the timeout.
		     * @param {number} [options.maxWait]
		     *  The maximum time `func` is allowed to be delayed before it's invoked.
		     * @param {boolean} [options.trailing=true]
		     *  Specify invoking on the trailing edge of the timeout.
		     * @returns {Function} Returns the new debounced function.
		     * @example
		     *
		     * // Avoid costly calculations while the window size is in flux.
		     * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
		     *
		     * // Invoke `sendMail` when clicked, debouncing subsequent calls.
		     * jQuery(element).on('click', _.debounce(sendMail, 300, {
		     *   'leading': true,
		     *   'trailing': false
		     * }));
		     *
		     * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
		     * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
		     * var source = new EventSource('/stream');
		     * jQuery(source).on('message', debounced);
		     *
		     * // Cancel the trailing debounced invocation.
		     * jQuery(window).on('popstate', debounced.cancel);
		     */
		    function debounce(func, wait, options) {
		      var lastArgs,
		          lastThis,
		          maxWait,
		          result,
		          timerId,
		          lastCallTime,
		          lastInvokeTime = 0,
		          leading = false,
		          maxing = false,
		          trailing = true;

		      if (typeof func != 'function') {
		        throw new TypeError(FUNC_ERROR_TEXT);
		      }
		      wait = toNumber(wait) || 0;
		      if (isObject(options)) {
		        leading = !!options.leading;
		        maxing = 'maxWait' in options;
		        maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
		        trailing = 'trailing' in options ? !!options.trailing : trailing;
		      }

		      function invokeFunc(time) {
		        var args = lastArgs,
		            thisArg = lastThis;

		        lastArgs = lastThis = undefined$1;
		        lastInvokeTime = time;
		        result = func.apply(thisArg, args);
		        return result;
		      }

		      function leadingEdge(time) {
		        // Reset any `maxWait` timer.
		        lastInvokeTime = time;
		        // Start the timer for the trailing edge.
		        timerId = setTimeout(timerExpired, wait);
		        // Invoke the leading edge.
		        return leading ? invokeFunc(time) : result;
		      }

		      function remainingWait(time) {
		        var timeSinceLastCall = time - lastCallTime,
		            timeSinceLastInvoke = time - lastInvokeTime,
		            timeWaiting = wait - timeSinceLastCall;

		        return maxing
		          ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke)
		          : timeWaiting;
		      }

		      function shouldInvoke(time) {
		        var timeSinceLastCall = time - lastCallTime,
		            timeSinceLastInvoke = time - lastInvokeTime;

		        // Either this is the first call, activity has stopped and we're at the
		        // trailing edge, the system time has gone backwards and we're treating
		        // it as the trailing edge, or we've hit the `maxWait` limit.
		        return (lastCallTime === undefined$1 || (timeSinceLastCall >= wait) ||
		          (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
		      }

		      function timerExpired() {
		        var time = now();
		        if (shouldInvoke(time)) {
		          return trailingEdge(time);
		        }
		        // Restart the timer.
		        timerId = setTimeout(timerExpired, remainingWait(time));
		      }

		      function trailingEdge(time) {
		        timerId = undefined$1;

		        // Only invoke if we have `lastArgs` which means `func` has been
		        // debounced at least once.
		        if (trailing && lastArgs) {
		          return invokeFunc(time);
		        }
		        lastArgs = lastThis = undefined$1;
		        return result;
		      }

		      function cancel() {
		        if (timerId !== undefined$1) {
		          clearTimeout(timerId);
		        }
		        lastInvokeTime = 0;
		        lastArgs = lastCallTime = lastThis = timerId = undefined$1;
		      }

		      function flush() {
		        return timerId === undefined$1 ? result : trailingEdge(now());
		      }

		      function debounced() {
		        var time = now(),
		            isInvoking = shouldInvoke(time);

		        lastArgs = arguments;
		        lastThis = this;
		        lastCallTime = time;

		        if (isInvoking) {
		          if (timerId === undefined$1) {
		            return leadingEdge(lastCallTime);
		          }
		          if (maxing) {
		            // Handle invocations in a tight loop.
		            clearTimeout(timerId);
		            timerId = setTimeout(timerExpired, wait);
		            return invokeFunc(lastCallTime);
		          }
		        }
		        if (timerId === undefined$1) {
		          timerId = setTimeout(timerExpired, wait);
		        }
		        return result;
		      }
		      debounced.cancel = cancel;
		      debounced.flush = flush;
		      return debounced;
		    }

		    /**
		     * Defers invoking the `func` until the current call stack has cleared. Any
		     * additional arguments are provided to `func` when it's invoked.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Function
		     * @param {Function} func The function to defer.
		     * @param {...*} [args] The arguments to invoke `func` with.
		     * @returns {number} Returns the timer id.
		     * @example
		     *
		     * _.defer(function(text) {
		     *   console.log(text);
		     * }, 'deferred');
		     * // => Logs 'deferred' after one millisecond.
		     */
		    var defer = baseRest(function(func, args) {
		      return baseDelay(func, 1, args);
		    });

		    /**
		     * Invokes `func` after `wait` milliseconds. Any additional arguments are
		     * provided to `func` when it's invoked.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Function
		     * @param {Function} func The function to delay.
		     * @param {number} wait The number of milliseconds to delay invocation.
		     * @param {...*} [args] The arguments to invoke `func` with.
		     * @returns {number} Returns the timer id.
		     * @example
		     *
		     * _.delay(function(text) {
		     *   console.log(text);
		     * }, 1000, 'later');
		     * // => Logs 'later' after one second.
		     */
		    var delay = baseRest(function(func, wait, args) {
		      return baseDelay(func, toNumber(wait) || 0, args);
		    });

		    /**
		     * Creates a function that invokes `func` with arguments reversed.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Function
		     * @param {Function} func The function to flip arguments for.
		     * @returns {Function} Returns the new flipped function.
		     * @example
		     *
		     * var flipped = _.flip(function() {
		     *   return _.toArray(arguments);
		     * });
		     *
		     * flipped('a', 'b', 'c', 'd');
		     * // => ['d', 'c', 'b', 'a']
		     */
		    function flip(func) {
		      return createWrap(func, WRAP_FLIP_FLAG);
		    }

		    /**
		     * Creates a function that memoizes the result of `func`. If `resolver` is
		     * provided, it determines the cache key for storing the result based on the
		     * arguments provided to the memoized function. By default, the first argument
		     * provided to the memoized function is used as the map cache key. The `func`
		     * is invoked with the `this` binding of the memoized function.
		     *
		     * **Note:** The cache is exposed as the `cache` property on the memoized
		     * function. Its creation may be customized by replacing the `_.memoize.Cache`
		     * constructor with one whose instances implement the
		     * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
		     * method interface of `clear`, `delete`, `get`, `has`, and `set`.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Function
		     * @param {Function} func The function to have its output memoized.
		     * @param {Function} [resolver] The function to resolve the cache key.
		     * @returns {Function} Returns the new memoized function.
		     * @example
		     *
		     * var object = { 'a': 1, 'b': 2 };
		     * var other = { 'c': 3, 'd': 4 };
		     *
		     * var values = _.memoize(_.values);
		     * values(object);
		     * // => [1, 2]
		     *
		     * values(other);
		     * // => [3, 4]
		     *
		     * object.a = 2;
		     * values(object);
		     * // => [1, 2]
		     *
		     * // Modify the result cache.
		     * values.cache.set(object, ['a', 'b']);
		     * values(object);
		     * // => ['a', 'b']
		     *
		     * // Replace `_.memoize.Cache`.
		     * _.memoize.Cache = WeakMap;
		     */
		    function memoize(func, resolver) {
		      if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {
		        throw new TypeError(FUNC_ERROR_TEXT);
		      }
		      var memoized = function() {
		        var args = arguments,
		            key = resolver ? resolver.apply(this, args) : args[0],
		            cache = memoized.cache;

		        if (cache.has(key)) {
		          return cache.get(key);
		        }
		        var result = func.apply(this, args);
		        memoized.cache = cache.set(key, result) || cache;
		        return result;
		      };
		      memoized.cache = new (memoize.Cache || MapCache);
		      return memoized;
		    }

		    // Expose `MapCache`.
		    memoize.Cache = MapCache;

		    /**
		     * Creates a function that negates the result of the predicate `func`. The
		     * `func` predicate is invoked with the `this` binding and arguments of the
		     * created function.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category Function
		     * @param {Function} predicate The predicate to negate.
		     * @returns {Function} Returns the new negated function.
		     * @example
		     *
		     * function isEven(n) {
		     *   return n % 2 == 0;
		     * }
		     *
		     * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));
		     * // => [1, 3, 5]
		     */
		    function negate(predicate) {
		      if (typeof predicate != 'function') {
		        throw new TypeError(FUNC_ERROR_TEXT);
		      }
		      return function() {
		        var args = arguments;
		        switch (args.length) {
		          case 0: return !predicate.call(this);
		          case 1: return !predicate.call(this, args[0]);
		          case 2: return !predicate.call(this, args[0], args[1]);
		          case 3: return !predicate.call(this, args[0], args[1], args[2]);
		        }
		        return !predicate.apply(this, args);
		      };
		    }

		    /**
		     * Creates a function that is restricted to invoking `func` once. Repeat calls
		     * to the function return the value of the first invocation. The `func` is
		     * invoked with the `this` binding and arguments of the created function.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Function
		     * @param {Function} func The function to restrict.
		     * @returns {Function} Returns the new restricted function.
		     * @example
		     *
		     * var initialize = _.once(createApplication);
		     * initialize();
		     * initialize();
		     * // => `createApplication` is invoked once
		     */
		    function once(func) {
		      return before(2, func);
		    }

		    /**
		     * Creates a function that invokes `func` with its arguments transformed.
		     *
		     * @static
		     * @since 4.0.0
		     * @memberOf _
		     * @category Function
		     * @param {Function} func The function to wrap.
		     * @param {...(Function|Function[])} [transforms=[_.identity]]
		     *  The argument transforms.
		     * @returns {Function} Returns the new function.
		     * @example
		     *
		     * function doubled(n) {
		     *   return n * 2;
		     * }
		     *
		     * function square(n) {
		     *   return n * n;
		     * }
		     *
		     * var func = _.overArgs(function(x, y) {
		     *   return [x, y];
		     * }, [square, doubled]);
		     *
		     * func(9, 3);
		     * // => [81, 6]
		     *
		     * func(10, 5);
		     * // => [100, 10]
		     */
		    var overArgs = castRest(function(func, transforms) {
		      transforms = (transforms.length == 1 && isArray(transforms[0]))
		        ? arrayMap(transforms[0], baseUnary(getIteratee()))
		        : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));

		      var funcsLength = transforms.length;
		      return baseRest(function(args) {
		        var index = -1,
		            length = nativeMin(args.length, funcsLength);

		        while (++index < length) {
		          args[index] = transforms[index].call(this, args[index]);
		        }
		        return apply(func, this, args);
		      });
		    });

		    /**
		     * Creates a function that invokes `func` with `partials` prepended to the
		     * arguments it receives. This method is like `_.bind` except it does **not**
		     * alter the `this` binding.
		     *
		     * The `_.partial.placeholder` value, which defaults to `_` in monolithic
		     * builds, may be used as a placeholder for partially applied arguments.
		     *
		     * **Note:** This method doesn't set the "length" property of partially
		     * applied functions.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.2.0
		     * @category Function
		     * @param {Function} func The function to partially apply arguments to.
		     * @param {...*} [partials] The arguments to be partially applied.
		     * @returns {Function} Returns the new partially applied function.
		     * @example
		     *
		     * function greet(greeting, name) {
		     *   return greeting + ' ' + name;
		     * }
		     *
		     * var sayHelloTo = _.partial(greet, 'hello');
		     * sayHelloTo('fred');
		     * // => 'hello fred'
		     *
		     * // Partially applied with placeholders.
		     * var greetFred = _.partial(greet, _, 'fred');
		     * greetFred('hi');
		     * // => 'hi fred'
		     */
		    var partial = baseRest(function(func, partials) {
		      var holders = replaceHolders(partials, getHolder(partial));
		      return createWrap(func, WRAP_PARTIAL_FLAG, undefined$1, partials, holders);
		    });

		    /**
		     * This method is like `_.partial` except that partially applied arguments
		     * are appended to the arguments it receives.
		     *
		     * The `_.partialRight.placeholder` value, which defaults to `_` in monolithic
		     * builds, may be used as a placeholder for partially applied arguments.
		     *
		     * **Note:** This method doesn't set the "length" property of partially
		     * applied functions.
		     *
		     * @static
		     * @memberOf _
		     * @since 1.0.0
		     * @category Function
		     * @param {Function} func The function to partially apply arguments to.
		     * @param {...*} [partials] The arguments to be partially applied.
		     * @returns {Function} Returns the new partially applied function.
		     * @example
		     *
		     * function greet(greeting, name) {
		     *   return greeting + ' ' + name;
		     * }
		     *
		     * var greetFred = _.partialRight(greet, 'fred');
		     * greetFred('hi');
		     * // => 'hi fred'
		     *
		     * // Partially applied with placeholders.
		     * var sayHelloTo = _.partialRight(greet, 'hello', _);
		     * sayHelloTo('fred');
		     * // => 'hello fred'
		     */
		    var partialRight = baseRest(function(func, partials) {
		      var holders = replaceHolders(partials, getHolder(partialRight));
		      return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined$1, partials, holders);
		    });

		    /**
		     * Creates a function that invokes `func` with arguments arranged according
		     * to the specified `indexes` where the argument value at the first index is
		     * provided as the first argument, the argument value at the second index is
		     * provided as the second argument, and so on.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category Function
		     * @param {Function} func The function to rearrange arguments for.
		     * @param {...(number|number[])} indexes The arranged argument indexes.
		     * @returns {Function} Returns the new function.
		     * @example
		     *
		     * var rearged = _.rearg(function(a, b, c) {
		     *   return [a, b, c];
		     * }, [2, 0, 1]);
		     *
		     * rearged('b', 'c', 'a')
		     * // => ['a', 'b', 'c']
		     */
		    var rearg = flatRest(function(func, indexes) {
		      return createWrap(func, WRAP_REARG_FLAG, undefined$1, undefined$1, undefined$1, indexes);
		    });

		    /**
		     * Creates a function that invokes `func` with the `this` binding of the
		     * created function and arguments from `start` and beyond provided as
		     * an array.
		     *
		     * **Note:** This method is based on the
		     * [rest parameter](https://mdn.io/rest_parameters).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Function
		     * @param {Function} func The function to apply a rest parameter to.
		     * @param {number} [start=func.length-1] The start position of the rest parameter.
		     * @returns {Function} Returns the new function.
		     * @example
		     *
		     * var say = _.rest(function(what, names) {
		     *   return what + ' ' + _.initial(names).join(', ') +
		     *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);
		     * });
		     *
		     * say('hello', 'fred', 'barney', 'pebbles');
		     * // => 'hello fred, barney, & pebbles'
		     */
		    function rest(func, start) {
		      if (typeof func != 'function') {
		        throw new TypeError(FUNC_ERROR_TEXT);
		      }
		      start = start === undefined$1 ? start : toInteger(start);
		      return baseRest(func, start);
		    }

		    /**
		     * Creates a function that invokes `func` with the `this` binding of the
		     * create function and an array of arguments much like
		     * [`Function#apply`](http://www.ecma-international.org/ecma-262/7.0/#sec-function.prototype.apply).
		     *
		     * **Note:** This method is based on the
		     * [spread operator](https://mdn.io/spread_operator).
		     *
		     * @static
		     * @memberOf _
		     * @since 3.2.0
		     * @category Function
		     * @param {Function} func The function to spread arguments over.
		     * @param {number} [start=0] The start position of the spread.
		     * @returns {Function} Returns the new function.
		     * @example
		     *
		     * var say = _.spread(function(who, what) {
		     *   return who + ' says ' + what;
		     * });
		     *
		     * say(['fred', 'hello']);
		     * // => 'fred says hello'
		     *
		     * var numbers = Promise.all([
		     *   Promise.resolve(40),
		     *   Promise.resolve(36)
		     * ]);
		     *
		     * numbers.then(_.spread(function(x, y) {
		     *   return x + y;
		     * }));
		     * // => a Promise of 76
		     */
		    function spread(func, start) {
		      if (typeof func != 'function') {
		        throw new TypeError(FUNC_ERROR_TEXT);
		      }
		      start = start == null ? 0 : nativeMax(toInteger(start), 0);
		      return baseRest(function(args) {
		        var array = args[start],
		            otherArgs = castSlice(args, 0, start);

		        if (array) {
		          arrayPush(otherArgs, array);
		        }
		        return apply(func, this, otherArgs);
		      });
		    }

		    /**
		     * Creates a throttled function that only invokes `func` at most once per
		     * every `wait` milliseconds. The throttled function comes with a `cancel`
		     * method to cancel delayed `func` invocations and a `flush` method to
		     * immediately invoke them. Provide `options` to indicate whether `func`
		     * should be invoked on the leading and/or trailing edge of the `wait`
		     * timeout. The `func` is invoked with the last arguments provided to the
		     * throttled function. Subsequent calls to the throttled function return the
		     * result of the last `func` invocation.
		     *
		     * **Note:** If `leading` and `trailing` options are `true`, `func` is
		     * invoked on the trailing edge of the timeout only if the throttled function
		     * is invoked more than once during the `wait` timeout.
		     *
		     * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
		     * until to the next tick, similar to `setTimeout` with a timeout of `0`.
		     *
		     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
		     * for details over the differences between `_.throttle` and `_.debounce`.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Function
		     * @param {Function} func The function to throttle.
		     * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
		     * @param {Object} [options={}] The options object.
		     * @param {boolean} [options.leading=true]
		     *  Specify invoking on the leading edge of the timeout.
		     * @param {boolean} [options.trailing=true]
		     *  Specify invoking on the trailing edge of the timeout.
		     * @returns {Function} Returns the new throttled function.
		     * @example
		     *
		     * // Avoid excessively updating the position while scrolling.
		     * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
		     *
		     * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
		     * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
		     * jQuery(element).on('click', throttled);
		     *
		     * // Cancel the trailing throttled invocation.
		     * jQuery(window).on('popstate', throttled.cancel);
		     */
		    function throttle(func, wait, options) {
		      var leading = true,
		          trailing = true;

		      if (typeof func != 'function') {
		        throw new TypeError(FUNC_ERROR_TEXT);
		      }
		      if (isObject(options)) {
		        leading = 'leading' in options ? !!options.leading : leading;
		        trailing = 'trailing' in options ? !!options.trailing : trailing;
		      }
		      return debounce(func, wait, {
		        'leading': leading,
		        'maxWait': wait,
		        'trailing': trailing
		      });
		    }

		    /**
		     * Creates a function that accepts up to one argument, ignoring any
		     * additional arguments.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Function
		     * @param {Function} func The function to cap arguments for.
		     * @returns {Function} Returns the new capped function.
		     * @example
		     *
		     * _.map(['6', '8', '10'], _.unary(parseInt));
		     * // => [6, 8, 10]
		     */
		    function unary(func) {
		      return ary(func, 1);
		    }

		    /**
		     * Creates a function that provides `value` to `wrapper` as its first
		     * argument. Any additional arguments provided to the function are appended
		     * to those provided to the `wrapper`. The wrapper is invoked with the `this`
		     * binding of the created function.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Function
		     * @param {*} value The value to wrap.
		     * @param {Function} [wrapper=identity] The wrapper function.
		     * @returns {Function} Returns the new function.
		     * @example
		     *
		     * var p = _.wrap(_.escape, function(func, text) {
		     *   return '<p>' + func(text) + '</p>';
		     * });
		     *
		     * p('fred, barney, & pebbles');
		     * // => '<p>fred, barney, &amp; pebbles</p>'
		     */
		    function wrap(value, wrapper) {
		      return partial(castFunction(wrapper), value);
		    }

		    /*------------------------------------------------------------------------*/

		    /**
		     * Casts `value` as an array if it's not one.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.4.0
		     * @category Lang
		     * @param {*} value The value to inspect.
		     * @returns {Array} Returns the cast array.
		     * @example
		     *
		     * _.castArray(1);
		     * // => [1]
		     *
		     * _.castArray({ 'a': 1 });
		     * // => [{ 'a': 1 }]
		     *
		     * _.castArray('abc');
		     * // => ['abc']
		     *
		     * _.castArray(null);
		     * // => [null]
		     *
		     * _.castArray(undefined);
		     * // => [undefined]
		     *
		     * _.castArray();
		     * // => []
		     *
		     * var array = [1, 2, 3];
		     * console.log(_.castArray(array) === array);
		     * // => true
		     */
		    function castArray() {
		      if (!arguments.length) {
		        return [];
		      }
		      var value = arguments[0];
		      return isArray(value) ? value : [value];
		    }

		    /**
		     * Creates a shallow clone of `value`.
		     *
		     * **Note:** This method is loosely based on the
		     * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)
		     * and supports cloning arrays, array buffers, booleans, date objects, maps,
		     * numbers, `Object` objects, regexes, sets, strings, symbols, and typed
		     * arrays. The own enumerable properties of `arguments` objects are cloned
		     * as plain objects. An empty object is returned for uncloneable values such
		     * as error objects, functions, DOM nodes, and WeakMaps.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Lang
		     * @param {*} value The value to clone.
		     * @returns {*} Returns the cloned value.
		     * @see _.cloneDeep
		     * @example
		     *
		     * var objects = [{ 'a': 1 }, { 'b': 2 }];
		     *
		     * var shallow = _.clone(objects);
		     * console.log(shallow[0] === objects[0]);
		     * // => true
		     */
		    function clone(value) {
		      return baseClone(value, CLONE_SYMBOLS_FLAG);
		    }

		    /**
		     * This method is like `_.clone` except that it accepts `customizer` which
		     * is invoked to produce the cloned value. If `customizer` returns `undefined`,
		     * cloning is handled by the method instead. The `customizer` is invoked with
		     * up to four arguments; (value [, index|key, object, stack]).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Lang
		     * @param {*} value The value to clone.
		     * @param {Function} [customizer] The function to customize cloning.
		     * @returns {*} Returns the cloned value.
		     * @see _.cloneDeepWith
		     * @example
		     *
		     * function customizer(value) {
		     *   if (_.isElement(value)) {
		     *     return value.cloneNode(false);
		     *   }
		     * }
		     *
		     * var el = _.cloneWith(document.body, customizer);
		     *
		     * console.log(el === document.body);
		     * // => false
		     * console.log(el.nodeName);
		     * // => 'BODY'
		     * console.log(el.childNodes.length);
		     * // => 0
		     */
		    function cloneWith(value, customizer) {
		      customizer = typeof customizer == 'function' ? customizer : undefined$1;
		      return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
		    }

		    /**
		     * This method is like `_.clone` except that it recursively clones `value`.
		     *
		     * @static
		     * @memberOf _
		     * @since 1.0.0
		     * @category Lang
		     * @param {*} value The value to recursively clone.
		     * @returns {*} Returns the deep cloned value.
		     * @see _.clone
		     * @example
		     *
		     * var objects = [{ 'a': 1 }, { 'b': 2 }];
		     *
		     * var deep = _.cloneDeep(objects);
		     * console.log(deep[0] === objects[0]);
		     * // => false
		     */
		    function cloneDeep(value) {
		      return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
		    }

		    /**
		     * This method is like `_.cloneWith` except that it recursively clones `value`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Lang
		     * @param {*} value The value to recursively clone.
		     * @param {Function} [customizer] The function to customize cloning.
		     * @returns {*} Returns the deep cloned value.
		     * @see _.cloneWith
		     * @example
		     *
		     * function customizer(value) {
		     *   if (_.isElement(value)) {
		     *     return value.cloneNode(true);
		     *   }
		     * }
		     *
		     * var el = _.cloneDeepWith(document.body, customizer);
		     *
		     * console.log(el === document.body);
		     * // => false
		     * console.log(el.nodeName);
		     * // => 'BODY'
		     * console.log(el.childNodes.length);
		     * // => 20
		     */
		    function cloneDeepWith(value, customizer) {
		      customizer = typeof customizer == 'function' ? customizer : undefined$1;
		      return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
		    }

		    /**
		     * Checks if `object` conforms to `source` by invoking the predicate
		     * properties of `source` with the corresponding property values of `object`.
		     *
		     * **Note:** This method is equivalent to `_.conforms` when `source` is
		     * partially applied.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.14.0
		     * @category Lang
		     * @param {Object} object The object to inspect.
		     * @param {Object} source The object of property predicates to conform to.
		     * @returns {boolean} Returns `true` if `object` conforms, else `false`.
		     * @example
		     *
		     * var object = { 'a': 1, 'b': 2 };
		     *
		     * _.conformsTo(object, { 'b': function(n) { return n > 1; } });
		     * // => true
		     *
		     * _.conformsTo(object, { 'b': function(n) { return n > 2; } });
		     * // => false
		     */
		    function conformsTo(object, source) {
		      return source == null || baseConformsTo(object, source, keys(source));
		    }

		    /**
		     * Performs a
		     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
		     * comparison between two values to determine if they are equivalent.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Lang
		     * @param {*} value The value to compare.
		     * @param {*} other The other value to compare.
		     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
		     * @example
		     *
		     * var object = { 'a': 1 };
		     * var other = { 'a': 1 };
		     *
		     * _.eq(object, object);
		     * // => true
		     *
		     * _.eq(object, other);
		     * // => false
		     *
		     * _.eq('a', 'a');
		     * // => true
		     *
		     * _.eq('a', Object('a'));
		     * // => false
		     *
		     * _.eq(NaN, NaN);
		     * // => true
		     */
		    function eq(value, other) {
		      return value === other || (value !== value && other !== other);
		    }

		    /**
		     * Checks if `value` is greater than `other`.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.9.0
		     * @category Lang
		     * @param {*} value The value to compare.
		     * @param {*} other The other value to compare.
		     * @returns {boolean} Returns `true` if `value` is greater than `other`,
		     *  else `false`.
		     * @see _.lt
		     * @example
		     *
		     * _.gt(3, 1);
		     * // => true
		     *
		     * _.gt(3, 3);
		     * // => false
		     *
		     * _.gt(1, 3);
		     * // => false
		     */
		    var gt = createRelationalOperation(baseGt);

		    /**
		     * Checks if `value` is greater than or equal to `other`.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.9.0
		     * @category Lang
		     * @param {*} value The value to compare.
		     * @param {*} other The other value to compare.
		     * @returns {boolean} Returns `true` if `value` is greater than or equal to
		     *  `other`, else `false`.
		     * @see _.lte
		     * @example
		     *
		     * _.gte(3, 1);
		     * // => true
		     *
		     * _.gte(3, 3);
		     * // => true
		     *
		     * _.gte(1, 3);
		     * // => false
		     */
		    var gte = createRelationalOperation(function(value, other) {
		      return value >= other;
		    });

		    /**
		     * Checks if `value` is likely an `arguments` object.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
		     *  else `false`.
		     * @example
		     *
		     * _.isArguments(function() { return arguments; }());
		     * // => true
		     *
		     * _.isArguments([1, 2, 3]);
		     * // => false
		     */
		    var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
		      return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&
		        !propertyIsEnumerable.call(value, 'callee');
		    };

		    /**
		     * Checks if `value` is classified as an `Array` object.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is an array, else `false`.
		     * @example
		     *
		     * _.isArray([1, 2, 3]);
		     * // => true
		     *
		     * _.isArray(document.body.children);
		     * // => false
		     *
		     * _.isArray('abc');
		     * // => false
		     *
		     * _.isArray(_.noop);
		     * // => false
		     */
		    var isArray = Array.isArray;

		    /**
		     * Checks if `value` is classified as an `ArrayBuffer` object.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.3.0
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.
		     * @example
		     *
		     * _.isArrayBuffer(new ArrayBuffer(2));
		     * // => true
		     *
		     * _.isArrayBuffer(new Array(2));
		     * // => false
		     */
		    var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;

		    /**
		     * Checks if `value` is array-like. A value is considered array-like if it's
		     * not a function and has a `value.length` that's an integer greater than or
		     * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
		     * @example
		     *
		     * _.isArrayLike([1, 2, 3]);
		     * // => true
		     *
		     * _.isArrayLike(document.body.children);
		     * // => true
		     *
		     * _.isArrayLike('abc');
		     * // => true
		     *
		     * _.isArrayLike(_.noop);
		     * // => false
		     */
		    function isArrayLike(value) {
		      return value != null && isLength(value.length) && !isFunction(value);
		    }

		    /**
		     * This method is like `_.isArrayLike` except that it also checks if `value`
		     * is an object.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is an array-like object,
		     *  else `false`.
		     * @example
		     *
		     * _.isArrayLikeObject([1, 2, 3]);
		     * // => true
		     *
		     * _.isArrayLikeObject(document.body.children);
		     * // => true
		     *
		     * _.isArrayLikeObject('abc');
		     * // => false
		     *
		     * _.isArrayLikeObject(_.noop);
		     * // => false
		     */
		    function isArrayLikeObject(value) {
		      return isObjectLike(value) && isArrayLike(value);
		    }

		    /**
		     * Checks if `value` is classified as a boolean primitive or object.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is a boolean, else `false`.
		     * @example
		     *
		     * _.isBoolean(false);
		     * // => true
		     *
		     * _.isBoolean(null);
		     * // => false
		     */
		    function isBoolean(value) {
		      return value === true || value === false ||
		        (isObjectLike(value) && baseGetTag(value) == boolTag);
		    }

		    /**
		     * Checks if `value` is a buffer.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.3.0
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
		     * @example
		     *
		     * _.isBuffer(new Buffer(2));
		     * // => true
		     *
		     * _.isBuffer(new Uint8Array(2));
		     * // => false
		     */
		    var isBuffer = nativeIsBuffer || stubFalse;

		    /**
		     * Checks if `value` is classified as a `Date` object.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is a date object, else `false`.
		     * @example
		     *
		     * _.isDate(new Date);
		     * // => true
		     *
		     * _.isDate('Mon April 23 2012');
		     * // => false
		     */
		    var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;

		    /**
		     * Checks if `value` is likely a DOM element.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is a DOM element, else `false`.
		     * @example
		     *
		     * _.isElement(document.body);
		     * // => true
		     *
		     * _.isElement('<body>');
		     * // => false
		     */
		    function isElement(value) {
		      return isObjectLike(value) && value.nodeType === 1 && !isPlainObject(value);
		    }

		    /**
		     * Checks if `value` is an empty object, collection, map, or set.
		     *
		     * Objects are considered empty if they have no own enumerable string keyed
		     * properties.
		     *
		     * Array-like values such as `arguments` objects, arrays, buffers, strings, or
		     * jQuery-like collections are considered empty if they have a `length` of `0`.
		     * Similarly, maps and sets are considered empty if they have a `size` of `0`.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is empty, else `false`.
		     * @example
		     *
		     * _.isEmpty(null);
		     * // => true
		     *
		     * _.isEmpty(true);
		     * // => true
		     *
		     * _.isEmpty(1);
		     * // => true
		     *
		     * _.isEmpty([1, 2, 3]);
		     * // => false
		     *
		     * _.isEmpty({ 'a': 1 });
		     * // => false
		     */
		    function isEmpty(value) {
		      if (value == null) {
		        return true;
		      }
		      if (isArrayLike(value) &&
		          (isArray(value) || typeof value == 'string' || typeof value.splice == 'function' ||
		            isBuffer(value) || isTypedArray(value) || isArguments(value))) {
		        return !value.length;
		      }
		      var tag = getTag(value);
		      if (tag == mapTag || tag == setTag) {
		        return !value.size;
		      }
		      if (isPrototype(value)) {
		        return !baseKeys(value).length;
		      }
		      for (var key in value) {
		        if (hasOwnProperty.call(value, key)) {
		          return false;
		        }
		      }
		      return true;
		    }

		    /**
		     * Performs a deep comparison between two values to determine if they are
		     * equivalent.
		     *
		     * **Note:** This method supports comparing arrays, array buffers, booleans,
		     * date objects, error objects, maps, numbers, `Object` objects, regexes,
		     * sets, strings, symbols, and typed arrays. `Object` objects are compared
		     * by their own, not inherited, enumerable properties. Functions and DOM
		     * nodes are compared by strict equality, i.e. `===`.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Lang
		     * @param {*} value The value to compare.
		     * @param {*} other The other value to compare.
		     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
		     * @example
		     *
		     * var object = { 'a': 1 };
		     * var other = { 'a': 1 };
		     *
		     * _.isEqual(object, other);
		     * // => true
		     *
		     * object === other;
		     * // => false
		     */
		    function isEqual(value, other) {
		      return baseIsEqual(value, other);
		    }

		    /**
		     * This method is like `_.isEqual` except that it accepts `customizer` which
		     * is invoked to compare values. If `customizer` returns `undefined`, comparisons
		     * are handled by the method instead. The `customizer` is invoked with up to
		     * six arguments: (objValue, othValue [, index|key, object, other, stack]).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Lang
		     * @param {*} value The value to compare.
		     * @param {*} other The other value to compare.
		     * @param {Function} [customizer] The function to customize comparisons.
		     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
		     * @example
		     *
		     * function isGreeting(value) {
		     *   return /^h(?:i|ello)$/.test(value);
		     * }
		     *
		     * function customizer(objValue, othValue) {
		     *   if (isGreeting(objValue) && isGreeting(othValue)) {
		     *     return true;
		     *   }
		     * }
		     *
		     * var array = ['hello', 'goodbye'];
		     * var other = ['hi', 'goodbye'];
		     *
		     * _.isEqualWith(array, other, customizer);
		     * // => true
		     */
		    function isEqualWith(value, other, customizer) {
		      customizer = typeof customizer == 'function' ? customizer : undefined$1;
		      var result = customizer ? customizer(value, other) : undefined$1;
		      return result === undefined$1 ? baseIsEqual(value, other, undefined$1, customizer) : !!result;
		    }

		    /**
		     * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,
		     * `SyntaxError`, `TypeError`, or `URIError` object.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is an error object, else `false`.
		     * @example
		     *
		     * _.isError(new Error);
		     * // => true
		     *
		     * _.isError(Error);
		     * // => false
		     */
		    function isError(value) {
		      if (!isObjectLike(value)) {
		        return false;
		      }
		      var tag = baseGetTag(value);
		      return tag == errorTag || tag == domExcTag ||
		        (typeof value.message == 'string' && typeof value.name == 'string' && !isPlainObject(value));
		    }

		    /**
		     * Checks if `value` is a finite primitive number.
		     *
		     * **Note:** This method is based on
		     * [`Number.isFinite`](https://mdn.io/Number/isFinite).
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is a finite number, else `false`.
		     * @example
		     *
		     * _.isFinite(3);
		     * // => true
		     *
		     * _.isFinite(Number.MIN_VALUE);
		     * // => true
		     *
		     * _.isFinite(Infinity);
		     * // => false
		     *
		     * _.isFinite('3');
		     * // => false
		     */
		    function isFinite(value) {
		      return typeof value == 'number' && nativeIsFinite(value);
		    }

		    /**
		     * Checks if `value` is classified as a `Function` object.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is a function, else `false`.
		     * @example
		     *
		     * _.isFunction(_);
		     * // => true
		     *
		     * _.isFunction(/abc/);
		     * // => false
		     */
		    function isFunction(value) {
		      if (!isObject(value)) {
		        return false;
		      }
		      // The use of `Object#toString` avoids issues with the `typeof` operator
		      // in Safari 9 which returns 'object' for typed arrays and other constructors.
		      var tag = baseGetTag(value);
		      return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
		    }

		    /**
		     * Checks if `value` is an integer.
		     *
		     * **Note:** This method is based on
		     * [`Number.isInteger`](https://mdn.io/Number/isInteger).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is an integer, else `false`.
		     * @example
		     *
		     * _.isInteger(3);
		     * // => true
		     *
		     * _.isInteger(Number.MIN_VALUE);
		     * // => false
		     *
		     * _.isInteger(Infinity);
		     * // => false
		     *
		     * _.isInteger('3');
		     * // => false
		     */
		    function isInteger(value) {
		      return typeof value == 'number' && value == toInteger(value);
		    }

		    /**
		     * Checks if `value` is a valid array-like length.
		     *
		     * **Note:** This method is loosely based on
		     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
		     * @example
		     *
		     * _.isLength(3);
		     * // => true
		     *
		     * _.isLength(Number.MIN_VALUE);
		     * // => false
		     *
		     * _.isLength(Infinity);
		     * // => false
		     *
		     * _.isLength('3');
		     * // => false
		     */
		    function isLength(value) {
		      return typeof value == 'number' &&
		        value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
		    }

		    /**
		     * Checks if `value` is the
		     * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
		     * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is an object, else `false`.
		     * @example
		     *
		     * _.isObject({});
		     * // => true
		     *
		     * _.isObject([1, 2, 3]);
		     * // => true
		     *
		     * _.isObject(_.noop);
		     * // => true
		     *
		     * _.isObject(null);
		     * // => false
		     */
		    function isObject(value) {
		      var type = typeof value;
		      return value != null && (type == 'object' || type == 'function');
		    }

		    /**
		     * Checks if `value` is object-like. A value is object-like if it's not `null`
		     * and has a `typeof` result of "object".
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
		     * @example
		     *
		     * _.isObjectLike({});
		     * // => true
		     *
		     * _.isObjectLike([1, 2, 3]);
		     * // => true
		     *
		     * _.isObjectLike(_.noop);
		     * // => false
		     *
		     * _.isObjectLike(null);
		     * // => false
		     */
		    function isObjectLike(value) {
		      return value != null && typeof value == 'object';
		    }

		    /**
		     * Checks if `value` is classified as a `Map` object.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.3.0
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is a map, else `false`.
		     * @example
		     *
		     * _.isMap(new Map);
		     * // => true
		     *
		     * _.isMap(new WeakMap);
		     * // => false
		     */
		    var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;

		    /**
		     * Performs a partial deep comparison between `object` and `source` to
		     * determine if `object` contains equivalent property values.
		     *
		     * **Note:** This method is equivalent to `_.matches` when `source` is
		     * partially applied.
		     *
		     * Partial comparisons will match empty array and empty object `source`
		     * values against any array or object value, respectively. See `_.isEqual`
		     * for a list of supported value comparisons.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category Lang
		     * @param {Object} object The object to inspect.
		     * @param {Object} source The object of property values to match.
		     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
		     * @example
		     *
		     * var object = { 'a': 1, 'b': 2 };
		     *
		     * _.isMatch(object, { 'b': 2 });
		     * // => true
		     *
		     * _.isMatch(object, { 'b': 1 });
		     * // => false
		     */
		    function isMatch(object, source) {
		      return object === source || baseIsMatch(object, source, getMatchData(source));
		    }

		    /**
		     * This method is like `_.isMatch` except that it accepts `customizer` which
		     * is invoked to compare values. If `customizer` returns `undefined`, comparisons
		     * are handled by the method instead. The `customizer` is invoked with five
		     * arguments: (objValue, srcValue, index|key, object, source).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Lang
		     * @param {Object} object The object to inspect.
		     * @param {Object} source The object of property values to match.
		     * @param {Function} [customizer] The function to customize comparisons.
		     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
		     * @example
		     *
		     * function isGreeting(value) {
		     *   return /^h(?:i|ello)$/.test(value);
		     * }
		     *
		     * function customizer(objValue, srcValue) {
		     *   if (isGreeting(objValue) && isGreeting(srcValue)) {
		     *     return true;
		     *   }
		     * }
		     *
		     * var object = { 'greeting': 'hello' };
		     * var source = { 'greeting': 'hi' };
		     *
		     * _.isMatchWith(object, source, customizer);
		     * // => true
		     */
		    function isMatchWith(object, source, customizer) {
		      customizer = typeof customizer == 'function' ? customizer : undefined$1;
		      return baseIsMatch(object, source, getMatchData(source), customizer);
		    }

		    /**
		     * Checks if `value` is `NaN`.
		     *
		     * **Note:** This method is based on
		     * [`Number.isNaN`](https://mdn.io/Number/isNaN) and is not the same as
		     * global [`isNaN`](https://mdn.io/isNaN) which returns `true` for
		     * `undefined` and other non-number values.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
		     * @example
		     *
		     * _.isNaN(NaN);
		     * // => true
		     *
		     * _.isNaN(new Number(NaN));
		     * // => true
		     *
		     * isNaN(undefined);
		     * // => true
		     *
		     * _.isNaN(undefined);
		     * // => false
		     */
		    function isNaN(value) {
		      // An `NaN` primitive is the only value that is not equal to itself.
		      // Perform the `toStringTag` check first to avoid errors with some
		      // ActiveX objects in IE.
		      return isNumber(value) && value != +value;
		    }

		    /**
		     * Checks if `value` is a pristine native function.
		     *
		     * **Note:** This method can't reliably detect native functions in the presence
		     * of the core-js package because core-js circumvents this kind of detection.
		     * Despite multiple requests, the core-js maintainer has made it clear: any
		     * attempt to fix the detection will be obstructed. As a result, we're left
		     * with little choice but to throw an error. Unfortunately, this also affects
		     * packages, like [babel-polyfill](https://www.npmjs.com/package/babel-polyfill),
		     * which rely on core-js.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is a native function,
		     *  else `false`.
		     * @example
		     *
		     * _.isNative(Array.prototype.push);
		     * // => true
		     *
		     * _.isNative(_);
		     * // => false
		     */
		    function isNative(value) {
		      if (isMaskable(value)) {
		        throw new Error(CORE_ERROR_TEXT);
		      }
		      return baseIsNative(value);
		    }

		    /**
		     * Checks if `value` is `null`.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is `null`, else `false`.
		     * @example
		     *
		     * _.isNull(null);
		     * // => true
		     *
		     * _.isNull(void 0);
		     * // => false
		     */
		    function isNull(value) {
		      return value === null;
		    }

		    /**
		     * Checks if `value` is `null` or `undefined`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is nullish, else `false`.
		     * @example
		     *
		     * _.isNil(null);
		     * // => true
		     *
		     * _.isNil(void 0);
		     * // => true
		     *
		     * _.isNil(NaN);
		     * // => false
		     */
		    function isNil(value) {
		      return value == null;
		    }

		    /**
		     * Checks if `value` is classified as a `Number` primitive or object.
		     *
		     * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are
		     * classified as numbers, use the `_.isFinite` method.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is a number, else `false`.
		     * @example
		     *
		     * _.isNumber(3);
		     * // => true
		     *
		     * _.isNumber(Number.MIN_VALUE);
		     * // => true
		     *
		     * _.isNumber(Infinity);
		     * // => true
		     *
		     * _.isNumber('3');
		     * // => false
		     */
		    function isNumber(value) {
		      return typeof value == 'number' ||
		        (isObjectLike(value) && baseGetTag(value) == numberTag);
		    }

		    /**
		     * Checks if `value` is a plain object, that is, an object created by the
		     * `Object` constructor or one with a `[[Prototype]]` of `null`.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.8.0
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
		     * @example
		     *
		     * function Foo() {
		     *   this.a = 1;
		     * }
		     *
		     * _.isPlainObject(new Foo);
		     * // => false
		     *
		     * _.isPlainObject([1, 2, 3]);
		     * // => false
		     *
		     * _.isPlainObject({ 'x': 0, 'y': 0 });
		     * // => true
		     *
		     * _.isPlainObject(Object.create(null));
		     * // => true
		     */
		    function isPlainObject(value) {
		      if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
		        return false;
		      }
		      var proto = getPrototype(value);
		      if (proto === null) {
		        return true;
		      }
		      var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
		      return typeof Ctor == 'function' && Ctor instanceof Ctor &&
		        funcToString.call(Ctor) == objectCtorString;
		    }

		    /**
		     * Checks if `value` is classified as a `RegExp` object.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
		     * @example
		     *
		     * _.isRegExp(/abc/);
		     * // => true
		     *
		     * _.isRegExp('/abc/');
		     * // => false
		     */
		    var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;

		    /**
		     * Checks if `value` is a safe integer. An integer is safe if it's an IEEE-754
		     * double precision number which isn't the result of a rounded unsafe integer.
		     *
		     * **Note:** This method is based on
		     * [`Number.isSafeInteger`](https://mdn.io/Number/isSafeInteger).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is a safe integer, else `false`.
		     * @example
		     *
		     * _.isSafeInteger(3);
		     * // => true
		     *
		     * _.isSafeInteger(Number.MIN_VALUE);
		     * // => false
		     *
		     * _.isSafeInteger(Infinity);
		     * // => false
		     *
		     * _.isSafeInteger('3');
		     * // => false
		     */
		    function isSafeInteger(value) {
		      return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
		    }

		    /**
		     * Checks if `value` is classified as a `Set` object.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.3.0
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is a set, else `false`.
		     * @example
		     *
		     * _.isSet(new Set);
		     * // => true
		     *
		     * _.isSet(new WeakSet);
		     * // => false
		     */
		    var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;

		    /**
		     * Checks if `value` is classified as a `String` primitive or object.
		     *
		     * @static
		     * @since 0.1.0
		     * @memberOf _
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is a string, else `false`.
		     * @example
		     *
		     * _.isString('abc');
		     * // => true
		     *
		     * _.isString(1);
		     * // => false
		     */
		    function isString(value) {
		      return typeof value == 'string' ||
		        (!isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag);
		    }

		    /**
		     * Checks if `value` is classified as a `Symbol` primitive or object.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
		     * @example
		     *
		     * _.isSymbol(Symbol.iterator);
		     * // => true
		     *
		     * _.isSymbol('abc');
		     * // => false
		     */
		    function isSymbol(value) {
		      return typeof value == 'symbol' ||
		        (isObjectLike(value) && baseGetTag(value) == symbolTag);
		    }

		    /**
		     * Checks if `value` is classified as a typed array.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
		     * @example
		     *
		     * _.isTypedArray(new Uint8Array);
		     * // => true
		     *
		     * _.isTypedArray([]);
		     * // => false
		     */
		    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

		    /**
		     * Checks if `value` is `undefined`.
		     *
		     * @static
		     * @since 0.1.0
		     * @memberOf _
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
		     * @example
		     *
		     * _.isUndefined(void 0);
		     * // => true
		     *
		     * _.isUndefined(null);
		     * // => false
		     */
		    function isUndefined(value) {
		      return value === undefined$1;
		    }

		    /**
		     * Checks if `value` is classified as a `WeakMap` object.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.3.0
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is a weak map, else `false`.
		     * @example
		     *
		     * _.isWeakMap(new WeakMap);
		     * // => true
		     *
		     * _.isWeakMap(new Map);
		     * // => false
		     */
		    function isWeakMap(value) {
		      return isObjectLike(value) && getTag(value) == weakMapTag;
		    }

		    /**
		     * Checks if `value` is classified as a `WeakSet` object.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.3.0
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is a weak set, else `false`.
		     * @example
		     *
		     * _.isWeakSet(new WeakSet);
		     * // => true
		     *
		     * _.isWeakSet(new Set);
		     * // => false
		     */
		    function isWeakSet(value) {
		      return isObjectLike(value) && baseGetTag(value) == weakSetTag;
		    }

		    /**
		     * Checks if `value` is less than `other`.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.9.0
		     * @category Lang
		     * @param {*} value The value to compare.
		     * @param {*} other The other value to compare.
		     * @returns {boolean} Returns `true` if `value` is less than `other`,
		     *  else `false`.
		     * @see _.gt
		     * @example
		     *
		     * _.lt(1, 3);
		     * // => true
		     *
		     * _.lt(3, 3);
		     * // => false
		     *
		     * _.lt(3, 1);
		     * // => false
		     */
		    var lt = createRelationalOperation(baseLt);

		    /**
		     * Checks if `value` is less than or equal to `other`.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.9.0
		     * @category Lang
		     * @param {*} value The value to compare.
		     * @param {*} other The other value to compare.
		     * @returns {boolean} Returns `true` if `value` is less than or equal to
		     *  `other`, else `false`.
		     * @see _.gte
		     * @example
		     *
		     * _.lte(1, 3);
		     * // => true
		     *
		     * _.lte(3, 3);
		     * // => true
		     *
		     * _.lte(3, 1);
		     * // => false
		     */
		    var lte = createRelationalOperation(function(value, other) {
		      return value <= other;
		    });

		    /**
		     * Converts `value` to an array.
		     *
		     * @static
		     * @since 0.1.0
		     * @memberOf _
		     * @category Lang
		     * @param {*} value The value to convert.
		     * @returns {Array} Returns the converted array.
		     * @example
		     *
		     * _.toArray({ 'a': 1, 'b': 2 });
		     * // => [1, 2]
		     *
		     * _.toArray('abc');
		     * // => ['a', 'b', 'c']
		     *
		     * _.toArray(1);
		     * // => []
		     *
		     * _.toArray(null);
		     * // => []
		     */
		    function toArray(value) {
		      if (!value) {
		        return [];
		      }
		      if (isArrayLike(value)) {
		        return isString(value) ? stringToArray(value) : copyArray(value);
		      }
		      if (symIterator && value[symIterator]) {
		        return iteratorToArray(value[symIterator]());
		      }
		      var tag = getTag(value),
		          func = tag == mapTag ? mapToArray : (tag == setTag ? setToArray : values);

		      return func(value);
		    }

		    /**
		     * Converts `value` to a finite number.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.12.0
		     * @category Lang
		     * @param {*} value The value to convert.
		     * @returns {number} Returns the converted number.
		     * @example
		     *
		     * _.toFinite(3.2);
		     * // => 3.2
		     *
		     * _.toFinite(Number.MIN_VALUE);
		     * // => 5e-324
		     *
		     * _.toFinite(Infinity);
		     * // => 1.7976931348623157e+308
		     *
		     * _.toFinite('3.2');
		     * // => 3.2
		     */
		    function toFinite(value) {
		      if (!value) {
		        return value === 0 ? value : 0;
		      }
		      value = toNumber(value);
		      if (value === INFINITY || value === -INFINITY) {
		        var sign = (value < 0 ? -1 : 1);
		        return sign * MAX_INTEGER;
		      }
		      return value === value ? value : 0;
		    }

		    /**
		     * Converts `value` to an integer.
		     *
		     * **Note:** This method is loosely based on
		     * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Lang
		     * @param {*} value The value to convert.
		     * @returns {number} Returns the converted integer.
		     * @example
		     *
		     * _.toInteger(3.2);
		     * // => 3
		     *
		     * _.toInteger(Number.MIN_VALUE);
		     * // => 0
		     *
		     * _.toInteger(Infinity);
		     * // => 1.7976931348623157e+308
		     *
		     * _.toInteger('3.2');
		     * // => 3
		     */
		    function toInteger(value) {
		      var result = toFinite(value),
		          remainder = result % 1;

		      return result === result ? (remainder ? result - remainder : result) : 0;
		    }

		    /**
		     * Converts `value` to an integer suitable for use as the length of an
		     * array-like object.
		     *
		     * **Note:** This method is based on
		     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Lang
		     * @param {*} value The value to convert.
		     * @returns {number} Returns the converted integer.
		     * @example
		     *
		     * _.toLength(3.2);
		     * // => 3
		     *
		     * _.toLength(Number.MIN_VALUE);
		     * // => 0
		     *
		     * _.toLength(Infinity);
		     * // => 4294967295
		     *
		     * _.toLength('3.2');
		     * // => 3
		     */
		    function toLength(value) {
		      return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
		    }

		    /**
		     * Converts `value` to a number.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Lang
		     * @param {*} value The value to process.
		     * @returns {number} Returns the number.
		     * @example
		     *
		     * _.toNumber(3.2);
		     * // => 3.2
		     *
		     * _.toNumber(Number.MIN_VALUE);
		     * // => 5e-324
		     *
		     * _.toNumber(Infinity);
		     * // => Infinity
		     *
		     * _.toNumber('3.2');
		     * // => 3.2
		     */
		    function toNumber(value) {
		      if (typeof value == 'number') {
		        return value;
		      }
		      if (isSymbol(value)) {
		        return NAN;
		      }
		      if (isObject(value)) {
		        var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
		        value = isObject(other) ? (other + '') : other;
		      }
		      if (typeof value != 'string') {
		        return value === 0 ? value : +value;
		      }
		      value = baseTrim(value);
		      var isBinary = reIsBinary.test(value);
		      return (isBinary || reIsOctal.test(value))
		        ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
		        : (reIsBadHex.test(value) ? NAN : +value);
		    }

		    /**
		     * Converts `value` to a plain object flattening inherited enumerable string
		     * keyed properties of `value` to own properties of the plain object.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category Lang
		     * @param {*} value The value to convert.
		     * @returns {Object} Returns the converted plain object.
		     * @example
		     *
		     * function Foo() {
		     *   this.b = 2;
		     * }
		     *
		     * Foo.prototype.c = 3;
		     *
		     * _.assign({ 'a': 1 }, new Foo);
		     * // => { 'a': 1, 'b': 2 }
		     *
		     * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
		     * // => { 'a': 1, 'b': 2, 'c': 3 }
		     */
		    function toPlainObject(value) {
		      return copyObject(value, keysIn(value));
		    }

		    /**
		     * Converts `value` to a safe integer. A safe integer can be compared and
		     * represented correctly.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Lang
		     * @param {*} value The value to convert.
		     * @returns {number} Returns the converted integer.
		     * @example
		     *
		     * _.toSafeInteger(3.2);
		     * // => 3
		     *
		     * _.toSafeInteger(Number.MIN_VALUE);
		     * // => 0
		     *
		     * _.toSafeInteger(Infinity);
		     * // => 9007199254740991
		     *
		     * _.toSafeInteger('3.2');
		     * // => 3
		     */
		    function toSafeInteger(value) {
		      return value
		        ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER)
		        : (value === 0 ? value : 0);
		    }

		    /**
		     * Converts `value` to a string. An empty string is returned for `null`
		     * and `undefined` values. The sign of `-0` is preserved.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Lang
		     * @param {*} value The value to convert.
		     * @returns {string} Returns the converted string.
		     * @example
		     *
		     * _.toString(null);
		     * // => ''
		     *
		     * _.toString(-0);
		     * // => '-0'
		     *
		     * _.toString([1, 2, 3]);
		     * // => '1,2,3'
		     */
		    function toString(value) {
		      return value == null ? '' : baseToString(value);
		    }

		    /*------------------------------------------------------------------------*/

		    /**
		     * Assigns own enumerable string keyed properties of source objects to the
		     * destination object. Source objects are applied from left to right.
		     * Subsequent sources overwrite property assignments of previous sources.
		     *
		     * **Note:** This method mutates `object` and is loosely based on
		     * [`Object.assign`](https://mdn.io/Object/assign).
		     *
		     * @static
		     * @memberOf _
		     * @since 0.10.0
		     * @category Object
		     * @param {Object} object The destination object.
		     * @param {...Object} [sources] The source objects.
		     * @returns {Object} Returns `object`.
		     * @see _.assignIn
		     * @example
		     *
		     * function Foo() {
		     *   this.a = 1;
		     * }
		     *
		     * function Bar() {
		     *   this.c = 3;
		     * }
		     *
		     * Foo.prototype.b = 2;
		     * Bar.prototype.d = 4;
		     *
		     * _.assign({ 'a': 0 }, new Foo, new Bar);
		     * // => { 'a': 1, 'c': 3 }
		     */
		    var assign = createAssigner(function(object, source) {
		      if (isPrototype(source) || isArrayLike(source)) {
		        copyObject(source, keys(source), object);
		        return;
		      }
		      for (var key in source) {
		        if (hasOwnProperty.call(source, key)) {
		          assignValue(object, key, source[key]);
		        }
		      }
		    });

		    /**
		     * This method is like `_.assign` except that it iterates over own and
		     * inherited source properties.
		     *
		     * **Note:** This method mutates `object`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @alias extend
		     * @category Object
		     * @param {Object} object The destination object.
		     * @param {...Object} [sources] The source objects.
		     * @returns {Object} Returns `object`.
		     * @see _.assign
		     * @example
		     *
		     * function Foo() {
		     *   this.a = 1;
		     * }
		     *
		     * function Bar() {
		     *   this.c = 3;
		     * }
		     *
		     * Foo.prototype.b = 2;
		     * Bar.prototype.d = 4;
		     *
		     * _.assignIn({ 'a': 0 }, new Foo, new Bar);
		     * // => { 'a': 1, 'b': 2, 'c': 3, 'd': 4 }
		     */
		    var assignIn = createAssigner(function(object, source) {
		      copyObject(source, keysIn(source), object);
		    });

		    /**
		     * This method is like `_.assignIn` except that it accepts `customizer`
		     * which is invoked to produce the assigned values. If `customizer` returns
		     * `undefined`, assignment is handled by the method instead. The `customizer`
		     * is invoked with five arguments: (objValue, srcValue, key, object, source).
		     *
		     * **Note:** This method mutates `object`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @alias extendWith
		     * @category Object
		     * @param {Object} object The destination object.
		     * @param {...Object} sources The source objects.
		     * @param {Function} [customizer] The function to customize assigned values.
		     * @returns {Object} Returns `object`.
		     * @see _.assignWith
		     * @example
		     *
		     * function customizer(objValue, srcValue) {
		     *   return _.isUndefined(objValue) ? srcValue : objValue;
		     * }
		     *
		     * var defaults = _.partialRight(_.assignInWith, customizer);
		     *
		     * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
		     * // => { 'a': 1, 'b': 2 }
		     */
		    var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
		      copyObject(source, keysIn(source), object, customizer);
		    });

		    /**
		     * This method is like `_.assign` except that it accepts `customizer`
		     * which is invoked to produce the assigned values. If `customizer` returns
		     * `undefined`, assignment is handled by the method instead. The `customizer`
		     * is invoked with five arguments: (objValue, srcValue, key, object, source).
		     *
		     * **Note:** This method mutates `object`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Object
		     * @param {Object} object The destination object.
		     * @param {...Object} sources The source objects.
		     * @param {Function} [customizer] The function to customize assigned values.
		     * @returns {Object} Returns `object`.
		     * @see _.assignInWith
		     * @example
		     *
		     * function customizer(objValue, srcValue) {
		     *   return _.isUndefined(objValue) ? srcValue : objValue;
		     * }
		     *
		     * var defaults = _.partialRight(_.assignWith, customizer);
		     *
		     * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
		     * // => { 'a': 1, 'b': 2 }
		     */
		    var assignWith = createAssigner(function(object, source, srcIndex, customizer) {
		      copyObject(source, keys(source), object, customizer);
		    });

		    /**
		     * Creates an array of values corresponding to `paths` of `object`.
		     *
		     * @static
		     * @memberOf _
		     * @since 1.0.0
		     * @category Object
		     * @param {Object} object The object to iterate over.
		     * @param {...(string|string[])} [paths] The property paths to pick.
		     * @returns {Array} Returns the picked values.
		     * @example
		     *
		     * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
		     *
		     * _.at(object, ['a[0].b.c', 'a[1]']);
		     * // => [3, 4]
		     */
		    var at = flatRest(baseAt);

		    /**
		     * Creates an object that inherits from the `prototype` object. If a
		     * `properties` object is given, its own enumerable string keyed properties
		     * are assigned to the created object.
		     *
		     * @static
		     * @memberOf _
		     * @since 2.3.0
		     * @category Object
		     * @param {Object} prototype The object to inherit from.
		     * @param {Object} [properties] The properties to assign to the object.
		     * @returns {Object} Returns the new object.
		     * @example
		     *
		     * function Shape() {
		     *   this.x = 0;
		     *   this.y = 0;
		     * }
		     *
		     * function Circle() {
		     *   Shape.call(this);
		     * }
		     *
		     * Circle.prototype = _.create(Shape.prototype, {
		     *   'constructor': Circle
		     * });
		     *
		     * var circle = new Circle;
		     * circle instanceof Circle;
		     * // => true
		     *
		     * circle instanceof Shape;
		     * // => true
		     */
		    function create(prototype, properties) {
		      var result = baseCreate(prototype);
		      return properties == null ? result : baseAssign(result, properties);
		    }

		    /**
		     * Assigns own and inherited enumerable string keyed properties of source
		     * objects to the destination object for all destination properties that
		     * resolve to `undefined`. Source objects are applied from left to right.
		     * Once a property is set, additional values of the same property are ignored.
		     *
		     * **Note:** This method mutates `object`.
		     *
		     * @static
		     * @since 0.1.0
		     * @memberOf _
		     * @category Object
		     * @param {Object} object The destination object.
		     * @param {...Object} [sources] The source objects.
		     * @returns {Object} Returns `object`.
		     * @see _.defaultsDeep
		     * @example
		     *
		     * _.defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
		     * // => { 'a': 1, 'b': 2 }
		     */
		    var defaults = baseRest(function(object, sources) {
		      object = Object(object);

		      var index = -1;
		      var length = sources.length;
		      var guard = length > 2 ? sources[2] : undefined$1;

		      if (guard && isIterateeCall(sources[0], sources[1], guard)) {
		        length = 1;
		      }

		      while (++index < length) {
		        var source = sources[index];
		        var props = keysIn(source);
		        var propsIndex = -1;
		        var propsLength = props.length;

		        while (++propsIndex < propsLength) {
		          var key = props[propsIndex];
		          var value = object[key];

		          if (value === undefined$1 ||
		              (eq(value, objectProto[key]) && !hasOwnProperty.call(object, key))) {
		            object[key] = source[key];
		          }
		        }
		      }

		      return object;
		    });

		    /**
		     * This method is like `_.defaults` except that it recursively assigns
		     * default properties.
		     *
		     * **Note:** This method mutates `object`.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.10.0
		     * @category Object
		     * @param {Object} object The destination object.
		     * @param {...Object} [sources] The source objects.
		     * @returns {Object} Returns `object`.
		     * @see _.defaults
		     * @example
		     *
		     * _.defaultsDeep({ 'a': { 'b': 2 } }, { 'a': { 'b': 1, 'c': 3 } });
		     * // => { 'a': { 'b': 2, 'c': 3 } }
		     */
		    var defaultsDeep = baseRest(function(args) {
		      args.push(undefined$1, customDefaultsMerge);
		      return apply(mergeWith, undefined$1, args);
		    });

		    /**
		     * This method is like `_.find` except that it returns the key of the first
		     * element `predicate` returns truthy for instead of the element itself.
		     *
		     * @static
		     * @memberOf _
		     * @since 1.1.0
		     * @category Object
		     * @param {Object} object The object to inspect.
		     * @param {Function} [predicate=_.identity] The function invoked per iteration.
		     * @returns {string|undefined} Returns the key of the matched element,
		     *  else `undefined`.
		     * @example
		     *
		     * var users = {
		     *   'barney':  { 'age': 36, 'active': true },
		     *   'fred':    { 'age': 40, 'active': false },
		     *   'pebbles': { 'age': 1,  'active': true }
		     * };
		     *
		     * _.findKey(users, function(o) { return o.age < 40; });
		     * // => 'barney' (iteration order is not guaranteed)
		     *
		     * // The `_.matches` iteratee shorthand.
		     * _.findKey(users, { 'age': 1, 'active': true });
		     * // => 'pebbles'
		     *
		     * // The `_.matchesProperty` iteratee shorthand.
		     * _.findKey(users, ['active', false]);
		     * // => 'fred'
		     *
		     * // The `_.property` iteratee shorthand.
		     * _.findKey(users, 'active');
		     * // => 'barney'
		     */
		    function findKey(object, predicate) {
		      return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
		    }

		    /**
		     * This method is like `_.findKey` except that it iterates over elements of
		     * a collection in the opposite order.
		     *
		     * @static
		     * @memberOf _
		     * @since 2.0.0
		     * @category Object
		     * @param {Object} object The object to inspect.
		     * @param {Function} [predicate=_.identity] The function invoked per iteration.
		     * @returns {string|undefined} Returns the key of the matched element,
		     *  else `undefined`.
		     * @example
		     *
		     * var users = {
		     *   'barney':  { 'age': 36, 'active': true },
		     *   'fred':    { 'age': 40, 'active': false },
		     *   'pebbles': { 'age': 1,  'active': true }
		     * };
		     *
		     * _.findLastKey(users, function(o) { return o.age < 40; });
		     * // => returns 'pebbles' assuming `_.findKey` returns 'barney'
		     *
		     * // The `_.matches` iteratee shorthand.
		     * _.findLastKey(users, { 'age': 36, 'active': true });
		     * // => 'barney'
		     *
		     * // The `_.matchesProperty` iteratee shorthand.
		     * _.findLastKey(users, ['active', false]);
		     * // => 'fred'
		     *
		     * // The `_.property` iteratee shorthand.
		     * _.findLastKey(users, 'active');
		     * // => 'pebbles'
		     */
		    function findLastKey(object, predicate) {
		      return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
		    }

		    /**
		     * Iterates over own and inherited enumerable string keyed properties of an
		     * object and invokes `iteratee` for each property. The iteratee is invoked
		     * with three arguments: (value, key, object). Iteratee functions may exit
		     * iteration early by explicitly returning `false`.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.3.0
		     * @category Object
		     * @param {Object} object The object to iterate over.
		     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
		     * @returns {Object} Returns `object`.
		     * @see _.forInRight
		     * @example
		     *
		     * function Foo() {
		     *   this.a = 1;
		     *   this.b = 2;
		     * }
		     *
		     * Foo.prototype.c = 3;
		     *
		     * _.forIn(new Foo, function(value, key) {
		     *   console.log(key);
		     * });
		     * // => Logs 'a', 'b', then 'c' (iteration order is not guaranteed).
		     */
		    function forIn(object, iteratee) {
		      return object == null
		        ? object
		        : baseFor(object, getIteratee(iteratee, 3), keysIn);
		    }

		    /**
		     * This method is like `_.forIn` except that it iterates over properties of
		     * `object` in the opposite order.
		     *
		     * @static
		     * @memberOf _
		     * @since 2.0.0
		     * @category Object
		     * @param {Object} object The object to iterate over.
		     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
		     * @returns {Object} Returns `object`.
		     * @see _.forIn
		     * @example
		     *
		     * function Foo() {
		     *   this.a = 1;
		     *   this.b = 2;
		     * }
		     *
		     * Foo.prototype.c = 3;
		     *
		     * _.forInRight(new Foo, function(value, key) {
		     *   console.log(key);
		     * });
		     * // => Logs 'c', 'b', then 'a' assuming `_.forIn` logs 'a', 'b', then 'c'.
		     */
		    function forInRight(object, iteratee) {
		      return object == null
		        ? object
		        : baseForRight(object, getIteratee(iteratee, 3), keysIn);
		    }

		    /**
		     * Iterates over own enumerable string keyed properties of an object and
		     * invokes `iteratee` for each property. The iteratee is invoked with three
		     * arguments: (value, key, object). Iteratee functions may exit iteration
		     * early by explicitly returning `false`.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.3.0
		     * @category Object
		     * @param {Object} object The object to iterate over.
		     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
		     * @returns {Object} Returns `object`.
		     * @see _.forOwnRight
		     * @example
		     *
		     * function Foo() {
		     *   this.a = 1;
		     *   this.b = 2;
		     * }
		     *
		     * Foo.prototype.c = 3;
		     *
		     * _.forOwn(new Foo, function(value, key) {
		     *   console.log(key);
		     * });
		     * // => Logs 'a' then 'b' (iteration order is not guaranteed).
		     */
		    function forOwn(object, iteratee) {
		      return object && baseForOwn(object, getIteratee(iteratee, 3));
		    }

		    /**
		     * This method is like `_.forOwn` except that it iterates over properties of
		     * `object` in the opposite order.
		     *
		     * @static
		     * @memberOf _
		     * @since 2.0.0
		     * @category Object
		     * @param {Object} object The object to iterate over.
		     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
		     * @returns {Object} Returns `object`.
		     * @see _.forOwn
		     * @example
		     *
		     * function Foo() {
		     *   this.a = 1;
		     *   this.b = 2;
		     * }
		     *
		     * Foo.prototype.c = 3;
		     *
		     * _.forOwnRight(new Foo, function(value, key) {
		     *   console.log(key);
		     * });
		     * // => Logs 'b' then 'a' assuming `_.forOwn` logs 'a' then 'b'.
		     */
		    function forOwnRight(object, iteratee) {
		      return object && baseForOwnRight(object, getIteratee(iteratee, 3));
		    }

		    /**
		     * Creates an array of function property names from own enumerable properties
		     * of `object`.
		     *
		     * @static
		     * @since 0.1.0
		     * @memberOf _
		     * @category Object
		     * @param {Object} object The object to inspect.
		     * @returns {Array} Returns the function names.
		     * @see _.functionsIn
		     * @example
		     *
		     * function Foo() {
		     *   this.a = _.constant('a');
		     *   this.b = _.constant('b');
		     * }
		     *
		     * Foo.prototype.c = _.constant('c');
		     *
		     * _.functions(new Foo);
		     * // => ['a', 'b']
		     */
		    function functions(object) {
		      return object == null ? [] : baseFunctions(object, keys(object));
		    }

		    /**
		     * Creates an array of function property names from own and inherited
		     * enumerable properties of `object`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Object
		     * @param {Object} object The object to inspect.
		     * @returns {Array} Returns the function names.
		     * @see _.functions
		     * @example
		     *
		     * function Foo() {
		     *   this.a = _.constant('a');
		     *   this.b = _.constant('b');
		     * }
		     *
		     * Foo.prototype.c = _.constant('c');
		     *
		     * _.functionsIn(new Foo);
		     * // => ['a', 'b', 'c']
		     */
		    function functionsIn(object) {
		      return object == null ? [] : baseFunctions(object, keysIn(object));
		    }

		    /**
		     * Gets the value at `path` of `object`. If the resolved value is
		     * `undefined`, the `defaultValue` is returned in its place.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.7.0
		     * @category Object
		     * @param {Object} object The object to query.
		     * @param {Array|string} path The path of the property to get.
		     * @param {*} [defaultValue] The value returned for `undefined` resolved values.
		     * @returns {*} Returns the resolved value.
		     * @example
		     *
		     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
		     *
		     * _.get(object, 'a[0].b.c');
		     * // => 3
		     *
		     * _.get(object, ['a', '0', 'b', 'c']);
		     * // => 3
		     *
		     * _.get(object, 'a.b.c', 'default');
		     * // => 'default'
		     */
		    function get(object, path, defaultValue) {
		      var result = object == null ? undefined$1 : baseGet(object, path);
		      return result === undefined$1 ? defaultValue : result;
		    }

		    /**
		     * Checks if `path` is a direct property of `object`.
		     *
		     * @static
		     * @since 0.1.0
		     * @memberOf _
		     * @category Object
		     * @param {Object} object The object to query.
		     * @param {Array|string} path The path to check.
		     * @returns {boolean} Returns `true` if `path` exists, else `false`.
		     * @example
		     *
		     * var object = { 'a': { 'b': 2 } };
		     * var other = _.create({ 'a': _.create({ 'b': 2 }) });
		     *
		     * _.has(object, 'a');
		     * // => true
		     *
		     * _.has(object, 'a.b');
		     * // => true
		     *
		     * _.has(object, ['a', 'b']);
		     * // => true
		     *
		     * _.has(other, 'a');
		     * // => false
		     */
		    function has(object, path) {
		      return object != null && hasPath(object, path, baseHas);
		    }

		    /**
		     * Checks if `path` is a direct or inherited property of `object`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Object
		     * @param {Object} object The object to query.
		     * @param {Array|string} path The path to check.
		     * @returns {boolean} Returns `true` if `path` exists, else `false`.
		     * @example
		     *
		     * var object = _.create({ 'a': _.create({ 'b': 2 }) });
		     *
		     * _.hasIn(object, 'a');
		     * // => true
		     *
		     * _.hasIn(object, 'a.b');
		     * // => true
		     *
		     * _.hasIn(object, ['a', 'b']);
		     * // => true
		     *
		     * _.hasIn(object, 'b');
		     * // => false
		     */
		    function hasIn(object, path) {
		      return object != null && hasPath(object, path, baseHasIn);
		    }

		    /**
		     * Creates an object composed of the inverted keys and values of `object`.
		     * If `object` contains duplicate values, subsequent values overwrite
		     * property assignments of previous values.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.7.0
		     * @category Object
		     * @param {Object} object The object to invert.
		     * @returns {Object} Returns the new inverted object.
		     * @example
		     *
		     * var object = { 'a': 1, 'b': 2, 'c': 1 };
		     *
		     * _.invert(object);
		     * // => { '1': 'c', '2': 'b' }
		     */
		    var invert = createInverter(function(result, value, key) {
		      if (value != null &&
		          typeof value.toString != 'function') {
		        value = nativeObjectToString.call(value);
		      }

		      result[value] = key;
		    }, constant(identity));

		    /**
		     * This method is like `_.invert` except that the inverted object is generated
		     * from the results of running each element of `object` thru `iteratee`. The
		     * corresponding inverted value of each inverted key is an array of keys
		     * responsible for generating the inverted value. The iteratee is invoked
		     * with one argument: (value).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.1.0
		     * @category Object
		     * @param {Object} object The object to invert.
		     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
		     * @returns {Object} Returns the new inverted object.
		     * @example
		     *
		     * var object = { 'a': 1, 'b': 2, 'c': 1 };
		     *
		     * _.invertBy(object);
		     * // => { '1': ['a', 'c'], '2': ['b'] }
		     *
		     * _.invertBy(object, function(value) {
		     *   return 'group' + value;
		     * });
		     * // => { 'group1': ['a', 'c'], 'group2': ['b'] }
		     */
		    var invertBy = createInverter(function(result, value, key) {
		      if (value != null &&
		          typeof value.toString != 'function') {
		        value = nativeObjectToString.call(value);
		      }

		      if (hasOwnProperty.call(result, value)) {
		        result[value].push(key);
		      } else {
		        result[value] = [key];
		      }
		    }, getIteratee);

		    /**
		     * Invokes the method at `path` of `object`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Object
		     * @param {Object} object The object to query.
		     * @param {Array|string} path The path of the method to invoke.
		     * @param {...*} [args] The arguments to invoke the method with.
		     * @returns {*} Returns the result of the invoked method.
		     * @example
		     *
		     * var object = { 'a': [{ 'b': { 'c': [1, 2, 3, 4] } }] };
		     *
		     * _.invoke(object, 'a[0].b.c.slice', 1, 3);
		     * // => [2, 3]
		     */
		    var invoke = baseRest(baseInvoke);

		    /**
		     * Creates an array of the own enumerable property names of `object`.
		     *
		     * **Note:** Non-object values are coerced to objects. See the
		     * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
		     * for more details.
		     *
		     * @static
		     * @since 0.1.0
		     * @memberOf _
		     * @category Object
		     * @param {Object} object The object to query.
		     * @returns {Array} Returns the array of property names.
		     * @example
		     *
		     * function Foo() {
		     *   this.a = 1;
		     *   this.b = 2;
		     * }
		     *
		     * Foo.prototype.c = 3;
		     *
		     * _.keys(new Foo);
		     * // => ['a', 'b'] (iteration order is not guaranteed)
		     *
		     * _.keys('hi');
		     * // => ['0', '1']
		     */
		    function keys(object) {
		      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
		    }

		    /**
		     * Creates an array of the own and inherited enumerable property names of `object`.
		     *
		     * **Note:** Non-object values are coerced to objects.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category Object
		     * @param {Object} object The object to query.
		     * @returns {Array} Returns the array of property names.
		     * @example
		     *
		     * function Foo() {
		     *   this.a = 1;
		     *   this.b = 2;
		     * }
		     *
		     * Foo.prototype.c = 3;
		     *
		     * _.keysIn(new Foo);
		     * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
		     */
		    function keysIn(object) {
		      return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
		    }

		    /**
		     * The opposite of `_.mapValues`; this method creates an object with the
		     * same values as `object` and keys generated by running each own enumerable
		     * string keyed property of `object` thru `iteratee`. The iteratee is invoked
		     * with three arguments: (value, key, object).
		     *
		     * @static
		     * @memberOf _
		     * @since 3.8.0
		     * @category Object
		     * @param {Object} object The object to iterate over.
		     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
		     * @returns {Object} Returns the new mapped object.
		     * @see _.mapValues
		     * @example
		     *
		     * _.mapKeys({ 'a': 1, 'b': 2 }, function(value, key) {
		     *   return key + value;
		     * });
		     * // => { 'a1': 1, 'b2': 2 }
		     */
		    function mapKeys(object, iteratee) {
		      var result = {};
		      iteratee = getIteratee(iteratee, 3);

		      baseForOwn(object, function(value, key, object) {
		        baseAssignValue(result, iteratee(value, key, object), value);
		      });
		      return result;
		    }

		    /**
		     * Creates an object with the same keys as `object` and values generated
		     * by running each own enumerable string keyed property of `object` thru
		     * `iteratee`. The iteratee is invoked with three arguments:
		     * (value, key, object).
		     *
		     * @static
		     * @memberOf _
		     * @since 2.4.0
		     * @category Object
		     * @param {Object} object The object to iterate over.
		     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
		     * @returns {Object} Returns the new mapped object.
		     * @see _.mapKeys
		     * @example
		     *
		     * var users = {
		     *   'fred':    { 'user': 'fred',    'age': 40 },
		     *   'pebbles': { 'user': 'pebbles', 'age': 1 }
		     * };
		     *
		     * _.mapValues(users, function(o) { return o.age; });
		     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
		     *
		     * // The `_.property` iteratee shorthand.
		     * _.mapValues(users, 'age');
		     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
		     */
		    function mapValues(object, iteratee) {
		      var result = {};
		      iteratee = getIteratee(iteratee, 3);

		      baseForOwn(object, function(value, key, object) {
		        baseAssignValue(result, key, iteratee(value, key, object));
		      });
		      return result;
		    }

		    /**
		     * This method is like `_.assign` except that it recursively merges own and
		     * inherited enumerable string keyed properties of source objects into the
		     * destination object. Source properties that resolve to `undefined` are
		     * skipped if a destination value exists. Array and plain object properties
		     * are merged recursively. Other objects and value types are overridden by
		     * assignment. Source objects are applied from left to right. Subsequent
		     * sources overwrite property assignments of previous sources.
		     *
		     * **Note:** This method mutates `object`.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.5.0
		     * @category Object
		     * @param {Object} object The destination object.
		     * @param {...Object} [sources] The source objects.
		     * @returns {Object} Returns `object`.
		     * @example
		     *
		     * var object = {
		     *   'a': [{ 'b': 2 }, { 'd': 4 }]
		     * };
		     *
		     * var other = {
		     *   'a': [{ 'c': 3 }, { 'e': 5 }]
		     * };
		     *
		     * _.merge(object, other);
		     * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
		     */
		    var merge = createAssigner(function(object, source, srcIndex) {
		      baseMerge(object, source, srcIndex);
		    });

		    /**
		     * This method is like `_.merge` except that it accepts `customizer` which
		     * is invoked to produce the merged values of the destination and source
		     * properties. If `customizer` returns `undefined`, merging is handled by the
		     * method instead. The `customizer` is invoked with six arguments:
		     * (objValue, srcValue, key, object, source, stack).
		     *
		     * **Note:** This method mutates `object`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Object
		     * @param {Object} object The destination object.
		     * @param {...Object} sources The source objects.
		     * @param {Function} customizer The function to customize assigned values.
		     * @returns {Object} Returns `object`.
		     * @example
		     *
		     * function customizer(objValue, srcValue) {
		     *   if (_.isArray(objValue)) {
		     *     return objValue.concat(srcValue);
		     *   }
		     * }
		     *
		     * var object = { 'a': [1], 'b': [2] };
		     * var other = { 'a': [3], 'b': [4] };
		     *
		     * _.mergeWith(object, other, customizer);
		     * // => { 'a': [1, 3], 'b': [2, 4] }
		     */
		    var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
		      baseMerge(object, source, srcIndex, customizer);
		    });

		    /**
		     * The opposite of `_.pick`; this method creates an object composed of the
		     * own and inherited enumerable property paths of `object` that are not omitted.
		     *
		     * **Note:** This method is considerably slower than `_.pick`.
		     *
		     * @static
		     * @since 0.1.0
		     * @memberOf _
		     * @category Object
		     * @param {Object} object The source object.
		     * @param {...(string|string[])} [paths] The property paths to omit.
		     * @returns {Object} Returns the new object.
		     * @example
		     *
		     * var object = { 'a': 1, 'b': '2', 'c': 3 };
		     *
		     * _.omit(object, ['a', 'c']);
		     * // => { 'b': '2' }
		     */
		    var omit = flatRest(function(object, paths) {
		      var result = {};
		      if (object == null) {
		        return result;
		      }
		      var isDeep = false;
		      paths = arrayMap(paths, function(path) {
		        path = castPath(path, object);
		        isDeep || (isDeep = path.length > 1);
		        return path;
		      });
		      copyObject(object, getAllKeysIn(object), result);
		      if (isDeep) {
		        result = baseClone(result, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
		      }
		      var length = paths.length;
		      while (length--) {
		        baseUnset(result, paths[length]);
		      }
		      return result;
		    });

		    /**
		     * The opposite of `_.pickBy`; this method creates an object composed of
		     * the own and inherited enumerable string keyed properties of `object` that
		     * `predicate` doesn't return truthy for. The predicate is invoked with two
		     * arguments: (value, key).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Object
		     * @param {Object} object The source object.
		     * @param {Function} [predicate=_.identity] The function invoked per property.
		     * @returns {Object} Returns the new object.
		     * @example
		     *
		     * var object = { 'a': 1, 'b': '2', 'c': 3 };
		     *
		     * _.omitBy(object, _.isNumber);
		     * // => { 'b': '2' }
		     */
		    function omitBy(object, predicate) {
		      return pickBy(object, negate(getIteratee(predicate)));
		    }

		    /**
		     * Creates an object composed of the picked `object` properties.
		     *
		     * @static
		     * @since 0.1.0
		     * @memberOf _
		     * @category Object
		     * @param {Object} object The source object.
		     * @param {...(string|string[])} [paths] The property paths to pick.
		     * @returns {Object} Returns the new object.
		     * @example
		     *
		     * var object = { 'a': 1, 'b': '2', 'c': 3 };
		     *
		     * _.pick(object, ['a', 'c']);
		     * // => { 'a': 1, 'c': 3 }
		     */
		    var pick = flatRest(function(object, paths) {
		      return object == null ? {} : basePick(object, paths);
		    });

		    /**
		     * Creates an object composed of the `object` properties `predicate` returns
		     * truthy for. The predicate is invoked with two arguments: (value, key).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Object
		     * @param {Object} object The source object.
		     * @param {Function} [predicate=_.identity] The function invoked per property.
		     * @returns {Object} Returns the new object.
		     * @example
		     *
		     * var object = { 'a': 1, 'b': '2', 'c': 3 };
		     *
		     * _.pickBy(object, _.isNumber);
		     * // => { 'a': 1, 'c': 3 }
		     */
		    function pickBy(object, predicate) {
		      if (object == null) {
		        return {};
		      }
		      var props = arrayMap(getAllKeysIn(object), function(prop) {
		        return [prop];
		      });
		      predicate = getIteratee(predicate);
		      return basePickBy(object, props, function(value, path) {
		        return predicate(value, path[0]);
		      });
		    }

		    /**
		     * This method is like `_.get` except that if the resolved value is a
		     * function it's invoked with the `this` binding of its parent object and
		     * its result is returned.
		     *
		     * @static
		     * @since 0.1.0
		     * @memberOf _
		     * @category Object
		     * @param {Object} object The object to query.
		     * @param {Array|string} path The path of the property to resolve.
		     * @param {*} [defaultValue] The value returned for `undefined` resolved values.
		     * @returns {*} Returns the resolved value.
		     * @example
		     *
		     * var object = { 'a': [{ 'b': { 'c1': 3, 'c2': _.constant(4) } }] };
		     *
		     * _.result(object, 'a[0].b.c1');
		     * // => 3
		     *
		     * _.result(object, 'a[0].b.c2');
		     * // => 4
		     *
		     * _.result(object, 'a[0].b.c3', 'default');
		     * // => 'default'
		     *
		     * _.result(object, 'a[0].b.c3', _.constant('default'));
		     * // => 'default'
		     */
		    function result(object, path, defaultValue) {
		      path = castPath(path, object);

		      var index = -1,
		          length = path.length;

		      // Ensure the loop is entered when path is empty.
		      if (!length) {
		        length = 1;
		        object = undefined$1;
		      }
		      while (++index < length) {
		        var value = object == null ? undefined$1 : object[toKey(path[index])];
		        if (value === undefined$1) {
		          index = length;
		          value = defaultValue;
		        }
		        object = isFunction(value) ? value.call(object) : value;
		      }
		      return object;
		    }

		    /**
		     * Sets the value at `path` of `object`. If a portion of `path` doesn't exist,
		     * it's created. Arrays are created for missing index properties while objects
		     * are created for all other missing properties. Use `_.setWith` to customize
		     * `path` creation.
		     *
		     * **Note:** This method mutates `object`.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.7.0
		     * @category Object
		     * @param {Object} object The object to modify.
		     * @param {Array|string} path The path of the property to set.
		     * @param {*} value The value to set.
		     * @returns {Object} Returns `object`.
		     * @example
		     *
		     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
		     *
		     * _.set(object, 'a[0].b.c', 4);
		     * console.log(object.a[0].b.c);
		     * // => 4
		     *
		     * _.set(object, ['x', '0', 'y', 'z'], 5);
		     * console.log(object.x[0].y.z);
		     * // => 5
		     */
		    function set(object, path, value) {
		      return object == null ? object : baseSet(object, path, value);
		    }

		    /**
		     * This method is like `_.set` except that it accepts `customizer` which is
		     * invoked to produce the objects of `path`.  If `customizer` returns `undefined`
		     * path creation is handled by the method instead. The `customizer` is invoked
		     * with three arguments: (nsValue, key, nsObject).
		     *
		     * **Note:** This method mutates `object`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Object
		     * @param {Object} object The object to modify.
		     * @param {Array|string} path The path of the property to set.
		     * @param {*} value The value to set.
		     * @param {Function} [customizer] The function to customize assigned values.
		     * @returns {Object} Returns `object`.
		     * @example
		     *
		     * var object = {};
		     *
		     * _.setWith(object, '[0][1]', 'a', Object);
		     * // => { '0': { '1': 'a' } }
		     */
		    function setWith(object, path, value, customizer) {
		      customizer = typeof customizer == 'function' ? customizer : undefined$1;
		      return object == null ? object : baseSet(object, path, value, customizer);
		    }

		    /**
		     * Creates an array of own enumerable string keyed-value pairs for `object`
		     * which can be consumed by `_.fromPairs`. If `object` is a map or set, its
		     * entries are returned.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @alias entries
		     * @category Object
		     * @param {Object} object The object to query.
		     * @returns {Array} Returns the key-value pairs.
		     * @example
		     *
		     * function Foo() {
		     *   this.a = 1;
		     *   this.b = 2;
		     * }
		     *
		     * Foo.prototype.c = 3;
		     *
		     * _.toPairs(new Foo);
		     * // => [['a', 1], ['b', 2]] (iteration order is not guaranteed)
		     */
		    var toPairs = createToPairs(keys);

		    /**
		     * Creates an array of own and inherited enumerable string keyed-value pairs
		     * for `object` which can be consumed by `_.fromPairs`. If `object` is a map
		     * or set, its entries are returned.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @alias entriesIn
		     * @category Object
		     * @param {Object} object The object to query.
		     * @returns {Array} Returns the key-value pairs.
		     * @example
		     *
		     * function Foo() {
		     *   this.a = 1;
		     *   this.b = 2;
		     * }
		     *
		     * Foo.prototype.c = 3;
		     *
		     * _.toPairsIn(new Foo);
		     * // => [['a', 1], ['b', 2], ['c', 3]] (iteration order is not guaranteed)
		     */
		    var toPairsIn = createToPairs(keysIn);

		    /**
		     * An alternative to `_.reduce`; this method transforms `object` to a new
		     * `accumulator` object which is the result of running each of its own
		     * enumerable string keyed properties thru `iteratee`, with each invocation
		     * potentially mutating the `accumulator` object. If `accumulator` is not
		     * provided, a new object with the same `[[Prototype]]` will be used. The
		     * iteratee is invoked with four arguments: (accumulator, value, key, object).
		     * Iteratee functions may exit iteration early by explicitly returning `false`.
		     *
		     * @static
		     * @memberOf _
		     * @since 1.3.0
		     * @category Object
		     * @param {Object} object The object to iterate over.
		     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
		     * @param {*} [accumulator] The custom accumulator value.
		     * @returns {*} Returns the accumulated value.
		     * @example
		     *
		     * _.transform([2, 3, 4], function(result, n) {
		     *   result.push(n *= n);
		     *   return n % 2 == 0;
		     * }, []);
		     * // => [4, 9]
		     *
		     * _.transform({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
		     *   (result[value] || (result[value] = [])).push(key);
		     * }, {});
		     * // => { '1': ['a', 'c'], '2': ['b'] }
		     */
		    function transform(object, iteratee, accumulator) {
		      var isArr = isArray(object),
		          isArrLike = isArr || isBuffer(object) || isTypedArray(object);

		      iteratee = getIteratee(iteratee, 4);
		      if (accumulator == null) {
		        var Ctor = object && object.constructor;
		        if (isArrLike) {
		          accumulator = isArr ? new Ctor : [];
		        }
		        else if (isObject(object)) {
		          accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};
		        }
		        else {
		          accumulator = {};
		        }
		      }
		      (isArrLike ? arrayEach : baseForOwn)(object, function(value, index, object) {
		        return iteratee(accumulator, value, index, object);
		      });
		      return accumulator;
		    }

		    /**
		     * Removes the property at `path` of `object`.
		     *
		     * **Note:** This method mutates `object`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Object
		     * @param {Object} object The object to modify.
		     * @param {Array|string} path The path of the property to unset.
		     * @returns {boolean} Returns `true` if the property is deleted, else `false`.
		     * @example
		     *
		     * var object = { 'a': [{ 'b': { 'c': 7 } }] };
		     * _.unset(object, 'a[0].b.c');
		     * // => true
		     *
		     * console.log(object);
		     * // => { 'a': [{ 'b': {} }] };
		     *
		     * _.unset(object, ['a', '0', 'b', 'c']);
		     * // => true
		     *
		     * console.log(object);
		     * // => { 'a': [{ 'b': {} }] };
		     */
		    function unset(object, path) {
		      return object == null ? true : baseUnset(object, path);
		    }

		    /**
		     * This method is like `_.set` except that accepts `updater` to produce the
		     * value to set. Use `_.updateWith` to customize `path` creation. The `updater`
		     * is invoked with one argument: (value).
		     *
		     * **Note:** This method mutates `object`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.6.0
		     * @category Object
		     * @param {Object} object The object to modify.
		     * @param {Array|string} path The path of the property to set.
		     * @param {Function} updater The function to produce the updated value.
		     * @returns {Object} Returns `object`.
		     * @example
		     *
		     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
		     *
		     * _.update(object, 'a[0].b.c', function(n) { return n * n; });
		     * console.log(object.a[0].b.c);
		     * // => 9
		     *
		     * _.update(object, 'x[0].y.z', function(n) { return n ? n + 1 : 0; });
		     * console.log(object.x[0].y.z);
		     * // => 0
		     */
		    function update(object, path, updater) {
		      return object == null ? object : baseUpdate(object, path, castFunction(updater));
		    }

		    /**
		     * This method is like `_.update` except that it accepts `customizer` which is
		     * invoked to produce the objects of `path`.  If `customizer` returns `undefined`
		     * path creation is handled by the method instead. The `customizer` is invoked
		     * with three arguments: (nsValue, key, nsObject).
		     *
		     * **Note:** This method mutates `object`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.6.0
		     * @category Object
		     * @param {Object} object The object to modify.
		     * @param {Array|string} path The path of the property to set.
		     * @param {Function} updater The function to produce the updated value.
		     * @param {Function} [customizer] The function to customize assigned values.
		     * @returns {Object} Returns `object`.
		     * @example
		     *
		     * var object = {};
		     *
		     * _.updateWith(object, '[0][1]', _.constant('a'), Object);
		     * // => { '0': { '1': 'a' } }
		     */
		    function updateWith(object, path, updater, customizer) {
		      customizer = typeof customizer == 'function' ? customizer : undefined$1;
		      return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);
		    }

		    /**
		     * Creates an array of the own enumerable string keyed property values of `object`.
		     *
		     * **Note:** Non-object values are coerced to objects.
		     *
		     * @static
		     * @since 0.1.0
		     * @memberOf _
		     * @category Object
		     * @param {Object} object The object to query.
		     * @returns {Array} Returns the array of property values.
		     * @example
		     *
		     * function Foo() {
		     *   this.a = 1;
		     *   this.b = 2;
		     * }
		     *
		     * Foo.prototype.c = 3;
		     *
		     * _.values(new Foo);
		     * // => [1, 2] (iteration order is not guaranteed)
		     *
		     * _.values('hi');
		     * // => ['h', 'i']
		     */
		    function values(object) {
		      return object == null ? [] : baseValues(object, keys(object));
		    }

		    /**
		     * Creates an array of the own and inherited enumerable string keyed property
		     * values of `object`.
		     *
		     * **Note:** Non-object values are coerced to objects.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category Object
		     * @param {Object} object The object to query.
		     * @returns {Array} Returns the array of property values.
		     * @example
		     *
		     * function Foo() {
		     *   this.a = 1;
		     *   this.b = 2;
		     * }
		     *
		     * Foo.prototype.c = 3;
		     *
		     * _.valuesIn(new Foo);
		     * // => [1, 2, 3] (iteration order is not guaranteed)
		     */
		    function valuesIn(object) {
		      return object == null ? [] : baseValues(object, keysIn(object));
		    }

		    /*------------------------------------------------------------------------*/

		    /**
		     * Clamps `number` within the inclusive `lower` and `upper` bounds.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Number
		     * @param {number} number The number to clamp.
		     * @param {number} [lower] The lower bound.
		     * @param {number} upper The upper bound.
		     * @returns {number} Returns the clamped number.
		     * @example
		     *
		     * _.clamp(-10, -5, 5);
		     * // => -5
		     *
		     * _.clamp(10, -5, 5);
		     * // => 5
		     */
		    function clamp(number, lower, upper) {
		      if (upper === undefined$1) {
		        upper = lower;
		        lower = undefined$1;
		      }
		      if (upper !== undefined$1) {
		        upper = toNumber(upper);
		        upper = upper === upper ? upper : 0;
		      }
		      if (lower !== undefined$1) {
		        lower = toNumber(lower);
		        lower = lower === lower ? lower : 0;
		      }
		      return baseClamp(toNumber(number), lower, upper);
		    }

		    /**
		     * Checks if `n` is between `start` and up to, but not including, `end`. If
		     * `end` is not specified, it's set to `start` with `start` then set to `0`.
		     * If `start` is greater than `end` the params are swapped to support
		     * negative ranges.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.3.0
		     * @category Number
		     * @param {number} number The number to check.
		     * @param {number} [start=0] The start of the range.
		     * @param {number} end The end of the range.
		     * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
		     * @see _.range, _.rangeRight
		     * @example
		     *
		     * _.inRange(3, 2, 4);
		     * // => true
		     *
		     * _.inRange(4, 8);
		     * // => true
		     *
		     * _.inRange(4, 2);
		     * // => false
		     *
		     * _.inRange(2, 2);
		     * // => false
		     *
		     * _.inRange(1.2, 2);
		     * // => true
		     *
		     * _.inRange(5.2, 4);
		     * // => false
		     *
		     * _.inRange(-3, -2, -6);
		     * // => true
		     */
		    function inRange(number, start, end) {
		      start = toFinite(start);
		      if (end === undefined$1) {
		        end = start;
		        start = 0;
		      } else {
		        end = toFinite(end);
		      }
		      number = toNumber(number);
		      return baseInRange(number, start, end);
		    }

		    /**
		     * Produces a random number between the inclusive `lower` and `upper` bounds.
		     * If only one argument is provided a number between `0` and the given number
		     * is returned. If `floating` is `true`, or either `lower` or `upper` are
		     * floats, a floating-point number is returned instead of an integer.
		     *
		     * **Note:** JavaScript follows the IEEE-754 standard for resolving
		     * floating-point values which can produce unexpected results.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.7.0
		     * @category Number
		     * @param {number} [lower=0] The lower bound.
		     * @param {number} [upper=1] The upper bound.
		     * @param {boolean} [floating] Specify returning a floating-point number.
		     * @returns {number} Returns the random number.
		     * @example
		     *
		     * _.random(0, 5);
		     * // => an integer between 0 and 5
		     *
		     * _.random(5);
		     * // => also an integer between 0 and 5
		     *
		     * _.random(5, true);
		     * // => a floating-point number between 0 and 5
		     *
		     * _.random(1.2, 5.2);
		     * // => a floating-point number between 1.2 and 5.2
		     */
		    function random(lower, upper, floating) {
		      if (floating && typeof floating != 'boolean' && isIterateeCall(lower, upper, floating)) {
		        upper = floating = undefined$1;
		      }
		      if (floating === undefined$1) {
		        if (typeof upper == 'boolean') {
		          floating = upper;
		          upper = undefined$1;
		        }
		        else if (typeof lower == 'boolean') {
		          floating = lower;
		          lower = undefined$1;
		        }
		      }
		      if (lower === undefined$1 && upper === undefined$1) {
		        lower = 0;
		        upper = 1;
		      }
		      else {
		        lower = toFinite(lower);
		        if (upper === undefined$1) {
		          upper = lower;
		          lower = 0;
		        } else {
		          upper = toFinite(upper);
		        }
		      }
		      if (lower > upper) {
		        var temp = lower;
		        lower = upper;
		        upper = temp;
		      }
		      if (floating || lower % 1 || upper % 1) {
		        var rand = nativeRandom();
		        return nativeMin(lower + (rand * (upper - lower + freeParseFloat('1e-' + ((rand + '').length - 1)))), upper);
		      }
		      return baseRandom(lower, upper);
		    }

		    /*------------------------------------------------------------------------*/

		    /**
		     * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category String
		     * @param {string} [string=''] The string to convert.
		     * @returns {string} Returns the camel cased string.
		     * @example
		     *
		     * _.camelCase('Foo Bar');
		     * // => 'fooBar'
		     *
		     * _.camelCase('--foo-bar--');
		     * // => 'fooBar'
		     *
		     * _.camelCase('__FOO_BAR__');
		     * // => 'fooBar'
		     */
		    var camelCase = createCompounder(function(result, word, index) {
		      word = word.toLowerCase();
		      return result + (index ? capitalize(word) : word);
		    });

		    /**
		     * Converts the first character of `string` to upper case and the remaining
		     * to lower case.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category String
		     * @param {string} [string=''] The string to capitalize.
		     * @returns {string} Returns the capitalized string.
		     * @example
		     *
		     * _.capitalize('FRED');
		     * // => 'Fred'
		     */
		    function capitalize(string) {
		      return upperFirst(toString(string).toLowerCase());
		    }

		    /**
		     * Deburrs `string` by converting
		     * [Latin-1 Supplement](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)
		     * and [Latin Extended-A](https://en.wikipedia.org/wiki/Latin_Extended-A)
		     * letters to basic Latin letters and removing
		     * [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category String
		     * @param {string} [string=''] The string to deburr.
		     * @returns {string} Returns the deburred string.
		     * @example
		     *
		     * _.deburr('dj vu');
		     * // => 'deja vu'
		     */
		    function deburr(string) {
		      string = toString(string);
		      return string && string.replace(reLatin, deburrLetter).replace(reComboMark, '');
		    }

		    /**
		     * Checks if `string` ends with the given target string.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category String
		     * @param {string} [string=''] The string to inspect.
		     * @param {string} [target] The string to search for.
		     * @param {number} [position=string.length] The position to search up to.
		     * @returns {boolean} Returns `true` if `string` ends with `target`,
		     *  else `false`.
		     * @example
		     *
		     * _.endsWith('abc', 'c');
		     * // => true
		     *
		     * _.endsWith('abc', 'b');
		     * // => false
		     *
		     * _.endsWith('abc', 'b', 2);
		     * // => true
		     */
		    function endsWith(string, target, position) {
		      string = toString(string);
		      target = baseToString(target);

		      var length = string.length;
		      position = position === undefined$1
		        ? length
		        : baseClamp(toInteger(position), 0, length);

		      var end = position;
		      position -= target.length;
		      return position >= 0 && string.slice(position, end) == target;
		    }

		    /**
		     * Converts the characters "&", "<", ">", '"', and "'" in `string` to their
		     * corresponding HTML entities.
		     *
		     * **Note:** No other characters are escaped. To escape additional
		     * characters use a third-party library like [_he_](https://mths.be/he).
		     *
		     * Though the ">" character is escaped for symmetry, characters like
		     * ">" and "/" don't need escaping in HTML and have no special meaning
		     * unless they're part of a tag or unquoted attribute value. See
		     * [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)
		     * (under "semi-related fun fact") for more details.
		     *
		     * When working with HTML you should always
		     * [quote attribute values](http://wonko.com/post/html-escaping) to reduce
		     * XSS vectors.
		     *
		     * @static
		     * @since 0.1.0
		     * @memberOf _
		     * @category String
		     * @param {string} [string=''] The string to escape.
		     * @returns {string} Returns the escaped string.
		     * @example
		     *
		     * _.escape('fred, barney, & pebbles');
		     * // => 'fred, barney, &amp; pebbles'
		     */
		    function escape(string) {
		      string = toString(string);
		      return (string && reHasUnescapedHtml.test(string))
		        ? string.replace(reUnescapedHtml, escapeHtmlChar)
		        : string;
		    }

		    /**
		     * Escapes the `RegExp` special characters "^", "$", "\", ".", "*", "+",
		     * "?", "(", ")", "[", "]", "{", "}", and "|" in `string`.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category String
		     * @param {string} [string=''] The string to escape.
		     * @returns {string} Returns the escaped string.
		     * @example
		     *
		     * _.escapeRegExp('[lodash](https://lodash.com/)');
		     * // => '\[lodash\]\(https://lodash\.com/\)'
		     */
		    function escapeRegExp(string) {
		      string = toString(string);
		      return (string && reHasRegExpChar.test(string))
		        ? string.replace(reRegExpChar, '\\$&')
		        : string;
		    }

		    /**
		     * Converts `string` to
		     * [kebab case](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles).
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category String
		     * @param {string} [string=''] The string to convert.
		     * @returns {string} Returns the kebab cased string.
		     * @example
		     *
		     * _.kebabCase('Foo Bar');
		     * // => 'foo-bar'
		     *
		     * _.kebabCase('fooBar');
		     * // => 'foo-bar'
		     *
		     * _.kebabCase('__FOO_BAR__');
		     * // => 'foo-bar'
		     */
		    var kebabCase = createCompounder(function(result, word, index) {
		      return result + (index ? '-' : '') + word.toLowerCase();
		    });

		    /**
		     * Converts `string`, as space separated words, to lower case.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category String
		     * @param {string} [string=''] The string to convert.
		     * @returns {string} Returns the lower cased string.
		     * @example
		     *
		     * _.lowerCase('--Foo-Bar--');
		     * // => 'foo bar'
		     *
		     * _.lowerCase('fooBar');
		     * // => 'foo bar'
		     *
		     * _.lowerCase('__FOO_BAR__');
		     * // => 'foo bar'
		     */
		    var lowerCase = createCompounder(function(result, word, index) {
		      return result + (index ? ' ' : '') + word.toLowerCase();
		    });

		    /**
		     * Converts the first character of `string` to lower case.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category String
		     * @param {string} [string=''] The string to convert.
		     * @returns {string} Returns the converted string.
		     * @example
		     *
		     * _.lowerFirst('Fred');
		     * // => 'fred'
		     *
		     * _.lowerFirst('FRED');
		     * // => 'fRED'
		     */
		    var lowerFirst = createCaseFirst('toLowerCase');

		    /**
		     * Pads `string` on the left and right sides if it's shorter than `length`.
		     * Padding characters are truncated if they can't be evenly divided by `length`.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category String
		     * @param {string} [string=''] The string to pad.
		     * @param {number} [length=0] The padding length.
		     * @param {string} [chars=' '] The string used as padding.
		     * @returns {string} Returns the padded string.
		     * @example
		     *
		     * _.pad('abc', 8);
		     * // => '  abc   '
		     *
		     * _.pad('abc', 8, '_-');
		     * // => '_-abc_-_'
		     *
		     * _.pad('abc', 3);
		     * // => 'abc'
		     */
		    function pad(string, length, chars) {
		      string = toString(string);
		      length = toInteger(length);

		      var strLength = length ? stringSize(string) : 0;
		      if (!length || strLength >= length) {
		        return string;
		      }
		      var mid = (length - strLength) / 2;
		      return (
		        createPadding(nativeFloor(mid), chars) +
		        string +
		        createPadding(nativeCeil(mid), chars)
		      );
		    }

		    /**
		     * Pads `string` on the right side if it's shorter than `length`. Padding
		     * characters are truncated if they exceed `length`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category String
		     * @param {string} [string=''] The string to pad.
		     * @param {number} [length=0] The padding length.
		     * @param {string} [chars=' '] The string used as padding.
		     * @returns {string} Returns the padded string.
		     * @example
		     *
		     * _.padEnd('abc', 6);
		     * // => 'abc   '
		     *
		     * _.padEnd('abc', 6, '_-');
		     * // => 'abc_-_'
		     *
		     * _.padEnd('abc', 3);
		     * // => 'abc'
		     */
		    function padEnd(string, length, chars) {
		      string = toString(string);
		      length = toInteger(length);

		      var strLength = length ? stringSize(string) : 0;
		      return (length && strLength < length)
		        ? (string + createPadding(length - strLength, chars))
		        : string;
		    }

		    /**
		     * Pads `string` on the left side if it's shorter than `length`. Padding
		     * characters are truncated if they exceed `length`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category String
		     * @param {string} [string=''] The string to pad.
		     * @param {number} [length=0] The padding length.
		     * @param {string} [chars=' '] The string used as padding.
		     * @returns {string} Returns the padded string.
		     * @example
		     *
		     * _.padStart('abc', 6);
		     * // => '   abc'
		     *
		     * _.padStart('abc', 6, '_-');
		     * // => '_-_abc'
		     *
		     * _.padStart('abc', 3);
		     * // => 'abc'
		     */
		    function padStart(string, length, chars) {
		      string = toString(string);
		      length = toInteger(length);

		      var strLength = length ? stringSize(string) : 0;
		      return (length && strLength < length)
		        ? (createPadding(length - strLength, chars) + string)
		        : string;
		    }

		    /**
		     * Converts `string` to an integer of the specified radix. If `radix` is
		     * `undefined` or `0`, a `radix` of `10` is used unless `value` is a
		     * hexadecimal, in which case a `radix` of `16` is used.
		     *
		     * **Note:** This method aligns with the
		     * [ES5 implementation](https://es5.github.io/#x15.1.2.2) of `parseInt`.
		     *
		     * @static
		     * @memberOf _
		     * @since 1.1.0
		     * @category String
		     * @param {string} string The string to convert.
		     * @param {number} [radix=10] The radix to interpret `value` by.
		     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
		     * @returns {number} Returns the converted integer.
		     * @example
		     *
		     * _.parseInt('08');
		     * // => 8
		     *
		     * _.map(['6', '08', '10'], _.parseInt);
		     * // => [6, 8, 10]
		     */
		    function parseInt(string, radix, guard) {
		      if (guard || radix == null) {
		        radix = 0;
		      } else if (radix) {
		        radix = +radix;
		      }
		      return nativeParseInt(toString(string).replace(reTrimStart, ''), radix || 0);
		    }

		    /**
		     * Repeats the given string `n` times.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category String
		     * @param {string} [string=''] The string to repeat.
		     * @param {number} [n=1] The number of times to repeat the string.
		     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
		     * @returns {string} Returns the repeated string.
		     * @example
		     *
		     * _.repeat('*', 3);
		     * // => '***'
		     *
		     * _.repeat('abc', 2);
		     * // => 'abcabc'
		     *
		     * _.repeat('abc', 0);
		     * // => ''
		     */
		    function repeat(string, n, guard) {
		      if ((guard ? isIterateeCall(string, n, guard) : n === undefined$1)) {
		        n = 1;
		      } else {
		        n = toInteger(n);
		      }
		      return baseRepeat(toString(string), n);
		    }

		    /**
		     * Replaces matches for `pattern` in `string` with `replacement`.
		     *
		     * **Note:** This method is based on
		     * [`String#replace`](https://mdn.io/String/replace).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category String
		     * @param {string} [string=''] The string to modify.
		     * @param {RegExp|string} pattern The pattern to replace.
		     * @param {Function|string} replacement The match replacement.
		     * @returns {string} Returns the modified string.
		     * @example
		     *
		     * _.replace('Hi Fred', 'Fred', 'Barney');
		     * // => 'Hi Barney'
		     */
		    function replace() {
		      var args = arguments,
		          string = toString(args[0]);

		      return args.length < 3 ? string : string.replace(args[1], args[2]);
		    }

		    /**
		     * Converts `string` to
		     * [snake case](https://en.wikipedia.org/wiki/Snake_case).
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category String
		     * @param {string} [string=''] The string to convert.
		     * @returns {string} Returns the snake cased string.
		     * @example
		     *
		     * _.snakeCase('Foo Bar');
		     * // => 'foo_bar'
		     *
		     * _.snakeCase('fooBar');
		     * // => 'foo_bar'
		     *
		     * _.snakeCase('--FOO-BAR--');
		     * // => 'foo_bar'
		     */
		    var snakeCase = createCompounder(function(result, word, index) {
		      return result + (index ? '_' : '') + word.toLowerCase();
		    });

		    /**
		     * Splits `string` by `separator`.
		     *
		     * **Note:** This method is based on
		     * [`String#split`](https://mdn.io/String/split).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category String
		     * @param {string} [string=''] The string to split.
		     * @param {RegExp|string} separator The separator pattern to split by.
		     * @param {number} [limit] The length to truncate results to.
		     * @returns {Array} Returns the string segments.
		     * @example
		     *
		     * _.split('a-b-c', '-', 2);
		     * // => ['a', 'b']
		     */
		    function split(string, separator, limit) {
		      if (limit && typeof limit != 'number' && isIterateeCall(string, separator, limit)) {
		        separator = limit = undefined$1;
		      }
		      limit = limit === undefined$1 ? MAX_ARRAY_LENGTH : limit >>> 0;
		      if (!limit) {
		        return [];
		      }
		      string = toString(string);
		      if (string && (
		            typeof separator == 'string' ||
		            (separator != null && !isRegExp(separator))
		          )) {
		        separator = baseToString(separator);
		        if (!separator && hasUnicode(string)) {
		          return castSlice(stringToArray(string), 0, limit);
		        }
		      }
		      return string.split(separator, limit);
		    }

		    /**
		     * Converts `string` to
		     * [start case](https://en.wikipedia.org/wiki/Letter_case#Stylistic_or_specialised_usage).
		     *
		     * @static
		     * @memberOf _
		     * @since 3.1.0
		     * @category String
		     * @param {string} [string=''] The string to convert.
		     * @returns {string} Returns the start cased string.
		     * @example
		     *
		     * _.startCase('--foo-bar--');
		     * // => 'Foo Bar'
		     *
		     * _.startCase('fooBar');
		     * // => 'Foo Bar'
		     *
		     * _.startCase('__FOO_BAR__');
		     * // => 'FOO BAR'
		     */
		    var startCase = createCompounder(function(result, word, index) {
		      return result + (index ? ' ' : '') + upperFirst(word);
		    });

		    /**
		     * Checks if `string` starts with the given target string.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category String
		     * @param {string} [string=''] The string to inspect.
		     * @param {string} [target] The string to search for.
		     * @param {number} [position=0] The position to search from.
		     * @returns {boolean} Returns `true` if `string` starts with `target`,
		     *  else `false`.
		     * @example
		     *
		     * _.startsWith('abc', 'a');
		     * // => true
		     *
		     * _.startsWith('abc', 'b');
		     * // => false
		     *
		     * _.startsWith('abc', 'b', 1);
		     * // => true
		     */
		    function startsWith(string, target, position) {
		      string = toString(string);
		      position = position == null
		        ? 0
		        : baseClamp(toInteger(position), 0, string.length);

		      target = baseToString(target);
		      return string.slice(position, position + target.length) == target;
		    }

		    /**
		     * Creates a compiled template function that can interpolate data properties
		     * in "interpolate" delimiters, HTML-escape interpolated data properties in
		     * "escape" delimiters, and execute JavaScript in "evaluate" delimiters. Data
		     * properties may be accessed as free variables in the template. If a setting
		     * object is given, it takes precedence over `_.templateSettings` values.
		     *
		     * **Note:** In the development build `_.template` utilizes
		     * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)
		     * for easier debugging.
		     *
		     * For more information on precompiling templates see
		     * [lodash's custom builds documentation](https://lodash.com/custom-builds).
		     *
		     * For more information on Chrome extension sandboxes see
		     * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).
		     *
		     * @static
		     * @since 0.1.0
		     * @memberOf _
		     * @category String
		     * @param {string} [string=''] The template string.
		     * @param {Object} [options={}] The options object.
		     * @param {RegExp} [options.escape=_.templateSettings.escape]
		     *  The HTML "escape" delimiter.
		     * @param {RegExp} [options.evaluate=_.templateSettings.evaluate]
		     *  The "evaluate" delimiter.
		     * @param {Object} [options.imports=_.templateSettings.imports]
		     *  An object to import into the template as free variables.
		     * @param {RegExp} [options.interpolate=_.templateSettings.interpolate]
		     *  The "interpolate" delimiter.
		     * @param {string} [options.sourceURL='lodash.templateSources[n]']
		     *  The sourceURL of the compiled template.
		     * @param {string} [options.variable='obj']
		     *  The data object variable name.
		     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
		     * @returns {Function} Returns the compiled template function.
		     * @example
		     *
		     * // Use the "interpolate" delimiter to create a compiled template.
		     * var compiled = _.template('hello <%= user %>!');
		     * compiled({ 'user': 'fred' });
		     * // => 'hello fred!'
		     *
		     * // Use the HTML "escape" delimiter to escape data property values.
		     * var compiled = _.template('<b><%- value %></b>');
		     * compiled({ 'value': '<script>' });
		     * // => '<b>&lt;script&gt;</b>'
		     *
		     * // Use the "evaluate" delimiter to execute JavaScript and generate HTML.
		     * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');
		     * compiled({ 'users': ['fred', 'barney'] });
		     * // => '<li>fred</li><li>barney</li>'
		     *
		     * // Use the internal `print` function in "evaluate" delimiters.
		     * var compiled = _.template('<% print("hello " + user); %>!');
		     * compiled({ 'user': 'barney' });
		     * // => 'hello barney!'
		     *
		     * // Use the ES template literal delimiter as an "interpolate" delimiter.
		     * // Disable support by replacing the "interpolate" delimiter.
		     * var compiled = _.template('hello ${ user }!');
		     * compiled({ 'user': 'pebbles' });
		     * // => 'hello pebbles!'
		     *
		     * // Use backslashes to treat delimiters as plain text.
		     * var compiled = _.template('<%= "\\<%- value %\\>" %>');
		     * compiled({ 'value': 'ignored' });
		     * // => '<%- value %>'
		     *
		     * // Use the `imports` option to import `jQuery` as `jq`.
		     * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';
		     * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });
		     * compiled({ 'users': ['fred', 'barney'] });
		     * // => '<li>fred</li><li>barney</li>'
		     *
		     * // Use the `sourceURL` option to specify a custom sourceURL for the template.
		     * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });
		     * compiled(data);
		     * // => Find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector.
		     *
		     * // Use the `variable` option to ensure a with-statement isn't used in the compiled template.
		     * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });
		     * compiled.source;
		     * // => function(data) {
		     * //   var __t, __p = '';
		     * //   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';
		     * //   return __p;
		     * // }
		     *
		     * // Use custom template delimiters.
		     * _.templateSettings.interpolate = /{{([\s\S]+?)}}/g;
		     * var compiled = _.template('hello {{ user }}!');
		     * compiled({ 'user': 'mustache' });
		     * // => 'hello mustache!'
		     *
		     * // Use the `source` property to inline compiled templates for meaningful
		     * // line numbers in error messages and stack traces.
		     * fs.writeFileSync(path.join(process.cwd(), 'jst.js'), '\
		     *   var JST = {\
		     *     "main": ' + _.template(mainText).source + '\
		     *   };\
		     * ');
		     */
		    function template(string, options, guard) {
		      // Based on John Resig's `tmpl` implementation
		      // (http://ejohn.org/blog/javascript-micro-templating/)
		      // and Laura Doktorova's doT.js (https://github.com/olado/doT).
		      var settings = lodash.templateSettings;

		      if (guard && isIterateeCall(string, options, guard)) {
		        options = undefined$1;
		      }
		      string = toString(string);
		      options = assignInWith({}, options, settings, customDefaultsAssignIn);

		      var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn),
		          importsKeys = keys(imports),
		          importsValues = baseValues(imports, importsKeys);

		      var isEscaping,
		          isEvaluating,
		          index = 0,
		          interpolate = options.interpolate || reNoMatch,
		          source = "__p += '";

		      // Compile the regexp to match each delimiter.
		      var reDelimiters = RegExp(
		        (options.escape || reNoMatch).source + '|' +
		        interpolate.source + '|' +
		        (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +
		        (options.evaluate || reNoMatch).source + '|$'
		      , 'g');

		      // Use a sourceURL for easier debugging.
		      // The sourceURL gets injected into the source that's eval-ed, so be careful
		      // to normalize all kinds of whitespace, so e.g. newlines (and unicode versions of it) can't sneak in
		      // and escape the comment, thus injecting code that gets evaled.
		      var sourceURL = '//# sourceURL=' +
		        (hasOwnProperty.call(options, 'sourceURL')
		          ? (options.sourceURL + '').replace(/\s/g, ' ')
		          : ('lodash.templateSources[' + (++templateCounter) + ']')
		        ) + '\n';

		      string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
		        interpolateValue || (interpolateValue = esTemplateValue);

		        // Escape characters that can't be included in string literals.
		        source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);

		        // Replace delimiters with snippets.
		        if (escapeValue) {
		          isEscaping = true;
		          source += "' +\n__e(" + escapeValue + ") +\n'";
		        }
		        if (evaluateValue) {
		          isEvaluating = true;
		          source += "';\n" + evaluateValue + ";\n__p += '";
		        }
		        if (interpolateValue) {
		          source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
		        }
		        index = offset + match.length;

		        // The JS engine embedded in Adobe products needs `match` returned in
		        // order to produce the correct `offset` value.
		        return match;
		      });

		      source += "';\n";

		      // If `variable` is not specified wrap a with-statement around the generated
		      // code to add the data object to the top of the scope chain.
		      var variable = hasOwnProperty.call(options, 'variable') && options.variable;
		      if (!variable) {
		        source = 'with (obj) {\n' + source + '\n}\n';
		      }
		      // Throw an error if a forbidden character was found in `variable`, to prevent
		      // potential command injection attacks.
		      else if (reForbiddenIdentifierChars.test(variable)) {
		        throw new Error(INVALID_TEMPL_VAR_ERROR_TEXT);
		      }

		      // Cleanup code by stripping empty strings.
		      source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)
		        .replace(reEmptyStringMiddle, '$1')
		        .replace(reEmptyStringTrailing, '$1;');

		      // Frame code as the function body.
		      source = 'function(' + (variable || 'obj') + ') {\n' +
		        (variable
		          ? ''
		          : 'obj || (obj = {});\n'
		        ) +
		        "var __t, __p = ''" +
		        (isEscaping
		           ? ', __e = _.escape'
		           : ''
		        ) +
		        (isEvaluating
		          ? ', __j = Array.prototype.join;\n' +
		            "function print() { __p += __j.call(arguments, '') }\n"
		          : ';\n'
		        ) +
		        source +
		        'return __p\n}';

		      var result = attempt(function() {
		        return Function(importsKeys, sourceURL + 'return ' + source)
		          .apply(undefined$1, importsValues);
		      });

		      // Provide the compiled function's source by its `toString` method or
		      // the `source` property as a convenience for inlining compiled templates.
		      result.source = source;
		      if (isError(result)) {
		        throw result;
		      }
		      return result;
		    }

		    /**
		     * Converts `string`, as a whole, to lower case just like
		     * [String#toLowerCase](https://mdn.io/toLowerCase).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category String
		     * @param {string} [string=''] The string to convert.
		     * @returns {string} Returns the lower cased string.
		     * @example
		     *
		     * _.toLower('--Foo-Bar--');
		     * // => '--foo-bar--'
		     *
		     * _.toLower('fooBar');
		     * // => 'foobar'
		     *
		     * _.toLower('__FOO_BAR__');
		     * // => '__foo_bar__'
		     */
		    function toLower(value) {
		      return toString(value).toLowerCase();
		    }

		    /**
		     * Converts `string`, as a whole, to upper case just like
		     * [String#toUpperCase](https://mdn.io/toUpperCase).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category String
		     * @param {string} [string=''] The string to convert.
		     * @returns {string} Returns the upper cased string.
		     * @example
		     *
		     * _.toUpper('--foo-bar--');
		     * // => '--FOO-BAR--'
		     *
		     * _.toUpper('fooBar');
		     * // => 'FOOBAR'
		     *
		     * _.toUpper('__foo_bar__');
		     * // => '__FOO_BAR__'
		     */
		    function toUpper(value) {
		      return toString(value).toUpperCase();
		    }

		    /**
		     * Removes leading and trailing whitespace or specified characters from `string`.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category String
		     * @param {string} [string=''] The string to trim.
		     * @param {string} [chars=whitespace] The characters to trim.
		     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
		     * @returns {string} Returns the trimmed string.
		     * @example
		     *
		     * _.trim('  abc  ');
		     * // => 'abc'
		     *
		     * _.trim('-_-abc-_-', '_-');
		     * // => 'abc'
		     *
		     * _.map(['  foo  ', '  bar  '], _.trim);
		     * // => ['foo', 'bar']
		     */
		    function trim(string, chars, guard) {
		      string = toString(string);
		      if (string && (guard || chars === undefined$1)) {
		        return baseTrim(string);
		      }
		      if (!string || !(chars = baseToString(chars))) {
		        return string;
		      }
		      var strSymbols = stringToArray(string),
		          chrSymbols = stringToArray(chars),
		          start = charsStartIndex(strSymbols, chrSymbols),
		          end = charsEndIndex(strSymbols, chrSymbols) + 1;

		      return castSlice(strSymbols, start, end).join('');
		    }

		    /**
		     * Removes trailing whitespace or specified characters from `string`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category String
		     * @param {string} [string=''] The string to trim.
		     * @param {string} [chars=whitespace] The characters to trim.
		     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
		     * @returns {string} Returns the trimmed string.
		     * @example
		     *
		     * _.trimEnd('  abc  ');
		     * // => '  abc'
		     *
		     * _.trimEnd('-_-abc-_-', '_-');
		     * // => '-_-abc'
		     */
		    function trimEnd(string, chars, guard) {
		      string = toString(string);
		      if (string && (guard || chars === undefined$1)) {
		        return string.slice(0, trimmedEndIndex(string) + 1);
		      }
		      if (!string || !(chars = baseToString(chars))) {
		        return string;
		      }
		      var strSymbols = stringToArray(string),
		          end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;

		      return castSlice(strSymbols, 0, end).join('');
		    }

		    /**
		     * Removes leading whitespace or specified characters from `string`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category String
		     * @param {string} [string=''] The string to trim.
		     * @param {string} [chars=whitespace] The characters to trim.
		     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
		     * @returns {string} Returns the trimmed string.
		     * @example
		     *
		     * _.trimStart('  abc  ');
		     * // => 'abc  '
		     *
		     * _.trimStart('-_-abc-_-', '_-');
		     * // => 'abc-_-'
		     */
		    function trimStart(string, chars, guard) {
		      string = toString(string);
		      if (string && (guard || chars === undefined$1)) {
		        return string.replace(reTrimStart, '');
		      }
		      if (!string || !(chars = baseToString(chars))) {
		        return string;
		      }
		      var strSymbols = stringToArray(string),
		          start = charsStartIndex(strSymbols, stringToArray(chars));

		      return castSlice(strSymbols, start).join('');
		    }

		    /**
		     * Truncates `string` if it's longer than the given maximum string length.
		     * The last characters of the truncated string are replaced with the omission
		     * string which defaults to "...".
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category String
		     * @param {string} [string=''] The string to truncate.
		     * @param {Object} [options={}] The options object.
		     * @param {number} [options.length=30] The maximum string length.
		     * @param {string} [options.omission='...'] The string to indicate text is omitted.
		     * @param {RegExp|string} [options.separator] The separator pattern to truncate to.
		     * @returns {string} Returns the truncated string.
		     * @example
		     *
		     * _.truncate('hi-diddly-ho there, neighborino');
		     * // => 'hi-diddly-ho there, neighbo...'
		     *
		     * _.truncate('hi-diddly-ho there, neighborino', {
		     *   'length': 24,
		     *   'separator': ' '
		     * });
		     * // => 'hi-diddly-ho there,...'
		     *
		     * _.truncate('hi-diddly-ho there, neighborino', {
		     *   'length': 24,
		     *   'separator': /,? +/
		     * });
		     * // => 'hi-diddly-ho there...'
		     *
		     * _.truncate('hi-diddly-ho there, neighborino', {
		     *   'omission': ' [...]'
		     * });
		     * // => 'hi-diddly-ho there, neig [...]'
		     */
		    function truncate(string, options) {
		      var length = DEFAULT_TRUNC_LENGTH,
		          omission = DEFAULT_TRUNC_OMISSION;

		      if (isObject(options)) {
		        var separator = 'separator' in options ? options.separator : separator;
		        length = 'length' in options ? toInteger(options.length) : length;
		        omission = 'omission' in options ? baseToString(options.omission) : omission;
		      }
		      string = toString(string);

		      var strLength = string.length;
		      if (hasUnicode(string)) {
		        var strSymbols = stringToArray(string);
		        strLength = strSymbols.length;
		      }
		      if (length >= strLength) {
		        return string;
		      }
		      var end = length - stringSize(omission);
		      if (end < 1) {
		        return omission;
		      }
		      var result = strSymbols
		        ? castSlice(strSymbols, 0, end).join('')
		        : string.slice(0, end);

		      if (separator === undefined$1) {
		        return result + omission;
		      }
		      if (strSymbols) {
		        end += (result.length - end);
		      }
		      if (isRegExp(separator)) {
		        if (string.slice(end).search(separator)) {
		          var match,
		              substring = result;

		          if (!separator.global) {
		            separator = RegExp(separator.source, toString(reFlags.exec(separator)) + 'g');
		          }
		          separator.lastIndex = 0;
		          while ((match = separator.exec(substring))) {
		            var newEnd = match.index;
		          }
		          result = result.slice(0, newEnd === undefined$1 ? end : newEnd);
		        }
		      } else if (string.indexOf(baseToString(separator), end) != end) {
		        var index = result.lastIndexOf(separator);
		        if (index > -1) {
		          result = result.slice(0, index);
		        }
		      }
		      return result + omission;
		    }

		    /**
		     * The inverse of `_.escape`; this method converts the HTML entities
		     * `&amp;`, `&lt;`, `&gt;`, `&quot;`, and `&#39;` in `string` to
		     * their corresponding characters.
		     *
		     * **Note:** No other HTML entities are unescaped. To unescape additional
		     * HTML entities use a third-party library like [_he_](https://mths.be/he).
		     *
		     * @static
		     * @memberOf _
		     * @since 0.6.0
		     * @category String
		     * @param {string} [string=''] The string to unescape.
		     * @returns {string} Returns the unescaped string.
		     * @example
		     *
		     * _.unescape('fred, barney, &amp; pebbles');
		     * // => 'fred, barney, & pebbles'
		     */
		    function unescape(string) {
		      string = toString(string);
		      return (string && reHasEscapedHtml.test(string))
		        ? string.replace(reEscapedHtml, unescapeHtmlChar)
		        : string;
		    }

		    /**
		     * Converts `string`, as space separated words, to upper case.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category String
		     * @param {string} [string=''] The string to convert.
		     * @returns {string} Returns the upper cased string.
		     * @example
		     *
		     * _.upperCase('--foo-bar');
		     * // => 'FOO BAR'
		     *
		     * _.upperCase('fooBar');
		     * // => 'FOO BAR'
		     *
		     * _.upperCase('__foo_bar__');
		     * // => 'FOO BAR'
		     */
		    var upperCase = createCompounder(function(result, word, index) {
		      return result + (index ? ' ' : '') + word.toUpperCase();
		    });

		    /**
		     * Converts the first character of `string` to upper case.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category String
		     * @param {string} [string=''] The string to convert.
		     * @returns {string} Returns the converted string.
		     * @example
		     *
		     * _.upperFirst('fred');
		     * // => 'Fred'
		     *
		     * _.upperFirst('FRED');
		     * // => 'FRED'
		     */
		    var upperFirst = createCaseFirst('toUpperCase');

		    /**
		     * Splits `string` into an array of its words.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category String
		     * @param {string} [string=''] The string to inspect.
		     * @param {RegExp|string} [pattern] The pattern to match words.
		     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
		     * @returns {Array} Returns the words of `string`.
		     * @example
		     *
		     * _.words('fred, barney, & pebbles');
		     * // => ['fred', 'barney', 'pebbles']
		     *
		     * _.words('fred, barney, & pebbles', /[^, ]+/g);
		     * // => ['fred', 'barney', '&', 'pebbles']
		     */
		    function words(string, pattern, guard) {
		      string = toString(string);
		      pattern = guard ? undefined$1 : pattern;

		      if (pattern === undefined$1) {
		        return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
		      }
		      return string.match(pattern) || [];
		    }

		    /*------------------------------------------------------------------------*/

		    /**
		     * Attempts to invoke `func`, returning either the result or the caught error
		     * object. Any additional arguments are provided to `func` when it's invoked.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category Util
		     * @param {Function} func The function to attempt.
		     * @param {...*} [args] The arguments to invoke `func` with.
		     * @returns {*} Returns the `func` result or error object.
		     * @example
		     *
		     * // Avoid throwing errors for invalid selectors.
		     * var elements = _.attempt(function(selector) {
		     *   return document.querySelectorAll(selector);
		     * }, '>_>');
		     *
		     * if (_.isError(elements)) {
		     *   elements = [];
		     * }
		     */
		    var attempt = baseRest(function(func, args) {
		      try {
		        return apply(func, undefined$1, args);
		      } catch (e) {
		        return isError(e) ? e : new Error(e);
		      }
		    });

		    /**
		     * Binds methods of an object to the object itself, overwriting the existing
		     * method.
		     *
		     * **Note:** This method doesn't set the "length" property of bound functions.
		     *
		     * @static
		     * @since 0.1.0
		     * @memberOf _
		     * @category Util
		     * @param {Object} object The object to bind and assign the bound methods to.
		     * @param {...(string|string[])} methodNames The object method names to bind.
		     * @returns {Object} Returns `object`.
		     * @example
		     *
		     * var view = {
		     *   'label': 'docs',
		     *   'click': function() {
		     *     console.log('clicked ' + this.label);
		     *   }
		     * };
		     *
		     * _.bindAll(view, ['click']);
		     * jQuery(element).on('click', view.click);
		     * // => Logs 'clicked docs' when clicked.
		     */
		    var bindAll = flatRest(function(object, methodNames) {
		      arrayEach(methodNames, function(key) {
		        key = toKey(key);
		        baseAssignValue(object, key, bind(object[key], object));
		      });
		      return object;
		    });

		    /**
		     * Creates a function that iterates over `pairs` and invokes the corresponding
		     * function of the first predicate to return truthy. The predicate-function
		     * pairs are invoked with the `this` binding and arguments of the created
		     * function.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Util
		     * @param {Array} pairs The predicate-function pairs.
		     * @returns {Function} Returns the new composite function.
		     * @example
		     *
		     * var func = _.cond([
		     *   [_.matches({ 'a': 1 }),           _.constant('matches A')],
		     *   [_.conforms({ 'b': _.isNumber }), _.constant('matches B')],
		     *   [_.stubTrue,                      _.constant('no match')]
		     * ]);
		     *
		     * func({ 'a': 1, 'b': 2 });
		     * // => 'matches A'
		     *
		     * func({ 'a': 0, 'b': 1 });
		     * // => 'matches B'
		     *
		     * func({ 'a': '1', 'b': '2' });
		     * // => 'no match'
		     */
		    function cond(pairs) {
		      var length = pairs == null ? 0 : pairs.length,
		          toIteratee = getIteratee();

		      pairs = !length ? [] : arrayMap(pairs, function(pair) {
		        if (typeof pair[1] != 'function') {
		          throw new TypeError(FUNC_ERROR_TEXT);
		        }
		        return [toIteratee(pair[0]), pair[1]];
		      });

		      return baseRest(function(args) {
		        var index = -1;
		        while (++index < length) {
		          var pair = pairs[index];
		          if (apply(pair[0], this, args)) {
		            return apply(pair[1], this, args);
		          }
		        }
		      });
		    }

		    /**
		     * Creates a function that invokes the predicate properties of `source` with
		     * the corresponding property values of a given object, returning `true` if
		     * all predicates return truthy, else `false`.
		     *
		     * **Note:** The created function is equivalent to `_.conformsTo` with
		     * `source` partially applied.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Util
		     * @param {Object} source The object of property predicates to conform to.
		     * @returns {Function} Returns the new spec function.
		     * @example
		     *
		     * var objects = [
		     *   { 'a': 2, 'b': 1 },
		     *   { 'a': 1, 'b': 2 }
		     * ];
		     *
		     * _.filter(objects, _.conforms({ 'b': function(n) { return n > 1; } }));
		     * // => [{ 'a': 1, 'b': 2 }]
		     */
		    function conforms(source) {
		      return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
		    }

		    /**
		     * Creates a function that returns `value`.
		     *
		     * @static
		     * @memberOf _
		     * @since 2.4.0
		     * @category Util
		     * @param {*} value The value to return from the new function.
		     * @returns {Function} Returns the new constant function.
		     * @example
		     *
		     * var objects = _.times(2, _.constant({ 'a': 1 }));
		     *
		     * console.log(objects);
		     * // => [{ 'a': 1 }, { 'a': 1 }]
		     *
		     * console.log(objects[0] === objects[1]);
		     * // => true
		     */
		    function constant(value) {
		      return function() {
		        return value;
		      };
		    }

		    /**
		     * Checks `value` to determine whether a default value should be returned in
		     * its place. The `defaultValue` is returned if `value` is `NaN`, `null`,
		     * or `undefined`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.14.0
		     * @category Util
		     * @param {*} value The value to check.
		     * @param {*} defaultValue The default value.
		     * @returns {*} Returns the resolved value.
		     * @example
		     *
		     * _.defaultTo(1, 10);
		     * // => 1
		     *
		     * _.defaultTo(undefined, 10);
		     * // => 10
		     */
		    function defaultTo(value, defaultValue) {
		      return (value == null || value !== value) ? defaultValue : value;
		    }

		    /**
		     * Creates a function that returns the result of invoking the given functions
		     * with the `this` binding of the created function, where each successive
		     * invocation is supplied the return value of the previous.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category Util
		     * @param {...(Function|Function[])} [funcs] The functions to invoke.
		     * @returns {Function} Returns the new composite function.
		     * @see _.flowRight
		     * @example
		     *
		     * function square(n) {
		     *   return n * n;
		     * }
		     *
		     * var addSquare = _.flow([_.add, square]);
		     * addSquare(1, 2);
		     * // => 9
		     */
		    var flow = createFlow();

		    /**
		     * This method is like `_.flow` except that it creates a function that
		     * invokes the given functions from right to left.
		     *
		     * @static
		     * @since 3.0.0
		     * @memberOf _
		     * @category Util
		     * @param {...(Function|Function[])} [funcs] The functions to invoke.
		     * @returns {Function} Returns the new composite function.
		     * @see _.flow
		     * @example
		     *
		     * function square(n) {
		     *   return n * n;
		     * }
		     *
		     * var addSquare = _.flowRight([square, _.add]);
		     * addSquare(1, 2);
		     * // => 9
		     */
		    var flowRight = createFlow(true);

		    /**
		     * This method returns the first argument it receives.
		     *
		     * @static
		     * @since 0.1.0
		     * @memberOf _
		     * @category Util
		     * @param {*} value Any value.
		     * @returns {*} Returns `value`.
		     * @example
		     *
		     * var object = { 'a': 1 };
		     *
		     * console.log(_.identity(object) === object);
		     * // => true
		     */
		    function identity(value) {
		      return value;
		    }

		    /**
		     * Creates a function that invokes `func` with the arguments of the created
		     * function. If `func` is a property name, the created function returns the
		     * property value for a given element. If `func` is an array or object, the
		     * created function returns `true` for elements that contain the equivalent
		     * source properties, otherwise it returns `false`.
		     *
		     * @static
		     * @since 4.0.0
		     * @memberOf _
		     * @category Util
		     * @param {*} [func=_.identity] The value to convert to a callback.
		     * @returns {Function} Returns the callback.
		     * @example
		     *
		     * var users = [
		     *   { 'user': 'barney', 'age': 36, 'active': true },
		     *   { 'user': 'fred',   'age': 40, 'active': false }
		     * ];
		     *
		     * // The `_.matches` iteratee shorthand.
		     * _.filter(users, _.iteratee({ 'user': 'barney', 'active': true }));
		     * // => [{ 'user': 'barney', 'age': 36, 'active': true }]
		     *
		     * // The `_.matchesProperty` iteratee shorthand.
		     * _.filter(users, _.iteratee(['user', 'fred']));
		     * // => [{ 'user': 'fred', 'age': 40 }]
		     *
		     * // The `_.property` iteratee shorthand.
		     * _.map(users, _.iteratee('user'));
		     * // => ['barney', 'fred']
		     *
		     * // Create custom iteratee shorthands.
		     * _.iteratee = _.wrap(_.iteratee, function(iteratee, func) {
		     *   return !_.isRegExp(func) ? iteratee(func) : function(string) {
		     *     return func.test(string);
		     *   };
		     * });
		     *
		     * _.filter(['abc', 'def'], /ef/);
		     * // => ['def']
		     */
		    function iteratee(func) {
		      return baseIteratee(typeof func == 'function' ? func : baseClone(func, CLONE_DEEP_FLAG));
		    }

		    /**
		     * Creates a function that performs a partial deep comparison between a given
		     * object and `source`, returning `true` if the given object has equivalent
		     * property values, else `false`.
		     *
		     * **Note:** The created function is equivalent to `_.isMatch` with `source`
		     * partially applied.
		     *
		     * Partial comparisons will match empty array and empty object `source`
		     * values against any array or object value, respectively. See `_.isEqual`
		     * for a list of supported value comparisons.
		     *
		     * **Note:** Multiple values can be checked by combining several matchers
		     * using `_.overSome`
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category Util
		     * @param {Object} source The object of property values to match.
		     * @returns {Function} Returns the new spec function.
		     * @example
		     *
		     * var objects = [
		     *   { 'a': 1, 'b': 2, 'c': 3 },
		     *   { 'a': 4, 'b': 5, 'c': 6 }
		     * ];
		     *
		     * _.filter(objects, _.matches({ 'a': 4, 'c': 6 }));
		     * // => [{ 'a': 4, 'b': 5, 'c': 6 }]
		     *
		     * // Checking for several possible values
		     * _.filter(objects, _.overSome([_.matches({ 'a': 1 }), _.matches({ 'a': 4 })]));
		     * // => [{ 'a': 1, 'b': 2, 'c': 3 }, { 'a': 4, 'b': 5, 'c': 6 }]
		     */
		    function matches(source) {
		      return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
		    }

		    /**
		     * Creates a function that performs a partial deep comparison between the
		     * value at `path` of a given object to `srcValue`, returning `true` if the
		     * object value is equivalent, else `false`.
		     *
		     * **Note:** Partial comparisons will match empty array and empty object
		     * `srcValue` values against any array or object value, respectively. See
		     * `_.isEqual` for a list of supported value comparisons.
		     *
		     * **Note:** Multiple values can be checked by combining several matchers
		     * using `_.overSome`
		     *
		     * @static
		     * @memberOf _
		     * @since 3.2.0
		     * @category Util
		     * @param {Array|string} path The path of the property to get.
		     * @param {*} srcValue The value to match.
		     * @returns {Function} Returns the new spec function.
		     * @example
		     *
		     * var objects = [
		     *   { 'a': 1, 'b': 2, 'c': 3 },
		     *   { 'a': 4, 'b': 5, 'c': 6 }
		     * ];
		     *
		     * _.find(objects, _.matchesProperty('a', 4));
		     * // => { 'a': 4, 'b': 5, 'c': 6 }
		     *
		     * // Checking for several possible values
		     * _.filter(objects, _.overSome([_.matchesProperty('a', 1), _.matchesProperty('a', 4)]));
		     * // => [{ 'a': 1, 'b': 2, 'c': 3 }, { 'a': 4, 'b': 5, 'c': 6 }]
		     */
		    function matchesProperty(path, srcValue) {
		      return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));
		    }

		    /**
		     * Creates a function that invokes the method at `path` of a given object.
		     * Any additional arguments are provided to the invoked method.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.7.0
		     * @category Util
		     * @param {Array|string} path The path of the method to invoke.
		     * @param {...*} [args] The arguments to invoke the method with.
		     * @returns {Function} Returns the new invoker function.
		     * @example
		     *
		     * var objects = [
		     *   { 'a': { 'b': _.constant(2) } },
		     *   { 'a': { 'b': _.constant(1) } }
		     * ];
		     *
		     * _.map(objects, _.method('a.b'));
		     * // => [2, 1]
		     *
		     * _.map(objects, _.method(['a', 'b']));
		     * // => [2, 1]
		     */
		    var method = baseRest(function(path, args) {
		      return function(object) {
		        return baseInvoke(object, path, args);
		      };
		    });

		    /**
		     * The opposite of `_.method`; this method creates a function that invokes
		     * the method at a given path of `object`. Any additional arguments are
		     * provided to the invoked method.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.7.0
		     * @category Util
		     * @param {Object} object The object to query.
		     * @param {...*} [args] The arguments to invoke the method with.
		     * @returns {Function} Returns the new invoker function.
		     * @example
		     *
		     * var array = _.times(3, _.constant),
		     *     object = { 'a': array, 'b': array, 'c': array };
		     *
		     * _.map(['a[2]', 'c[0]'], _.methodOf(object));
		     * // => [2, 0]
		     *
		     * _.map([['a', '2'], ['c', '0']], _.methodOf(object));
		     * // => [2, 0]
		     */
		    var methodOf = baseRest(function(object, args) {
		      return function(path) {
		        return baseInvoke(object, path, args);
		      };
		    });

		    /**
		     * Adds all own enumerable string keyed function properties of a source
		     * object to the destination object. If `object` is a function, then methods
		     * are added to its prototype as well.
		     *
		     * **Note:** Use `_.runInContext` to create a pristine `lodash` function to
		     * avoid conflicts caused by modifying the original.
		     *
		     * @static
		     * @since 0.1.0
		     * @memberOf _
		     * @category Util
		     * @param {Function|Object} [object=lodash] The destination object.
		     * @param {Object} source The object of functions to add.
		     * @param {Object} [options={}] The options object.
		     * @param {boolean} [options.chain=true] Specify whether mixins are chainable.
		     * @returns {Function|Object} Returns `object`.
		     * @example
		     *
		     * function vowels(string) {
		     *   return _.filter(string, function(v) {
		     *     return /[aeiou]/i.test(v);
		     *   });
		     * }
		     *
		     * _.mixin({ 'vowels': vowels });
		     * _.vowels('fred');
		     * // => ['e']
		     *
		     * _('fred').vowels().value();
		     * // => ['e']
		     *
		     * _.mixin({ 'vowels': vowels }, { 'chain': false });
		     * _('fred').vowels();
		     * // => ['e']
		     */
		    function mixin(object, source, options) {
		      var props = keys(source),
		          methodNames = baseFunctions(source, props);

		      if (options == null &&
		          !(isObject(source) && (methodNames.length || !props.length))) {
		        options = source;
		        source = object;
		        object = this;
		        methodNames = baseFunctions(source, keys(source));
		      }
		      var chain = !(isObject(options) && 'chain' in options) || !!options.chain,
		          isFunc = isFunction(object);

		      arrayEach(methodNames, function(methodName) {
		        var func = source[methodName];
		        object[methodName] = func;
		        if (isFunc) {
		          object.prototype[methodName] = function() {
		            var chainAll = this.__chain__;
		            if (chain || chainAll) {
		              var result = object(this.__wrapped__),
		                  actions = result.__actions__ = copyArray(this.__actions__);

		              actions.push({ 'func': func, 'args': arguments, 'thisArg': object });
		              result.__chain__ = chainAll;
		              return result;
		            }
		            return func.apply(object, arrayPush([this.value()], arguments));
		          };
		        }
		      });

		      return object;
		    }

		    /**
		     * Reverts the `_` variable to its previous value and returns a reference to
		     * the `lodash` function.
		     *
		     * @static
		     * @since 0.1.0
		     * @memberOf _
		     * @category Util
		     * @returns {Function} Returns the `lodash` function.
		     * @example
		     *
		     * var lodash = _.noConflict();
		     */
		    function noConflict() {
		      if (root._ === this) {
		        root._ = oldDash;
		      }
		      return this;
		    }

		    /**
		     * This method returns `undefined`.
		     *
		     * @static
		     * @memberOf _
		     * @since 2.3.0
		     * @category Util
		     * @example
		     *
		     * _.times(2, _.noop);
		     * // => [undefined, undefined]
		     */
		    function noop() {
		      // No operation performed.
		    }

		    /**
		     * Creates a function that gets the argument at index `n`. If `n` is negative,
		     * the nth argument from the end is returned.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Util
		     * @param {number} [n=0] The index of the argument to return.
		     * @returns {Function} Returns the new pass-thru function.
		     * @example
		     *
		     * var func = _.nthArg(1);
		     * func('a', 'b', 'c', 'd');
		     * // => 'b'
		     *
		     * var func = _.nthArg(-2);
		     * func('a', 'b', 'c', 'd');
		     * // => 'c'
		     */
		    function nthArg(n) {
		      n = toInteger(n);
		      return baseRest(function(args) {
		        return baseNth(args, n);
		      });
		    }

		    /**
		     * Creates a function that invokes `iteratees` with the arguments it receives
		     * and returns their results.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Util
		     * @param {...(Function|Function[])} [iteratees=[_.identity]]
		     *  The iteratees to invoke.
		     * @returns {Function} Returns the new function.
		     * @example
		     *
		     * var func = _.over([Math.max, Math.min]);
		     *
		     * func(1, 2, 3, 4);
		     * // => [4, 1]
		     */
		    var over = createOver(arrayMap);

		    /**
		     * Creates a function that checks if **all** of the `predicates` return
		     * truthy when invoked with the arguments it receives.
		     *
		     * Following shorthands are possible for providing predicates.
		     * Pass an `Object` and it will be used as an parameter for `_.matches` to create the predicate.
		     * Pass an `Array` of parameters for `_.matchesProperty` and the predicate will be created using them.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Util
		     * @param {...(Function|Function[])} [predicates=[_.identity]]
		     *  The predicates to check.
		     * @returns {Function} Returns the new function.
		     * @example
		     *
		     * var func = _.overEvery([Boolean, isFinite]);
		     *
		     * func('1');
		     * // => true
		     *
		     * func(null);
		     * // => false
		     *
		     * func(NaN);
		     * // => false
		     */
		    var overEvery = createOver(arrayEvery);

		    /**
		     * Creates a function that checks if **any** of the `predicates` return
		     * truthy when invoked with the arguments it receives.
		     *
		     * Following shorthands are possible for providing predicates.
		     * Pass an `Object` and it will be used as an parameter for `_.matches` to create the predicate.
		     * Pass an `Array` of parameters for `_.matchesProperty` and the predicate will be created using them.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Util
		     * @param {...(Function|Function[])} [predicates=[_.identity]]
		     *  The predicates to check.
		     * @returns {Function} Returns the new function.
		     * @example
		     *
		     * var func = _.overSome([Boolean, isFinite]);
		     *
		     * func('1');
		     * // => true
		     *
		     * func(null);
		     * // => true
		     *
		     * func(NaN);
		     * // => false
		     *
		     * var matchesFunc = _.overSome([{ 'a': 1 }, { 'a': 2 }])
		     * var matchesPropertyFunc = _.overSome([['a', 1], ['a', 2]])
		     */
		    var overSome = createOver(arraySome);

		    /**
		     * Creates a function that returns the value at `path` of a given object.
		     *
		     * @static
		     * @memberOf _
		     * @since 2.4.0
		     * @category Util
		     * @param {Array|string} path The path of the property to get.
		     * @returns {Function} Returns the new accessor function.
		     * @example
		     *
		     * var objects = [
		     *   { 'a': { 'b': 2 } },
		     *   { 'a': { 'b': 1 } }
		     * ];
		     *
		     * _.map(objects, _.property('a.b'));
		     * // => [2, 1]
		     *
		     * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
		     * // => [1, 2]
		     */
		    function property(path) {
		      return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
		    }

		    /**
		     * The opposite of `_.property`; this method creates a function that returns
		     * the value at a given path of `object`.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category Util
		     * @param {Object} object The object to query.
		     * @returns {Function} Returns the new accessor function.
		     * @example
		     *
		     * var array = [0, 1, 2],
		     *     object = { 'a': array, 'b': array, 'c': array };
		     *
		     * _.map(['a[2]', 'c[0]'], _.propertyOf(object));
		     * // => [2, 0]
		     *
		     * _.map([['a', '2'], ['c', '0']], _.propertyOf(object));
		     * // => [2, 0]
		     */
		    function propertyOf(object) {
		      return function(path) {
		        return object == null ? undefined$1 : baseGet(object, path);
		      };
		    }

		    /**
		     * Creates an array of numbers (positive and/or negative) progressing from
		     * `start` up to, but not including, `end`. A step of `-1` is used if a negative
		     * `start` is specified without an `end` or `step`. If `end` is not specified,
		     * it's set to `start` with `start` then set to `0`.
		     *
		     * **Note:** JavaScript follows the IEEE-754 standard for resolving
		     * floating-point values which can produce unexpected results.
		     *
		     * @static
		     * @since 0.1.0
		     * @memberOf _
		     * @category Util
		     * @param {number} [start=0] The start of the range.
		     * @param {number} end The end of the range.
		     * @param {number} [step=1] The value to increment or decrement by.
		     * @returns {Array} Returns the range of numbers.
		     * @see _.inRange, _.rangeRight
		     * @example
		     *
		     * _.range(4);
		     * // => [0, 1, 2, 3]
		     *
		     * _.range(-4);
		     * // => [0, -1, -2, -3]
		     *
		     * _.range(1, 5);
		     * // => [1, 2, 3, 4]
		     *
		     * _.range(0, 20, 5);
		     * // => [0, 5, 10, 15]
		     *
		     * _.range(0, -4, -1);
		     * // => [0, -1, -2, -3]
		     *
		     * _.range(1, 4, 0);
		     * // => [1, 1, 1]
		     *
		     * _.range(0);
		     * // => []
		     */
		    var range = createRange();

		    /**
		     * This method is like `_.range` except that it populates values in
		     * descending order.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Util
		     * @param {number} [start=0] The start of the range.
		     * @param {number} end The end of the range.
		     * @param {number} [step=1] The value to increment or decrement by.
		     * @returns {Array} Returns the range of numbers.
		     * @see _.inRange, _.range
		     * @example
		     *
		     * _.rangeRight(4);
		     * // => [3, 2, 1, 0]
		     *
		     * _.rangeRight(-4);
		     * // => [-3, -2, -1, 0]
		     *
		     * _.rangeRight(1, 5);
		     * // => [4, 3, 2, 1]
		     *
		     * _.rangeRight(0, 20, 5);
		     * // => [15, 10, 5, 0]
		     *
		     * _.rangeRight(0, -4, -1);
		     * // => [-3, -2, -1, 0]
		     *
		     * _.rangeRight(1, 4, 0);
		     * // => [1, 1, 1]
		     *
		     * _.rangeRight(0);
		     * // => []
		     */
		    var rangeRight = createRange(true);

		    /**
		     * This method returns a new empty array.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.13.0
		     * @category Util
		     * @returns {Array} Returns the new empty array.
		     * @example
		     *
		     * var arrays = _.times(2, _.stubArray);
		     *
		     * console.log(arrays);
		     * // => [[], []]
		     *
		     * console.log(arrays[0] === arrays[1]);
		     * // => false
		     */
		    function stubArray() {
		      return [];
		    }

		    /**
		     * This method returns `false`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.13.0
		     * @category Util
		     * @returns {boolean} Returns `false`.
		     * @example
		     *
		     * _.times(2, _.stubFalse);
		     * // => [false, false]
		     */
		    function stubFalse() {
		      return false;
		    }

		    /**
		     * This method returns a new empty object.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.13.0
		     * @category Util
		     * @returns {Object} Returns the new empty object.
		     * @example
		     *
		     * var objects = _.times(2, _.stubObject);
		     *
		     * console.log(objects);
		     * // => [{}, {}]
		     *
		     * console.log(objects[0] === objects[1]);
		     * // => false
		     */
		    function stubObject() {
		      return {};
		    }

		    /**
		     * This method returns an empty string.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.13.0
		     * @category Util
		     * @returns {string} Returns the empty string.
		     * @example
		     *
		     * _.times(2, _.stubString);
		     * // => ['', '']
		     */
		    function stubString() {
		      return '';
		    }

		    /**
		     * This method returns `true`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.13.0
		     * @category Util
		     * @returns {boolean} Returns `true`.
		     * @example
		     *
		     * _.times(2, _.stubTrue);
		     * // => [true, true]
		     */
		    function stubTrue() {
		      return true;
		    }

		    /**
		     * Invokes the iteratee `n` times, returning an array of the results of
		     * each invocation. The iteratee is invoked with one argument; (index).
		     *
		     * @static
		     * @since 0.1.0
		     * @memberOf _
		     * @category Util
		     * @param {number} n The number of times to invoke `iteratee`.
		     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
		     * @returns {Array} Returns the array of results.
		     * @example
		     *
		     * _.times(3, String);
		     * // => ['0', '1', '2']
		     *
		     *  _.times(4, _.constant(0));
		     * // => [0, 0, 0, 0]
		     */
		    function times(n, iteratee) {
		      n = toInteger(n);
		      if (n < 1 || n > MAX_SAFE_INTEGER) {
		        return [];
		      }
		      var index = MAX_ARRAY_LENGTH,
		          length = nativeMin(n, MAX_ARRAY_LENGTH);

		      iteratee = getIteratee(iteratee);
		      n -= MAX_ARRAY_LENGTH;

		      var result = baseTimes(length, iteratee);
		      while (++index < n) {
		        iteratee(index);
		      }
		      return result;
		    }

		    /**
		     * Converts `value` to a property path array.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Util
		     * @param {*} value The value to convert.
		     * @returns {Array} Returns the new property path array.
		     * @example
		     *
		     * _.toPath('a.b.c');
		     * // => ['a', 'b', 'c']
		     *
		     * _.toPath('a[0].b.c');
		     * // => ['a', '0', 'b', 'c']
		     */
		    function toPath(value) {
		      if (isArray(value)) {
		        return arrayMap(value, toKey);
		      }
		      return isSymbol(value) ? [value] : copyArray(stringToPath(toString(value)));
		    }

		    /**
		     * Generates a unique ID. If `prefix` is given, the ID is appended to it.
		     *
		     * @static
		     * @since 0.1.0
		     * @memberOf _
		     * @category Util
		     * @param {string} [prefix=''] The value to prefix the ID with.
		     * @returns {string} Returns the unique ID.
		     * @example
		     *
		     * _.uniqueId('contact_');
		     * // => 'contact_104'
		     *
		     * _.uniqueId();
		     * // => '105'
		     */
		    function uniqueId(prefix) {
		      var id = ++idCounter;
		      return toString(prefix) + id;
		    }

		    /*------------------------------------------------------------------------*/

		    /**
		     * Adds two numbers.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.4.0
		     * @category Math
		     * @param {number} augend The first number in an addition.
		     * @param {number} addend The second number in an addition.
		     * @returns {number} Returns the total.
		     * @example
		     *
		     * _.add(6, 4);
		     * // => 10
		     */
		    var add = createMathOperation(function(augend, addend) {
		      return augend + addend;
		    }, 0);

		    /**
		     * Computes `number` rounded up to `precision`.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.10.0
		     * @category Math
		     * @param {number} number The number to round up.
		     * @param {number} [precision=0] The precision to round up to.
		     * @returns {number} Returns the rounded up number.
		     * @example
		     *
		     * _.ceil(4.006);
		     * // => 5
		     *
		     * _.ceil(6.004, 2);
		     * // => 6.01
		     *
		     * _.ceil(6040, -2);
		     * // => 6100
		     */
		    var ceil = createRound('ceil');

		    /**
		     * Divide two numbers.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.7.0
		     * @category Math
		     * @param {number} dividend The first number in a division.
		     * @param {number} divisor The second number in a division.
		     * @returns {number} Returns the quotient.
		     * @example
		     *
		     * _.divide(6, 4);
		     * // => 1.5
		     */
		    var divide = createMathOperation(function(dividend, divisor) {
		      return dividend / divisor;
		    }, 1);

		    /**
		     * Computes `number` rounded down to `precision`.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.10.0
		     * @category Math
		     * @param {number} number The number to round down.
		     * @param {number} [precision=0] The precision to round down to.
		     * @returns {number} Returns the rounded down number.
		     * @example
		     *
		     * _.floor(4.006);
		     * // => 4
		     *
		     * _.floor(0.046, 2);
		     * // => 0.04
		     *
		     * _.floor(4060, -2);
		     * // => 4000
		     */
		    var floor = createRound('floor');

		    /**
		     * Computes the maximum value of `array`. If `array` is empty or falsey,
		     * `undefined` is returned.
		     *
		     * @static
		     * @since 0.1.0
		     * @memberOf _
		     * @category Math
		     * @param {Array} array The array to iterate over.
		     * @returns {*} Returns the maximum value.
		     * @example
		     *
		     * _.max([4, 2, 8, 6]);
		     * // => 8
		     *
		     * _.max([]);
		     * // => undefined
		     */
		    function max(array) {
		      return (array && array.length)
		        ? baseExtremum(array, identity, baseGt)
		        : undefined$1;
		    }

		    /**
		     * This method is like `_.max` except that it accepts `iteratee` which is
		     * invoked for each element in `array` to generate the criterion by which
		     * the value is ranked. The iteratee is invoked with one argument: (value).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Math
		     * @param {Array} array The array to iterate over.
		     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
		     * @returns {*} Returns the maximum value.
		     * @example
		     *
		     * var objects = [{ 'n': 1 }, { 'n': 2 }];
		     *
		     * _.maxBy(objects, function(o) { return o.n; });
		     * // => { 'n': 2 }
		     *
		     * // The `_.property` iteratee shorthand.
		     * _.maxBy(objects, 'n');
		     * // => { 'n': 2 }
		     */
		    function maxBy(array, iteratee) {
		      return (array && array.length)
		        ? baseExtremum(array, getIteratee(iteratee, 2), baseGt)
		        : undefined$1;
		    }

		    /**
		     * Computes the mean of the values in `array`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Math
		     * @param {Array} array The array to iterate over.
		     * @returns {number} Returns the mean.
		     * @example
		     *
		     * _.mean([4, 2, 8, 6]);
		     * // => 5
		     */
		    function mean(array) {
		      return baseMean(array, identity);
		    }

		    /**
		     * This method is like `_.mean` except that it accepts `iteratee` which is
		     * invoked for each element in `array` to generate the value to be averaged.
		     * The iteratee is invoked with one argument: (value).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.7.0
		     * @category Math
		     * @param {Array} array The array to iterate over.
		     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
		     * @returns {number} Returns the mean.
		     * @example
		     *
		     * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
		     *
		     * _.meanBy(objects, function(o) { return o.n; });
		     * // => 5
		     *
		     * // The `_.property` iteratee shorthand.
		     * _.meanBy(objects, 'n');
		     * // => 5
		     */
		    function meanBy(array, iteratee) {
		      return baseMean(array, getIteratee(iteratee, 2));
		    }

		    /**
		     * Computes the minimum value of `array`. If `array` is empty or falsey,
		     * `undefined` is returned.
		     *
		     * @static
		     * @since 0.1.0
		     * @memberOf _
		     * @category Math
		     * @param {Array} array The array to iterate over.
		     * @returns {*} Returns the minimum value.
		     * @example
		     *
		     * _.min([4, 2, 8, 6]);
		     * // => 2
		     *
		     * _.min([]);
		     * // => undefined
		     */
		    function min(array) {
		      return (array && array.length)
		        ? baseExtremum(array, identity, baseLt)
		        : undefined$1;
		    }

		    /**
		     * This method is like `_.min` except that it accepts `iteratee` which is
		     * invoked for each element in `array` to generate the criterion by which
		     * the value is ranked. The iteratee is invoked with one argument: (value).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Math
		     * @param {Array} array The array to iterate over.
		     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
		     * @returns {*} Returns the minimum value.
		     * @example
		     *
		     * var objects = [{ 'n': 1 }, { 'n': 2 }];
		     *
		     * _.minBy(objects, function(o) { return o.n; });
		     * // => { 'n': 1 }
		     *
		     * // The `_.property` iteratee shorthand.
		     * _.minBy(objects, 'n');
		     * // => { 'n': 1 }
		     */
		    function minBy(array, iteratee) {
		      return (array && array.length)
		        ? baseExtremum(array, getIteratee(iteratee, 2), baseLt)
		        : undefined$1;
		    }

		    /**
		     * Multiply two numbers.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.7.0
		     * @category Math
		     * @param {number} multiplier The first number in a multiplication.
		     * @param {number} multiplicand The second number in a multiplication.
		     * @returns {number} Returns the product.
		     * @example
		     *
		     * _.multiply(6, 4);
		     * // => 24
		     */
		    var multiply = createMathOperation(function(multiplier, multiplicand) {
		      return multiplier * multiplicand;
		    }, 1);

		    /**
		     * Computes `number` rounded to `precision`.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.10.0
		     * @category Math
		     * @param {number} number The number to round.
		     * @param {number} [precision=0] The precision to round to.
		     * @returns {number} Returns the rounded number.
		     * @example
		     *
		     * _.round(4.006);
		     * // => 4
		     *
		     * _.round(4.006, 2);
		     * // => 4.01
		     *
		     * _.round(4060, -2);
		     * // => 4100
		     */
		    var round = createRound('round');

		    /**
		     * Subtract two numbers.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Math
		     * @param {number} minuend The first number in a subtraction.
		     * @param {number} subtrahend The second number in a subtraction.
		     * @returns {number} Returns the difference.
		     * @example
		     *
		     * _.subtract(6, 4);
		     * // => 2
		     */
		    var subtract = createMathOperation(function(minuend, subtrahend) {
		      return minuend - subtrahend;
		    }, 0);

		    /**
		     * Computes the sum of the values in `array`.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.4.0
		     * @category Math
		     * @param {Array} array The array to iterate over.
		     * @returns {number} Returns the sum.
		     * @example
		     *
		     * _.sum([4, 2, 8, 6]);
		     * // => 20
		     */
		    function sum(array) {
		      return (array && array.length)
		        ? baseSum(array, identity)
		        : 0;
		    }

		    /**
		     * This method is like `_.sum` except that it accepts `iteratee` which is
		     * invoked for each element in `array` to generate the value to be summed.
		     * The iteratee is invoked with one argument: (value).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Math
		     * @param {Array} array The array to iterate over.
		     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
		     * @returns {number} Returns the sum.
		     * @example
		     *
		     * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
		     *
		     * _.sumBy(objects, function(o) { return o.n; });
		     * // => 20
		     *
		     * // The `_.property` iteratee shorthand.
		     * _.sumBy(objects, 'n');
		     * // => 20
		     */
		    function sumBy(array, iteratee) {
		      return (array && array.length)
		        ? baseSum(array, getIteratee(iteratee, 2))
		        : 0;
		    }

		    /*------------------------------------------------------------------------*/

		    // Add methods that return wrapped values in chain sequences.
		    lodash.after = after;
		    lodash.ary = ary;
		    lodash.assign = assign;
		    lodash.assignIn = assignIn;
		    lodash.assignInWith = assignInWith;
		    lodash.assignWith = assignWith;
		    lodash.at = at;
		    lodash.before = before;
		    lodash.bind = bind;
		    lodash.bindAll = bindAll;
		    lodash.bindKey = bindKey;
		    lodash.castArray = castArray;
		    lodash.chain = chain;
		    lodash.chunk = chunk;
		    lodash.compact = compact;
		    lodash.concat = concat;
		    lodash.cond = cond;
		    lodash.conforms = conforms;
		    lodash.constant = constant;
		    lodash.countBy = countBy;
		    lodash.create = create;
		    lodash.curry = curry;
		    lodash.curryRight = curryRight;
		    lodash.debounce = debounce;
		    lodash.defaults = defaults;
		    lodash.defaultsDeep = defaultsDeep;
		    lodash.defer = defer;
		    lodash.delay = delay;
		    lodash.difference = difference;
		    lodash.differenceBy = differenceBy;
		    lodash.differenceWith = differenceWith;
		    lodash.drop = drop;
		    lodash.dropRight = dropRight;
		    lodash.dropRightWhile = dropRightWhile;
		    lodash.dropWhile = dropWhile;
		    lodash.fill = fill;
		    lodash.filter = filter;
		    lodash.flatMap = flatMap;
		    lodash.flatMapDeep = flatMapDeep;
		    lodash.flatMapDepth = flatMapDepth;
		    lodash.flatten = flatten;
		    lodash.flattenDeep = flattenDeep;
		    lodash.flattenDepth = flattenDepth;
		    lodash.flip = flip;
		    lodash.flow = flow;
		    lodash.flowRight = flowRight;
		    lodash.fromPairs = fromPairs;
		    lodash.functions = functions;
		    lodash.functionsIn = functionsIn;
		    lodash.groupBy = groupBy;
		    lodash.initial = initial;
		    lodash.intersection = intersection;
		    lodash.intersectionBy = intersectionBy;
		    lodash.intersectionWith = intersectionWith;
		    lodash.invert = invert;
		    lodash.invertBy = invertBy;
		    lodash.invokeMap = invokeMap;
		    lodash.iteratee = iteratee;
		    lodash.keyBy = keyBy;
		    lodash.keys = keys;
		    lodash.keysIn = keysIn;
		    lodash.map = map;
		    lodash.mapKeys = mapKeys;
		    lodash.mapValues = mapValues;
		    lodash.matches = matches;
		    lodash.matchesProperty = matchesProperty;
		    lodash.memoize = memoize;
		    lodash.merge = merge;
		    lodash.mergeWith = mergeWith;
		    lodash.method = method;
		    lodash.methodOf = methodOf;
		    lodash.mixin = mixin;
		    lodash.negate = negate;
		    lodash.nthArg = nthArg;
		    lodash.omit = omit;
		    lodash.omitBy = omitBy;
		    lodash.once = once;
		    lodash.orderBy = orderBy;
		    lodash.over = over;
		    lodash.overArgs = overArgs;
		    lodash.overEvery = overEvery;
		    lodash.overSome = overSome;
		    lodash.partial = partial;
		    lodash.partialRight = partialRight;
		    lodash.partition = partition;
		    lodash.pick = pick;
		    lodash.pickBy = pickBy;
		    lodash.property = property;
		    lodash.propertyOf = propertyOf;
		    lodash.pull = pull;
		    lodash.pullAll = pullAll;
		    lodash.pullAllBy = pullAllBy;
		    lodash.pullAllWith = pullAllWith;
		    lodash.pullAt = pullAt;
		    lodash.range = range;
		    lodash.rangeRight = rangeRight;
		    lodash.rearg = rearg;
		    lodash.reject = reject;
		    lodash.remove = remove;
		    lodash.rest = rest;
		    lodash.reverse = reverse;
		    lodash.sampleSize = sampleSize;
		    lodash.set = set;
		    lodash.setWith = setWith;
		    lodash.shuffle = shuffle;
		    lodash.slice = slice;
		    lodash.sortBy = sortBy;
		    lodash.sortedUniq = sortedUniq;
		    lodash.sortedUniqBy = sortedUniqBy;
		    lodash.split = split;
		    lodash.spread = spread;
		    lodash.tail = tail;
		    lodash.take = take;
		    lodash.takeRight = takeRight;
		    lodash.takeRightWhile = takeRightWhile;
		    lodash.takeWhile = takeWhile;
		    lodash.tap = tap;
		    lodash.throttle = throttle;
		    lodash.thru = thru;
		    lodash.toArray = toArray;
		    lodash.toPairs = toPairs;
		    lodash.toPairsIn = toPairsIn;
		    lodash.toPath = toPath;
		    lodash.toPlainObject = toPlainObject;
		    lodash.transform = transform;
		    lodash.unary = unary;
		    lodash.union = union;
		    lodash.unionBy = unionBy;
		    lodash.unionWith = unionWith;
		    lodash.uniq = uniq;
		    lodash.uniqBy = uniqBy;
		    lodash.uniqWith = uniqWith;
		    lodash.unset = unset;
		    lodash.unzip = unzip;
		    lodash.unzipWith = unzipWith;
		    lodash.update = update;
		    lodash.updateWith = updateWith;
		    lodash.values = values;
		    lodash.valuesIn = valuesIn;
		    lodash.without = without;
		    lodash.words = words;
		    lodash.wrap = wrap;
		    lodash.xor = xor;
		    lodash.xorBy = xorBy;
		    lodash.xorWith = xorWith;
		    lodash.zip = zip;
		    lodash.zipObject = zipObject;
		    lodash.zipObjectDeep = zipObjectDeep;
		    lodash.zipWith = zipWith;

		    // Add aliases.
		    lodash.entries = toPairs;
		    lodash.entriesIn = toPairsIn;
		    lodash.extend = assignIn;
		    lodash.extendWith = assignInWith;

		    // Add methods to `lodash.prototype`.
		    mixin(lodash, lodash);

		    /*------------------------------------------------------------------------*/

		    // Add methods that return unwrapped values in chain sequences.
		    lodash.add = add;
		    lodash.attempt = attempt;
		    lodash.camelCase = camelCase;
		    lodash.capitalize = capitalize;
		    lodash.ceil = ceil;
		    lodash.clamp = clamp;
		    lodash.clone = clone;
		    lodash.cloneDeep = cloneDeep;
		    lodash.cloneDeepWith = cloneDeepWith;
		    lodash.cloneWith = cloneWith;
		    lodash.conformsTo = conformsTo;
		    lodash.deburr = deburr;
		    lodash.defaultTo = defaultTo;
		    lodash.divide = divide;
		    lodash.endsWith = endsWith;
		    lodash.eq = eq;
		    lodash.escape = escape;
		    lodash.escapeRegExp = escapeRegExp;
		    lodash.every = every;
		    lodash.find = find;
		    lodash.findIndex = findIndex;
		    lodash.findKey = findKey;
		    lodash.findLast = findLast;
		    lodash.findLastIndex = findLastIndex;
		    lodash.findLastKey = findLastKey;
		    lodash.floor = floor;
		    lodash.forEach = forEach;
		    lodash.forEachRight = forEachRight;
		    lodash.forIn = forIn;
		    lodash.forInRight = forInRight;
		    lodash.forOwn = forOwn;
		    lodash.forOwnRight = forOwnRight;
		    lodash.get = get;
		    lodash.gt = gt;
		    lodash.gte = gte;
		    lodash.has = has;
		    lodash.hasIn = hasIn;
		    lodash.head = head;
		    lodash.identity = identity;
		    lodash.includes = includes;
		    lodash.indexOf = indexOf;
		    lodash.inRange = inRange;
		    lodash.invoke = invoke;
		    lodash.isArguments = isArguments;
		    lodash.isArray = isArray;
		    lodash.isArrayBuffer = isArrayBuffer;
		    lodash.isArrayLike = isArrayLike;
		    lodash.isArrayLikeObject = isArrayLikeObject;
		    lodash.isBoolean = isBoolean;
		    lodash.isBuffer = isBuffer;
		    lodash.isDate = isDate;
		    lodash.isElement = isElement;
		    lodash.isEmpty = isEmpty;
		    lodash.isEqual = isEqual;
		    lodash.isEqualWith = isEqualWith;
		    lodash.isError = isError;
		    lodash.isFinite = isFinite;
		    lodash.isFunction = isFunction;
		    lodash.isInteger = isInteger;
		    lodash.isLength = isLength;
		    lodash.isMap = isMap;
		    lodash.isMatch = isMatch;
		    lodash.isMatchWith = isMatchWith;
		    lodash.isNaN = isNaN;
		    lodash.isNative = isNative;
		    lodash.isNil = isNil;
		    lodash.isNull = isNull;
		    lodash.isNumber = isNumber;
		    lodash.isObject = isObject;
		    lodash.isObjectLike = isObjectLike;
		    lodash.isPlainObject = isPlainObject;
		    lodash.isRegExp = isRegExp;
		    lodash.isSafeInteger = isSafeInteger;
		    lodash.isSet = isSet;
		    lodash.isString = isString;
		    lodash.isSymbol = isSymbol;
		    lodash.isTypedArray = isTypedArray;
		    lodash.isUndefined = isUndefined;
		    lodash.isWeakMap = isWeakMap;
		    lodash.isWeakSet = isWeakSet;
		    lodash.join = join;
		    lodash.kebabCase = kebabCase;
		    lodash.last = last;
		    lodash.lastIndexOf = lastIndexOf;
		    lodash.lowerCase = lowerCase;
		    lodash.lowerFirst = lowerFirst;
		    lodash.lt = lt;
		    lodash.lte = lte;
		    lodash.max = max;
		    lodash.maxBy = maxBy;
		    lodash.mean = mean;
		    lodash.meanBy = meanBy;
		    lodash.min = min;
		    lodash.minBy = minBy;
		    lodash.stubArray = stubArray;
		    lodash.stubFalse = stubFalse;
		    lodash.stubObject = stubObject;
		    lodash.stubString = stubString;
		    lodash.stubTrue = stubTrue;
		    lodash.multiply = multiply;
		    lodash.nth = nth;
		    lodash.noConflict = noConflict;
		    lodash.noop = noop;
		    lodash.now = now;
		    lodash.pad = pad;
		    lodash.padEnd = padEnd;
		    lodash.padStart = padStart;
		    lodash.parseInt = parseInt;
		    lodash.random = random;
		    lodash.reduce = reduce;
		    lodash.reduceRight = reduceRight;
		    lodash.repeat = repeat;
		    lodash.replace = replace;
		    lodash.result = result;
		    lodash.round = round;
		    lodash.runInContext = runInContext;
		    lodash.sample = sample;
		    lodash.size = size;
		    lodash.snakeCase = snakeCase;
		    lodash.some = some;
		    lodash.sortedIndex = sortedIndex;
		    lodash.sortedIndexBy = sortedIndexBy;
		    lodash.sortedIndexOf = sortedIndexOf;
		    lodash.sortedLastIndex = sortedLastIndex;
		    lodash.sortedLastIndexBy = sortedLastIndexBy;
		    lodash.sortedLastIndexOf = sortedLastIndexOf;
		    lodash.startCase = startCase;
		    lodash.startsWith = startsWith;
		    lodash.subtract = subtract;
		    lodash.sum = sum;
		    lodash.sumBy = sumBy;
		    lodash.template = template;
		    lodash.times = times;
		    lodash.toFinite = toFinite;
		    lodash.toInteger = toInteger;
		    lodash.toLength = toLength;
		    lodash.toLower = toLower;
		    lodash.toNumber = toNumber;
		    lodash.toSafeInteger = toSafeInteger;
		    lodash.toString = toString;
		    lodash.toUpper = toUpper;
		    lodash.trim = trim;
		    lodash.trimEnd = trimEnd;
		    lodash.trimStart = trimStart;
		    lodash.truncate = truncate;
		    lodash.unescape = unescape;
		    lodash.uniqueId = uniqueId;
		    lodash.upperCase = upperCase;
		    lodash.upperFirst = upperFirst;

		    // Add aliases.
		    lodash.each = forEach;
		    lodash.eachRight = forEachRight;
		    lodash.first = head;

		    mixin(lodash, (function() {
		      var source = {};
		      baseForOwn(lodash, function(func, methodName) {
		        if (!hasOwnProperty.call(lodash.prototype, methodName)) {
		          source[methodName] = func;
		        }
		      });
		      return source;
		    }()), { 'chain': false });

		    /*------------------------------------------------------------------------*/

		    /**
		     * The semantic version number.
		     *
		     * @static
		     * @memberOf _
		     * @type {string}
		     */
		    lodash.VERSION = VERSION;

		    // Assign default placeholders.
		    arrayEach(['bind', 'bindKey', 'curry', 'curryRight', 'partial', 'partialRight'], function(methodName) {
		      lodash[methodName].placeholder = lodash;
		    });

		    // Add `LazyWrapper` methods for `_.drop` and `_.take` variants.
		    arrayEach(['drop', 'take'], function(methodName, index) {
		      LazyWrapper.prototype[methodName] = function(n) {
		        n = n === undefined$1 ? 1 : nativeMax(toInteger(n), 0);

		        var result = (this.__filtered__ && !index)
		          ? new LazyWrapper(this)
		          : this.clone();

		        if (result.__filtered__) {
		          result.__takeCount__ = nativeMin(n, result.__takeCount__);
		        } else {
		          result.__views__.push({
		            'size': nativeMin(n, MAX_ARRAY_LENGTH),
		            'type': methodName + (result.__dir__ < 0 ? 'Right' : '')
		          });
		        }
		        return result;
		      };

		      LazyWrapper.prototype[methodName + 'Right'] = function(n) {
		        return this.reverse()[methodName](n).reverse();
		      };
		    });

		    // Add `LazyWrapper` methods that accept an `iteratee` value.
		    arrayEach(['filter', 'map', 'takeWhile'], function(methodName, index) {
		      var type = index + 1,
		          isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;

		      LazyWrapper.prototype[methodName] = function(iteratee) {
		        var result = this.clone();
		        result.__iteratees__.push({
		          'iteratee': getIteratee(iteratee, 3),
		          'type': type
		        });
		        result.__filtered__ = result.__filtered__ || isFilter;
		        return result;
		      };
		    });

		    // Add `LazyWrapper` methods for `_.head` and `_.last`.
		    arrayEach(['head', 'last'], function(methodName, index) {
		      var takeName = 'take' + (index ? 'Right' : '');

		      LazyWrapper.prototype[methodName] = function() {
		        return this[takeName](1).value()[0];
		      };
		    });

		    // Add `LazyWrapper` methods for `_.initial` and `_.tail`.
		    arrayEach(['initial', 'tail'], function(methodName, index) {
		      var dropName = 'drop' + (index ? '' : 'Right');

		      LazyWrapper.prototype[methodName] = function() {
		        return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
		      };
		    });

		    LazyWrapper.prototype.compact = function() {
		      return this.filter(identity);
		    };

		    LazyWrapper.prototype.find = function(predicate) {
		      return this.filter(predicate).head();
		    };

		    LazyWrapper.prototype.findLast = function(predicate) {
		      return this.reverse().find(predicate);
		    };

		    LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {
		      if (typeof path == 'function') {
		        return new LazyWrapper(this);
		      }
		      return this.map(function(value) {
		        return baseInvoke(value, path, args);
		      });
		    });

		    LazyWrapper.prototype.reject = function(predicate) {
		      return this.filter(negate(getIteratee(predicate)));
		    };

		    LazyWrapper.prototype.slice = function(start, end) {
		      start = toInteger(start);

		      var result = this;
		      if (result.__filtered__ && (start > 0 || end < 0)) {
		        return new LazyWrapper(result);
		      }
		      if (start < 0) {
		        result = result.takeRight(-start);
		      } else if (start) {
		        result = result.drop(start);
		      }
		      if (end !== undefined$1) {
		        end = toInteger(end);
		        result = end < 0 ? result.dropRight(-end) : result.take(end - start);
		      }
		      return result;
		    };

		    LazyWrapper.prototype.takeRightWhile = function(predicate) {
		      return this.reverse().takeWhile(predicate).reverse();
		    };

		    LazyWrapper.prototype.toArray = function() {
		      return this.take(MAX_ARRAY_LENGTH);
		    };

		    // Add `LazyWrapper` methods to `lodash.prototype`.
		    baseForOwn(LazyWrapper.prototype, function(func, methodName) {
		      var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName),
		          isTaker = /^(?:head|last)$/.test(methodName),
		          lodashFunc = lodash[isTaker ? ('take' + (methodName == 'last' ? 'Right' : '')) : methodName],
		          retUnwrapped = isTaker || /^find/.test(methodName);

		      if (!lodashFunc) {
		        return;
		      }
		      lodash.prototype[methodName] = function() {
		        var value = this.__wrapped__,
		            args = isTaker ? [1] : arguments,
		            isLazy = value instanceof LazyWrapper,
		            iteratee = args[0],
		            useLazy = isLazy || isArray(value);

		        var interceptor = function(value) {
		          var result = lodashFunc.apply(lodash, arrayPush([value], args));
		          return (isTaker && chainAll) ? result[0] : result;
		        };

		        if (useLazy && checkIteratee && typeof iteratee == 'function' && iteratee.length != 1) {
		          // Avoid lazy use if the iteratee has a "length" value other than `1`.
		          isLazy = useLazy = false;
		        }
		        var chainAll = this.__chain__,
		            isHybrid = !!this.__actions__.length,
		            isUnwrapped = retUnwrapped && !chainAll,
		            onlyLazy = isLazy && !isHybrid;

		        if (!retUnwrapped && useLazy) {
		          value = onlyLazy ? value : new LazyWrapper(this);
		          var result = func.apply(value, args);
		          result.__actions__.push({ 'func': thru, 'args': [interceptor], 'thisArg': undefined$1 });
		          return new LodashWrapper(result, chainAll);
		        }
		        if (isUnwrapped && onlyLazy) {
		          return func.apply(this, args);
		        }
		        result = this.thru(interceptor);
		        return isUnwrapped ? (isTaker ? result.value()[0] : result.value()) : result;
		      };
		    });

		    // Add `Array` methods to `lodash.prototype`.
		    arrayEach(['pop', 'push', 'shift', 'sort', 'splice', 'unshift'], function(methodName) {
		      var func = arrayProto[methodName],
		          chainName = /^(?:push|sort|unshift)$/.test(methodName) ? 'tap' : 'thru',
		          retUnwrapped = /^(?:pop|shift)$/.test(methodName);

		      lodash.prototype[methodName] = function() {
		        var args = arguments;
		        if (retUnwrapped && !this.__chain__) {
		          var value = this.value();
		          return func.apply(isArray(value) ? value : [], args);
		        }
		        return this[chainName](function(value) {
		          return func.apply(isArray(value) ? value : [], args);
		        });
		      };
		    });

		    // Map minified method names to their real names.
		    baseForOwn(LazyWrapper.prototype, function(func, methodName) {
		      var lodashFunc = lodash[methodName];
		      if (lodashFunc) {
		        var key = lodashFunc.name + '';
		        if (!hasOwnProperty.call(realNames, key)) {
		          realNames[key] = [];
		        }
		        realNames[key].push({ 'name': methodName, 'func': lodashFunc });
		      }
		    });

		    realNames[createHybrid(undefined$1, WRAP_BIND_KEY_FLAG).name] = [{
		      'name': 'wrapper',
		      'func': undefined$1
		    }];

		    // Add methods to `LazyWrapper`.
		    LazyWrapper.prototype.clone = lazyClone;
		    LazyWrapper.prototype.reverse = lazyReverse;
		    LazyWrapper.prototype.value = lazyValue;

		    // Add chain sequence methods to the `lodash` wrapper.
		    lodash.prototype.at = wrapperAt;
		    lodash.prototype.chain = wrapperChain;
		    lodash.prototype.commit = wrapperCommit;
		    lodash.prototype.next = wrapperNext;
		    lodash.prototype.plant = wrapperPlant;
		    lodash.prototype.reverse = wrapperReverse;
		    lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;

		    // Add lazy aliases.
		    lodash.prototype.first = lodash.prototype.head;

		    if (symIterator) {
		      lodash.prototype[symIterator] = wrapperToIterator;
		    }
		    return lodash;
		  });

		  /*--------------------------------------------------------------------------*/

		  // Export lodash.
		  var _ = runInContext();

		  // Some AMD build optimizers, like r.js, check for condition patterns like:
		  if (freeModule) {
		    // Export for Node.js.
		    (freeModule.exports = _)._ = _;
		    // Export for CommonJS support.
		    freeExports._ = _;
		  }
		  else {
		    // Export to the global object.
		    root._ = _;
		  }
		}.call(commonjsGlobal)); 
	} (lodash, lodash.exports));

	var lodashExports = lodash.exports;

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	// resolves . and .. elements in a path array with directory names there
	// must be no slashes, empty elements, or device names (c:\) in the array
	// (so also no leading and trailing slashes - it does not distinguish
	// relative and absolute paths)
	function normalizeArray(parts, allowAboveRoot) {
	  // if the path tries to go above the root, `up` ends up > 0
	  var up = 0;
	  for (var i = parts.length - 1; i >= 0; i--) {
	    var last = parts[i];
	    if (last === '.') {
	      parts.splice(i, 1);
	    } else if (last === '..') {
	      parts.splice(i, 1);
	      up++;
	    } else if (up) {
	      parts.splice(i, 1);
	      up--;
	    }
	  }

	  // if the path is allowed to go above the root, restore leading ..s
	  if (allowAboveRoot) {
	    for (; up--; up) {
	      parts.unshift('..');
	    }
	  }

	  return parts;
	}

	// Split a filename into [root, dir, basename, ext], unix version
	// 'root' is just a slash, or nothing.
	var splitPathRe =
	    /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
	var splitPath = function(filename) {
	  return splitPathRe.exec(filename).slice(1);
	};

	// path.resolve([from ...], to)
	// posix version
	function resolve() {
	  var resolvedPath = '',
	      resolvedAbsolute = false;

	  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
	    var path = (i >= 0) ? arguments[i] : '/';

	    // Skip empty and invalid entries
	    if (typeof path !== 'string') {
	      throw new TypeError('Arguments to path.resolve must be strings');
	    } else if (!path) {
	      continue;
	    }

	    resolvedPath = path + '/' + resolvedPath;
	    resolvedAbsolute = path.charAt(0) === '/';
	  }

	  // At this point the path should be resolved to a full absolute path, but
	  // handle relative paths to be safe (might happen when process.cwd() fails)

	  // Normalize the path
	  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
	    return !!p;
	  }), !resolvedAbsolute).join('/');

	  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
	}
	// path.normalize(path)
	// posix version
	function normalize$1(path) {
	  var isPathAbsolute = isAbsolute(path),
	      trailingSlash = substr(path, -1) === '/';

	  // Normalize the path
	  path = normalizeArray(filter(path.split('/'), function(p) {
	    return !!p;
	  }), !isPathAbsolute).join('/');

	  if (!path && !isPathAbsolute) {
	    path = '.';
	  }
	  if (path && trailingSlash) {
	    path += '/';
	  }

	  return (isPathAbsolute ? '/' : '') + path;
	}
	// posix version
	function isAbsolute(path) {
	  return path.charAt(0) === '/';
	}

	// posix version
	function join() {
	  var paths = Array.prototype.slice.call(arguments, 0);
	  return normalize$1(filter(paths, function(p, index) {
	    if (typeof p !== 'string') {
	      throw new TypeError('Arguments to path.join must be strings');
	    }
	    return p;
	  }).join('/'));
	}


	// path.relative(from, to)
	// posix version
	function relative(from, to) {
	  from = resolve(from).substr(1);
	  to = resolve(to).substr(1);

	  function trim(arr) {
	    var start = 0;
	    for (; start < arr.length; start++) {
	      if (arr[start] !== '') break;
	    }

	    var end = arr.length - 1;
	    for (; end >= 0; end--) {
	      if (arr[end] !== '') break;
	    }

	    if (start > end) return [];
	    return arr.slice(start, end - start + 1);
	  }

	  var fromParts = trim(from.split('/'));
	  var toParts = trim(to.split('/'));

	  var length = Math.min(fromParts.length, toParts.length);
	  var samePartsLength = length;
	  for (var i = 0; i < length; i++) {
	    if (fromParts[i] !== toParts[i]) {
	      samePartsLength = i;
	      break;
	    }
	  }

	  var outputParts = [];
	  for (var i = samePartsLength; i < fromParts.length; i++) {
	    outputParts.push('..');
	  }

	  outputParts = outputParts.concat(toParts.slice(samePartsLength));

	  return outputParts.join('/');
	}

	var sep = '/';
	var delimiter = ':';

	function dirname(path) {
	  var result = splitPath(path),
	      root = result[0],
	      dir = result[1];

	  if (!root && !dir) {
	    // No dirname whatsoever
	    return '.';
	  }

	  if (dir) {
	    // It has a dirname, strip trailing slash
	    dir = dir.substr(0, dir.length - 1);
	  }

	  return root + dir;
	}

	function basename(path, ext) {
	  var f = splitPath(path)[2];
	  // TODO: make this comparison case-insensitive on windows?
	  if (ext && f.substr(-1 * ext.length) === ext) {
	    f = f.substr(0, f.length - ext.length);
	  }
	  return f;
	}


	function extname(path) {
	  return splitPath(path)[3];
	}
	var _polyfillNode_path = {
	  extname: extname,
	  basename: basename,
	  dirname: dirname,
	  sep: sep,
	  delimiter: delimiter,
	  relative: relative,
	  join: join,
	  isAbsolute: isAbsolute,
	  normalize: normalize$1,
	  resolve: resolve
	};
	function filter (xs, f) {
	    if (xs.filter) return xs.filter(f);
	    var res = [];
	    for (var i = 0; i < xs.length; i++) {
	        if (f(xs[i], i, xs)) res.push(xs[i]);
	    }
	    return res;
	}

	// String.prototype.substr - negative index don't work in IE8
	var substr = 'ab'.substr(-1) === 'b' ?
	    function (str, start, len) { return str.substr(start, len) } :
	    function (str, start, len) {
	        if (start < 0) start = str.length + start;
	        return str.substr(start, len);
	    }
	;

	var _polyfillNode_path$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		basename: basename,
		default: _polyfillNode_path,
		delimiter: delimiter,
		dirname: dirname,
		extname: extname,
		isAbsolute: isAbsolute,
		join: join,
		normalize: normalize$1,
		relative: relative,
		resolve: resolve,
		sep: sep
	});

	var require$$2 = /*@__PURE__*/getAugmentedNamespace(_polyfillNode_path$1);

	var formatter = {};

	var __assign$2 = (commonjsGlobal && commonjsGlobal.__assign) || function () {
	    __assign$2 = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$2.apply(this, arguments);
	};
	Object.defineProperty(formatter, "__esModule", { value: true });
	formatter.format = void 0;
	var prettier_1 = require$$0$1;
	function format$3(code, options) {
	    if (!options.format) {
	        return code;
	    }
	    return (0, prettier_1.format)(code, __assign$2({ parser: 'typescript' }, options.style));
	}
	formatter.format = format$3;

	var generator = {};

	var AST = {};

	Object.defineProperty(AST, "__esModule", { value: true });
	AST.T_UNKNOWN_ADDITIONAL_PROPERTIES = AST.T_UNKNOWN = AST.T_ANY_ADDITIONAL_PROPERTIES = AST.T_ANY = AST.hasStandaloneName = AST.hasComment = void 0;
	function hasComment(ast) {
	    return (('comment' in ast && ast.comment != null && ast.comment !== '') ||
	        // Compare to true because ast.deprecated might be undefined
	        ('deprecated' in ast && ast.deprecated === true));
	}
	AST.hasComment = hasComment;
	function hasStandaloneName(ast) {
	    return 'standaloneName' in ast && ast.standaloneName != null && ast.standaloneName !== '';
	}
	AST.hasStandaloneName = hasStandaloneName;
	////////////////////////////////////////////     literals
	AST.T_ANY = {
	    type: 'ANY',
	};
	AST.T_ANY_ADDITIONAL_PROPERTIES = {
	    keyName: '[k: string]',
	    type: 'ANY',
	};
	AST.T_UNKNOWN = {
	    type: 'UNKNOWN',
	};
	AST.T_UNKNOWN_ADDITIONAL_PROPERTIES = {
	    keyName: '[k: string]',
	    type: 'UNKNOWN',
	};

	var utils = {};

	var JSONSchema = {};

	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.isCompound = exports.isPrimitive = exports.isBoolean = exports.getRootSchema = exports.Parent = void 0;
		var lodash_1 = lodashExports;
		exports.Parent = Symbol('Parent');
		exports.getRootSchema = (0, lodash_1.memoize)(function (schema) {
		    var parent = schema[exports.Parent];
		    if (!parent) {
		        return schema;
		    }
		    return (0, exports.getRootSchema)(parent);
		});
		function isBoolean(schema) {
		    return schema === true || schema === false;
		}
		exports.isBoolean = isBoolean;
		function isPrimitive(schema) {
		    return !(0, lodash_1.isPlainObject)(schema);
		}
		exports.isPrimitive = isPrimitive;
		function isCompound(schema) {
		    return Array.isArray(schema.type) || 'anyOf' in schema || 'oneOf' in schema;
		}
		exports.isCompound = isCompound;
		
	} (JSONSchema));

	var d = {exports: {}};

	var is$5;
	var hasRequiredIs$5;

	function requireIs$5 () {
		if (hasRequiredIs$5) return is$5;
		hasRequiredIs$5 = 1;

		// ES3 safe
		var _undefined = void 0;

		is$5 = function (value) { return value !== _undefined && value !== null; };
		return is$5;
	}

	var is$4;
	var hasRequiredIs$4;

	function requireIs$4 () {
		if (hasRequiredIs$4) return is$4;
		hasRequiredIs$4 = 1;

		var isValue = requireIs$5();

		// prettier-ignore
		var possibleTypes = { "object": true, "function": true, "undefined": true /* document.all */ };

		is$4 = function (value) {
			if (!isValue(value)) return false;
			return hasOwnProperty.call(possibleTypes, typeof value);
		};
		return is$4;
	}

	var is$3;
	var hasRequiredIs$3;

	function requireIs$3 () {
		if (hasRequiredIs$3) return is$3;
		hasRequiredIs$3 = 1;

		var isObject = requireIs$4();

		is$3 = function (value) {
			if (!isObject(value)) return false;
			try {
				if (!value.constructor) return false;
				return value.constructor.prototype === value;
			} catch (error) {
				return false;
			}
		};
		return is$3;
	}

	var is$2;
	var hasRequiredIs$2;

	function requireIs$2 () {
		if (hasRequiredIs$2) return is$2;
		hasRequiredIs$2 = 1;

		var isPrototype = requireIs$3();

		is$2 = function (value) {
			if (typeof value !== "function") return false;

			if (!hasOwnProperty.call(value, "length")) return false;

			try {
				if (typeof value.length !== "number") return false;
				if (typeof value.call !== "function") return false;
				if (typeof value.apply !== "function") return false;
			} catch (error) {
				return false;
			}

			return !isPrototype(value);
		};
		return is$2;
	}

	var is$1;
	var hasRequiredIs$1;

	function requireIs$1 () {
		if (hasRequiredIs$1) return is$1;
		hasRequiredIs$1 = 1;

		var isFunction = requireIs$2();

		var classRe = /^\s*class[\s{/}]/, functionToString = Function.prototype.toString;

		is$1 = function (value) {
			if (!isFunction(value)) return false;
			if (classRe.test(functionToString.call(value))) return false;
			return true;
		};
		return is$1;
	}

	var isImplemented$a;
	var hasRequiredIsImplemented$a;

	function requireIsImplemented$a () {
		if (hasRequiredIsImplemented$a) return isImplemented$a;
		hasRequiredIsImplemented$a = 1;

		isImplemented$a = function () {
			var assign = Object.assign, obj;
			if (typeof assign !== "function") return false;
			obj = { foo: "raz" };
			assign(obj, { bar: "dwa" }, { trzy: "trzy" });
			return obj.foo + obj.bar + obj.trzy === "razdwatrzy";
		};
		return isImplemented$a;
	}

	var isImplemented$9;
	var hasRequiredIsImplemented$9;

	function requireIsImplemented$9 () {
		if (hasRequiredIsImplemented$9) return isImplemented$9;
		hasRequiredIsImplemented$9 = 1;

		isImplemented$9 = function () {
			try {
				Object.keys("primitive");
				return true;
			} catch (e) {
				return false;
			}
		};
		return isImplemented$9;
	}

	var noop;
	var hasRequiredNoop;

	function requireNoop () {
		if (hasRequiredNoop) return noop;
		hasRequiredNoop = 1;

		// eslint-disable-next-line no-empty-function
		noop = function () {};
		return noop;
	}

	var isValue;
	var hasRequiredIsValue;

	function requireIsValue () {
		if (hasRequiredIsValue) return isValue;
		hasRequiredIsValue = 1;

		var _undefined = requireNoop()(); // Support ES3 engines

		isValue = function (val) { return val !== _undefined && val !== null; };
		return isValue;
	}

	var shim$8;
	var hasRequiredShim$8;

	function requireShim$8 () {
		if (hasRequiredShim$8) return shim$8;
		hasRequiredShim$8 = 1;

		var isValue = requireIsValue();

		var keys = Object.keys;

		shim$8 = function (object) { return keys(isValue(object) ? Object(object) : object); };
		return shim$8;
	}

	var keys;
	var hasRequiredKeys;

	function requireKeys () {
		if (hasRequiredKeys) return keys;
		hasRequiredKeys = 1;

		keys = requireIsImplemented$9()() ? Object.keys : requireShim$8();
		return keys;
	}

	var validValue;
	var hasRequiredValidValue;

	function requireValidValue () {
		if (hasRequiredValidValue) return validValue;
		hasRequiredValidValue = 1;

		var isValue = requireIsValue();

		validValue = function (value) {
			if (!isValue(value)) throw new TypeError("Cannot use null or undefined");
			return value;
		};
		return validValue;
	}

	var shim$7;
	var hasRequiredShim$7;

	function requireShim$7 () {
		if (hasRequiredShim$7) return shim$7;
		hasRequiredShim$7 = 1;

		var keys  = requireKeys()
		  , value = requireValidValue()
		  , max   = Math.max;

		shim$7 = function (dest, src /*, srcn*/) {
			var error, i, length = max(arguments.length, 2), assign;
			dest = Object(value(dest));
			assign = function (key) {
				try {
					dest[key] = src[key];
				} catch (e) {
					if (!error) error = e;
				}
			};
			for (i = 1; i < length; ++i) {
				src = arguments[i];
				keys(src).forEach(assign);
			}
			if (error !== undefined) throw error;
			return dest;
		};
		return shim$7;
	}

	var assign;
	var hasRequiredAssign;

	function requireAssign () {
		if (hasRequiredAssign) return assign;
		hasRequiredAssign = 1;

		assign = requireIsImplemented$a()() ? Object.assign : requireShim$7();
		return assign;
	}

	var normalizeOptions$1;
	var hasRequiredNormalizeOptions;

	function requireNormalizeOptions () {
		if (hasRequiredNormalizeOptions) return normalizeOptions$1;
		hasRequiredNormalizeOptions = 1;

		var isValue = requireIsValue();

		var forEach = Array.prototype.forEach, create = Object.create;

		var process = function (src, obj) {
			var key;
			for (key in src) obj[key] = src[key];
		};

		// eslint-disable-next-line no-unused-vars
		normalizeOptions$1 = function (opts1 /*, options*/) {
			var result = create(null);
			forEach.call(arguments, function (options) {
				if (!isValue(options)) return;
				process(Object(options), result);
			});
			return result;
		};
		return normalizeOptions$1;
	}

	var isImplemented$8;
	var hasRequiredIsImplemented$8;

	function requireIsImplemented$8 () {
		if (hasRequiredIsImplemented$8) return isImplemented$8;
		hasRequiredIsImplemented$8 = 1;

		var str = "razdwatrzy";

		isImplemented$8 = function () {
			if (typeof str.contains !== "function") return false;
			return str.contains("dwa") === true && str.contains("foo") === false;
		};
		return isImplemented$8;
	}

	var shim$6;
	var hasRequiredShim$6;

	function requireShim$6 () {
		if (hasRequiredShim$6) return shim$6;
		hasRequiredShim$6 = 1;

		var indexOf = String.prototype.indexOf;

		shim$6 = function (searchString /*, position*/) {
			return indexOf.call(this, searchString, arguments[1]) > -1;
		};
		return shim$6;
	}

	var contains;
	var hasRequiredContains;

	function requireContains () {
		if (hasRequiredContains) return contains;
		hasRequiredContains = 1;

		contains = requireIsImplemented$8()() ? String.prototype.contains : requireShim$6();
		return contains;
	}

	var hasRequiredD;

	function requireD () {
		if (hasRequiredD) return d.exports;
		hasRequiredD = 1;

		var isValue         = requireIs$5()
		  , isPlainFunction = requireIs$1()
		  , assign          = requireAssign()
		  , normalizeOpts   = requireNormalizeOptions()
		  , contains        = requireContains();

		var d$1 = (d.exports = function (dscr, value/*, options*/) {
			var c, e, w, options, desc;
			if (arguments.length < 2 || typeof dscr !== "string") {
				options = value;
				value = dscr;
				dscr = null;
			} else {
				options = arguments[2];
			}
			if (isValue(dscr)) {
				c = contains.call(dscr, "c");
				e = contains.call(dscr, "e");
				w = contains.call(dscr, "w");
			} else {
				c = w = true;
				e = false;
			}

			desc = { value: value, configurable: c, enumerable: e, writable: w };
			return !options ? desc : assign(normalizeOpts(options), desc);
		});

		d$1.gs = function (dscr, get, set/*, options*/) {
			var c, e, options, desc;
			if (typeof dscr !== "string") {
				options = set;
				set = get;
				get = dscr;
				dscr = null;
			} else {
				options = arguments[3];
			}
			if (!isValue(get)) {
				get = undefined;
			} else if (!isPlainFunction(get)) {
				options = get;
				get = set = undefined;
			} else if (!isValue(set)) {
				set = undefined;
			} else if (!isPlainFunction(set)) {
				options = set;
				set = undefined;
			}
			if (isValue(dscr)) {
				c = contains.call(dscr, "c");
				e = contains.call(dscr, "e");
			} else {
				c = true;
				e = false;
			}

			desc = { get: get, set: set, configurable: c, enumerable: e };
			return !options ? desc : assign(normalizeOpts(options), desc);
		};
		return d.exports;
	}

	var validCallable;
	var hasRequiredValidCallable;

	function requireValidCallable () {
		if (hasRequiredValidCallable) return validCallable;
		hasRequiredValidCallable = 1;

		validCallable = function (fn) {
			if (typeof fn !== "function") throw new TypeError(fn + " is not a function");
			return fn;
		};
		return validCallable;
	}

	var _iterate;
	var hasRequired_iterate;

	function require_iterate () {
		if (hasRequired_iterate) return _iterate;
		hasRequired_iterate = 1;

		var callable                = requireValidCallable()
		  , value                   = requireValidValue()
		  , bind                    = Function.prototype.bind
		  , call                    = Function.prototype.call
		  , keys                    = Object.keys
		  , objPropertyIsEnumerable = Object.prototype.propertyIsEnumerable;

		_iterate = function (method, defVal) {
			return function (obj, cb /*, thisArg, compareFn*/) {
				var list, thisArg = arguments[2], compareFn = arguments[3];
				obj = Object(value(obj));
				callable(cb);

				list = keys(obj);
				if (compareFn) {
					list.sort(typeof compareFn === "function" ? bind.call(compareFn, obj) : undefined);
				}
				if (typeof method !== "function") method = list[method];
				return call.call(method, list, function (key, index) {
					if (!objPropertyIsEnumerable.call(obj, key)) return defVal;
					return call.call(cb, thisArg, obj[key], key, obj, index);
				});
			};
		};
		return _iterate;
	}

	var forEach;
	var hasRequiredForEach;

	function requireForEach () {
		if (hasRequiredForEach) return forEach;
		hasRequiredForEach = 1;

		forEach = require_iterate()("forEach");
		return forEach;
	}

	var map$1;
	var hasRequiredMap;

	function requireMap () {
		if (hasRequiredMap) return map$1;
		hasRequiredMap = 1;

		var callable = requireValidCallable()
		  , forEach  = requireForEach()
		  , call     = Function.prototype.call;

		map$1 = function (obj, cb /*, thisArg*/) {
			var result = {}, thisArg = arguments[2];
			callable(cb);
			forEach(obj, function (value, key, targetObj, index) {
				result[key] = call.call(cb, thisArg, value, key, targetObj, index);
			});
			return result;
		};
		return map$1;
	}

	var primitiveSet;
	var hasRequiredPrimitiveSet;

	function requirePrimitiveSet () {
		if (hasRequiredPrimitiveSet) return primitiveSet;
		hasRequiredPrimitiveSet = 1;

		var forEach = Array.prototype.forEach, create = Object.create;

		// eslint-disable-next-line no-unused-vars
		primitiveSet = function (arg /*, args*/) {
			var set = create(null);
			forEach.call(arguments, function (name) { set[name] = true; });
			return set;
		};
		return primitiveSet;
	}

	var isImplemented$7;
	var hasRequiredIsImplemented$7;

	function requireIsImplemented$7 () {
		if (hasRequiredIsImplemented$7) return isImplemented$7;
		hasRequiredIsImplemented$7 = 1;

		var create = Object.create, getPrototypeOf = Object.getPrototypeOf, plainObject = {};

		isImplemented$7 = function (/* CustomCreate*/) {
			var setPrototypeOf = Object.setPrototypeOf, customCreate = arguments[0] || create;
			if (typeof setPrototypeOf !== "function") return false;
			return getPrototypeOf(setPrototypeOf(customCreate(null), plainObject)) === plainObject;
		};
		return isImplemented$7;
	}

	var isObject$2;
	var hasRequiredIsObject;

	function requireIsObject () {
		if (hasRequiredIsObject) return isObject$2;
		hasRequiredIsObject = 1;

		var isValue = requireIsValue();

		var map = { function: true, object: true };

		isObject$2 = function (value) { return (isValue(value) && map[typeof value]) || false; };
		return isObject$2;
	}

	var create_1;
	var hasRequiredCreate;

	function requireCreate () {
		if (hasRequiredCreate) return create_1;
		hasRequiredCreate = 1;

		var create = Object.create, shim;

		if (!requireIsImplemented$7()()) {
			shim = requireShim$5();
		}

		create_1 = (function () {
			var nullObject, polyProps, desc;
			if (!shim) return create;
			if (shim.level !== 1) return create;

			nullObject = {};
			polyProps = {};
			desc = { configurable: false, enumerable: false, writable: true, value: undefined };
			Object.getOwnPropertyNames(Object.prototype).forEach(function (name) {
				if (name === "__proto__") {
					polyProps[name] = {
						configurable: true,
						enumerable: false,
						writable: true,
						value: undefined
					};
					return;
				}
				polyProps[name] = desc;
			});
			Object.defineProperties(nullObject, polyProps);

			Object.defineProperty(shim, "nullPolyfill", {
				configurable: false,
				enumerable: false,
				writable: false,
				value: nullObject
			});

			return function (prototype, props) {
				return create(prototype === null ? nullObject : prototype, props);
			};
		})();
		return create_1;
	}

	/* eslint no-proto: "off" */

	var shim$5;
	var hasRequiredShim$5;

	function requireShim$5 () {
		if (hasRequiredShim$5) return shim$5;
		hasRequiredShim$5 = 1;

		var isObject         = requireIsObject()
		  , value            = requireValidValue()
		  , objIsPrototypeOf = Object.prototype.isPrototypeOf
		  , defineProperty   = Object.defineProperty
		  , nullDesc         = { configurable: true, enumerable: false, writable: true, value: undefined }
		  , validate;

		validate = function (obj, prototype) {
			value(obj);
			if (prototype === null || isObject(prototype)) return obj;
			throw new TypeError("Prototype must be null or an object");
		};

		shim$5 = (function (status) {
			var fn, set;
			if (!status) return null;
			if (status.level === 2) {
				if (status.set) {
					set = status.set;
					fn = function (obj, prototype) {
						set.call(validate(obj, prototype), prototype);
						return obj;
					};
				} else {
					fn = function (obj, prototype) {
						validate(obj, prototype).__proto__ = prototype;
						return obj;
					};
				}
			} else {
				fn = function self(obj, prototype) {
					var isNullBase;
					validate(obj, prototype);
					isNullBase = objIsPrototypeOf.call(self.nullPolyfill, obj);
					if (isNullBase) delete self.nullPolyfill.__proto__;
					if (prototype === null) prototype = self.nullPolyfill;
					obj.__proto__ = prototype;
					if (isNullBase) defineProperty(self.nullPolyfill, "__proto__", nullDesc);
					return obj;
				};
			}
			return Object.defineProperty(fn, "level", {
				configurable: false,
				enumerable: false,
				writable: false,
				value: status.level
			});
		})(
			(function () {
				var tmpObj1 = Object.create(null)
				  , tmpObj2 = {}
				  , set
				  , desc = Object.getOwnPropertyDescriptor(Object.prototype, "__proto__");

				if (desc) {
					try {
						set = desc.set; // Opera crashes at this point
						set.call(tmpObj1, tmpObj2);
					} catch (ignore) {}
					if (Object.getPrototypeOf(tmpObj1) === tmpObj2) return { set: set, level: 2 };
				}

				tmpObj1.__proto__ = tmpObj2;
				if (Object.getPrototypeOf(tmpObj1) === tmpObj2) return { level: 2 };

				tmpObj1 = {};
				tmpObj1.__proto__ = tmpObj2;
				if (Object.getPrototypeOf(tmpObj1) === tmpObj2) return { level: 1 };

				return false;
			})()
		);

		requireCreate();
		return shim$5;
	}

	var setPrototypeOf;
	var hasRequiredSetPrototypeOf;

	function requireSetPrototypeOf () {
		if (hasRequiredSetPrototypeOf) return setPrototypeOf;
		hasRequiredSetPrototypeOf = 1;

		setPrototypeOf = requireIsImplemented$7()() ? Object.setPrototypeOf : requireShim$5();
		return setPrototypeOf;
	}

	var isImplemented$6;
	var hasRequiredIsImplemented$6;

	function requireIsImplemented$6 () {
		if (hasRequiredIsImplemented$6) return isImplemented$6;
		hasRequiredIsImplemented$6 = 1;

		isImplemented$6 = function () {
			var sign = Math.sign;
			if (typeof sign !== "function") return false;
			return sign(10) === 1 && sign(-20) === -1;
		};
		return isImplemented$6;
	}

	var shim$4;
	var hasRequiredShim$4;

	function requireShim$4 () {
		if (hasRequiredShim$4) return shim$4;
		hasRequiredShim$4 = 1;

		shim$4 = function (value) {
			value = Number(value);
			if (isNaN(value) || value === 0) return value;
			return value > 0 ? 1 : -1;
		};
		return shim$4;
	}

	var sign;
	var hasRequiredSign;

	function requireSign () {
		if (hasRequiredSign) return sign;
		hasRequiredSign = 1;

		sign = requireIsImplemented$6()() ? Math.sign : requireShim$4();
		return sign;
	}

	var toInteger;
	var hasRequiredToInteger;

	function requireToInteger () {
		if (hasRequiredToInteger) return toInteger;
		hasRequiredToInteger = 1;

		var sign  = requireSign()
		  , abs   = Math.abs
		  , floor = Math.floor;

		toInteger = function (value) {
			if (isNaN(value)) return 0;
			value = Number(value);
			if (value === 0 || !isFinite(value)) return value;
			return sign(value) * floor(abs(value));
		};
		return toInteger;
	}

	var toPosInteger;
	var hasRequiredToPosInteger;

	function requireToPosInteger () {
		if (hasRequiredToPosInteger) return toPosInteger;
		hasRequiredToPosInteger = 1;

		var toInteger = requireToInteger()
		  , max       = Math.max;

		toPosInteger = function (value) { return max(0, toInteger(value)); };
		return toPosInteger;
	}

	var resolveLength;
	var hasRequiredResolveLength;

	function requireResolveLength () {
		if (hasRequiredResolveLength) return resolveLength;
		hasRequiredResolveLength = 1;

		var toPosInt = requireToPosInteger();

		resolveLength = function (optsLength, fnLength, isAsync) {
			var length;
			if (isNaN(optsLength)) {
				length = fnLength;
				if (!(length >= 0)) return 1;
				if (isAsync && length) return length - 1;
				return length;
			}
			if (optsLength === false) return false;
			return toPosInt(optsLength);
		};
		return resolveLength;
	}

	var registeredExtensions = {};

	var hasRequiredRegisteredExtensions;

	function requireRegisteredExtensions () {
		if (hasRequiredRegisteredExtensions) return registeredExtensions;
		hasRequiredRegisteredExtensions = 1;
		return registeredExtensions;
	}

	var custom = {exports: {}};

	var hasRequiredCustom;

	function requireCustom () {
		if (hasRequiredCustom) return custom.exports;
		hasRequiredCustom = 1;
		(function (module) {

			var assign            = requireAssign()
			  , isObject          = requireIsObject()
			  , isValue           = requireIsValue()
			  , captureStackTrace = Error.captureStackTrace;

			module.exports = function (message /*, code, ext*/) {
				var err = new Error(message), code = arguments[1], ext = arguments[2];
				if (!isValue(ext)) {
					if (isObject(code)) {
						ext = code;
						code = null;
					}
				}
				if (isValue(ext)) assign(err, ext);
				if (isValue(code)) err.code = code;
				if (captureStackTrace) captureStackTrace(err, module.exports);
				return err;
			}; 
		} (custom));
		return custom.exports;
	}

	var _defineLength = {exports: {}};

	var mixin;
	var hasRequiredMixin;

	function requireMixin () {
		if (hasRequiredMixin) return mixin;
		hasRequiredMixin = 1;

		var value                    = requireValidValue()
		  , defineProperty           = Object.defineProperty
		  , getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor
		  , getOwnPropertyNames      = Object.getOwnPropertyNames
		  , getOwnPropertySymbols    = Object.getOwnPropertySymbols;

		mixin = function (target, source) {
			var error, sourceObject = Object(value(source));
			target = Object(value(target));
			getOwnPropertyNames(sourceObject).forEach(function (name) {
				try {
					defineProperty(target, name, getOwnPropertyDescriptor(source, name));
				} catch (e) { error = e; }
			});
			if (typeof getOwnPropertySymbols === "function") {
				getOwnPropertySymbols(sourceObject).forEach(function (symbol) {
					try {
						defineProperty(target, symbol, getOwnPropertyDescriptor(source, symbol));
					} catch (e) { error = e; }
				});
			}
			if (error !== undefined) throw error;
			return target;
		};
		return mixin;
	}

	var hasRequired_defineLength;

	function require_defineLength () {
		if (hasRequired_defineLength) return _defineLength.exports;
		hasRequired_defineLength = 1;

		var toPosInt = requireToPosInteger();

		var test = function (arg1, arg2) { return arg2; };

		var desc, defineProperty, generate, mixin;

		try {
			Object.defineProperty(test, "length", {
				configurable: true,
				writable: false,
				enumerable: false,
				value: 1
			});
		}
		catch (ignore) {}

		if (test.length === 1) {
			// ES6
			desc = { configurable: true, writable: false, enumerable: false };
			defineProperty = Object.defineProperty;
			_defineLength.exports = function (fn, length) {
				length = toPosInt(length);
				if (fn.length === length) return fn;
				desc.value = length;
				return defineProperty(fn, "length", desc);
			};
		} else {
			mixin = requireMixin();
			generate = (function () {
				var cache = [];
				return function (length) {
					var args, i = 0;
					if (cache[length]) return cache[length];
					args = [];
					while (length--) args.push("a" + (++i).toString(36));
					// eslint-disable-next-line no-new-func
					return new Function(
						"fn",
						"return function (" + args.join(", ") + ") { return fn.apply(this, arguments); };"
					);
				};
			})();
			_defineLength.exports = function (src, length) {
				var target;
				length = toPosInt(length);
				if (src.length === length) return src;
				target = generate(length)(src);
				try { mixin(target, src); }
				catch (ignore) {}
				return target;
			};
		}
		return _defineLength.exports;
	}

	var eventEmitter = {exports: {}};

	var hasRequiredEventEmitter;

	function requireEventEmitter () {
		if (hasRequiredEventEmitter) return eventEmitter.exports;
		hasRequiredEventEmitter = 1;
		(function (module, exports) {

			var d        = requireD()
			  , callable = requireValidCallable()

			  , apply = Function.prototype.apply, call = Function.prototype.call
			  , create = Object.create, defineProperty = Object.defineProperty
			  , defineProperties = Object.defineProperties
			  , hasOwnProperty = Object.prototype.hasOwnProperty
			  , descriptor = { configurable: true, enumerable: false, writable: true }

			  , on, once, off, emit, methods, descriptors, base;

			on = function (type, listener) {
				var data;

				callable(listener);

				if (!hasOwnProperty.call(this, '__ee__')) {
					data = descriptor.value = create(null);
					defineProperty(this, '__ee__', descriptor);
					descriptor.value = null;
				} else {
					data = this.__ee__;
				}
				if (!data[type]) data[type] = listener;
				else if (typeof data[type] === 'object') data[type].push(listener);
				else data[type] = [data[type], listener];

				return this;
			};

			once = function (type, listener) {
				var once, self;

				callable(listener);
				self = this;
				on.call(this, type, once = function () {
					off.call(self, type, once);
					apply.call(listener, this, arguments);
				});

				once.__eeOnceListener__ = listener;
				return this;
			};

			off = function (type, listener) {
				var data, listeners, candidate, i;

				callable(listener);

				if (!hasOwnProperty.call(this, '__ee__')) return this;
				data = this.__ee__;
				if (!data[type]) return this;
				listeners = data[type];

				if (typeof listeners === 'object') {
					for (i = 0; (candidate = listeners[i]); ++i) {
						if ((candidate === listener) ||
								(candidate.__eeOnceListener__ === listener)) {
							if (listeners.length === 2) data[type] = listeners[i ? 0 : 1];
							else listeners.splice(i, 1);
						}
					}
				} else {
					if ((listeners === listener) ||
							(listeners.__eeOnceListener__ === listener)) {
						delete data[type];
					}
				}

				return this;
			};

			emit = function (type) {
				var i, l, listener, listeners, args;

				if (!hasOwnProperty.call(this, '__ee__')) return;
				listeners = this.__ee__[type];
				if (!listeners) return;

				if (typeof listeners === 'object') {
					l = arguments.length;
					args = new Array(l - 1);
					for (i = 1; i < l; ++i) args[i - 1] = arguments[i];

					listeners = listeners.slice();
					for (i = 0; (listener = listeners[i]); ++i) {
						apply.call(listener, this, args);
					}
				} else {
					switch (arguments.length) {
					case 1:
						call.call(listeners, this);
						break;
					case 2:
						call.call(listeners, this, arguments[1]);
						break;
					case 3:
						call.call(listeners, this, arguments[1], arguments[2]);
						break;
					default:
						l = arguments.length;
						args = new Array(l - 1);
						for (i = 1; i < l; ++i) {
							args[i - 1] = arguments[i];
						}
						apply.call(listeners, this, args);
					}
				}
			};

			methods = {
				on: on,
				once: once,
				off: off,
				emit: emit
			};

			descriptors = {
				on: d(on),
				once: d(once),
				off: d(off),
				emit: d(emit)
			};

			base = defineProperties({}, descriptors);

			module.exports = exports = function (o) {
				return (o == null) ? create(base) : defineProperties(Object(o), descriptors);
			};
			exports.methods = methods; 
		} (eventEmitter, eventEmitter.exports));
		return eventEmitter.exports;
	}

	var isImplemented$5;
	var hasRequiredIsImplemented$5;

	function requireIsImplemented$5 () {
		if (hasRequiredIsImplemented$5) return isImplemented$5;
		hasRequiredIsImplemented$5 = 1;

		isImplemented$5 = function () {
			var from = Array.from, arr, result;
			if (typeof from !== "function") return false;
			arr = ["raz", "dwa"];
			result = from(arr);
			return Boolean(result && result !== arr && result[1] === "dwa");
		};
		return isImplemented$5;
	}

	var isImplemented$4;
	var hasRequiredIsImplemented$4;

	function requireIsImplemented$4 () {
		if (hasRequiredIsImplemented$4) return isImplemented$4;
		hasRequiredIsImplemented$4 = 1;

		isImplemented$4 = function () {
			if (typeof globalThis !== "object") return false;
			if (!globalThis) return false;
			return globalThis.Array === Array;
		};
		return isImplemented$4;
	}

	var implementation;
	var hasRequiredImplementation;

	function requireImplementation () {
		if (hasRequiredImplementation) return implementation;
		hasRequiredImplementation = 1;
		var naiveFallback = function () {
			if (typeof self === "object" && self) return self;
			if (typeof window === "object" && window) return window;
			throw new Error("Unable to resolve global `this`");
		};

		implementation = (function () {
			if (this) return this;

			// Unexpected strict mode (may happen if e.g. bundled into ESM module)

			// Thanks @mathiasbynens -> https://mathiasbynens.be/notes/globalthis
			// In all ES5+ engines global object inherits from Object.prototype
			// (if you approached one that doesn't please report)
			try {
				Object.defineProperty(Object.prototype, "__global__", {
					get: function () { return this; },
					configurable: true
				});
			} catch (error) {
				// Unfortunate case of Object.prototype being sealed (via preventExtensions, seal or freeze)
				return naiveFallback();
			}
			try {
				// Safari case (window.__global__ is resolved with global context, but __global__ does not)
				if (!__global__) return naiveFallback();
				return __global__;
			} finally {
				delete Object.prototype.__global__;
			}
		})();
		return implementation;
	}

	var globalThis_1;
	var hasRequiredGlobalThis;

	function requireGlobalThis () {
		if (hasRequiredGlobalThis) return globalThis_1;
		hasRequiredGlobalThis = 1;

		globalThis_1 = requireIsImplemented$4()() ? globalThis : requireImplementation();
		return globalThis_1;
	}

	var isImplemented$3;
	var hasRequiredIsImplemented$3;

	function requireIsImplemented$3 () {
		if (hasRequiredIsImplemented$3) return isImplemented$3;
		hasRequiredIsImplemented$3 = 1;

		var global     = requireGlobalThis()
		  , validTypes = { object: true, symbol: true };

		isImplemented$3 = function () {
			var Symbol = global.Symbol;
			var symbol;
			if (typeof Symbol !== "function") return false;
			symbol = Symbol("test symbol");
			try { String(symbol); }
			catch (e) { return false; }

			// Return 'true' also for polyfills
			if (!validTypes[typeof Symbol.iterator]) return false;
			if (!validTypes[typeof Symbol.toPrimitive]) return false;
			if (!validTypes[typeof Symbol.toStringTag]) return false;

			return true;
		};
		return isImplemented$3;
	}

	var isSymbol$1;
	var hasRequiredIsSymbol;

	function requireIsSymbol () {
		if (hasRequiredIsSymbol) return isSymbol$1;
		hasRequiredIsSymbol = 1;

		isSymbol$1 = function (value) {
			if (!value) return false;
			if (typeof value === "symbol") return true;
			if (!value.constructor) return false;
			if (value.constructor.name !== "Symbol") return false;
			return value[value.constructor.toStringTag] === "Symbol";
		};
		return isSymbol$1;
	}

	var validateSymbol;
	var hasRequiredValidateSymbol;

	function requireValidateSymbol () {
		if (hasRequiredValidateSymbol) return validateSymbol;
		hasRequiredValidateSymbol = 1;

		var isSymbol = requireIsSymbol();

		validateSymbol = function (value) {
			if (!isSymbol(value)) throw new TypeError(value + " is not a symbol");
			return value;
		};
		return validateSymbol;
	}

	var generateName$1;
	var hasRequiredGenerateName;

	function requireGenerateName () {
		if (hasRequiredGenerateName) return generateName$1;
		hasRequiredGenerateName = 1;

		var d = requireD();

		var create = Object.create, defineProperty = Object.defineProperty, objPrototype = Object.prototype;

		var created = create(null);
		generateName$1 = function (desc) {
			var postfix = 0, name, ie11BugWorkaround;
			while (created[desc + (postfix || "")]) ++postfix;
			desc += postfix || "";
			created[desc] = true;
			name = "@@" + desc;
			defineProperty(
				objPrototype, name,
				d.gs(null, function (value) {
					// For IE11 issue see:
					// https://connect.microsoft.com/IE/feedbackdetail/view/1928508/
					//    ie11-broken-getters-on-dom-objects
					// https://github.com/medikoo/es6-symbol/issues/12
					if (ie11BugWorkaround) return;
					ie11BugWorkaround = true;
					defineProperty(this, name, d(value));
					ie11BugWorkaround = false;
				})
			);
			return name;
		};
		return generateName$1;
	}

	var standardSymbols;
	var hasRequiredStandardSymbols;

	function requireStandardSymbols () {
		if (hasRequiredStandardSymbols) return standardSymbols;
		hasRequiredStandardSymbols = 1;

		var d            = requireD()
		  , NativeSymbol = requireGlobalThis().Symbol;

		standardSymbols = function (SymbolPolyfill) {
			return Object.defineProperties(SymbolPolyfill, {
				// To ensure proper interoperability with other native functions (e.g. Array.from)
				// fallback to eventual native implementation of given symbol
				hasInstance: d(
					"", (NativeSymbol && NativeSymbol.hasInstance) || SymbolPolyfill("hasInstance")
				),
				isConcatSpreadable: d(
					"",
					(NativeSymbol && NativeSymbol.isConcatSpreadable) ||
						SymbolPolyfill("isConcatSpreadable")
				),
				iterator: d("", (NativeSymbol && NativeSymbol.iterator) || SymbolPolyfill("iterator")),
				match: d("", (NativeSymbol && NativeSymbol.match) || SymbolPolyfill("match")),
				replace: d("", (NativeSymbol && NativeSymbol.replace) || SymbolPolyfill("replace")),
				search: d("", (NativeSymbol && NativeSymbol.search) || SymbolPolyfill("search")),
				species: d("", (NativeSymbol && NativeSymbol.species) || SymbolPolyfill("species")),
				split: d("", (NativeSymbol && NativeSymbol.split) || SymbolPolyfill("split")),
				toPrimitive: d(
					"", (NativeSymbol && NativeSymbol.toPrimitive) || SymbolPolyfill("toPrimitive")
				),
				toStringTag: d(
					"", (NativeSymbol && NativeSymbol.toStringTag) || SymbolPolyfill("toStringTag")
				),
				unscopables: d(
					"", (NativeSymbol && NativeSymbol.unscopables) || SymbolPolyfill("unscopables")
				)
			});
		};
		return standardSymbols;
	}

	var symbolRegistry;
	var hasRequiredSymbolRegistry;

	function requireSymbolRegistry () {
		if (hasRequiredSymbolRegistry) return symbolRegistry;
		hasRequiredSymbolRegistry = 1;

		var d              = requireD()
		  , validateSymbol = requireValidateSymbol();

		var registry = Object.create(null);

		symbolRegistry = function (SymbolPolyfill) {
			return Object.defineProperties(SymbolPolyfill, {
				for: d(function (key) {
					if (registry[key]) return registry[key];
					return (registry[key] = SymbolPolyfill(String(key)));
				}),
				keyFor: d(function (symbol) {
					var key;
					validateSymbol(symbol);
					for (key in registry) {
						if (registry[key] === symbol) return key;
					}
					return undefined;
				})
			});
		};
		return symbolRegistry;
	}

	var polyfill;
	var hasRequiredPolyfill;

	function requirePolyfill () {
		if (hasRequiredPolyfill) return polyfill;
		hasRequiredPolyfill = 1;

		var d                    = requireD()
		  , validateSymbol       = requireValidateSymbol()
		  , NativeSymbol         = requireGlobalThis().Symbol
		  , generateName         = requireGenerateName()
		  , setupStandardSymbols = requireStandardSymbols()
		  , setupSymbolRegistry  = requireSymbolRegistry();

		var create = Object.create
		  , defineProperties = Object.defineProperties
		  , defineProperty = Object.defineProperty;

		var SymbolPolyfill, HiddenSymbol, isNativeSafe;

		if (typeof NativeSymbol === "function") {
			try {
				String(NativeSymbol());
				isNativeSafe = true;
			} catch (ignore) {}
		} else {
			NativeSymbol = null;
		}

		// Internal constructor (not one exposed) for creating Symbol instances.
		// This one is used to ensure that `someSymbol instanceof Symbol` always return false
		HiddenSymbol = function Symbol(description) {
			if (this instanceof HiddenSymbol) throw new TypeError("Symbol is not a constructor");
			return SymbolPolyfill(description);
		};

		// Exposed `Symbol` constructor
		// (returns instances of HiddenSymbol)
		polyfill = SymbolPolyfill = function Symbol(description) {
			var symbol;
			if (this instanceof Symbol) throw new TypeError("Symbol is not a constructor");
			if (isNativeSafe) return NativeSymbol(description);
			symbol = create(HiddenSymbol.prototype);
			description = description === undefined ? "" : String(description);
			return defineProperties(symbol, {
				__description__: d("", description),
				__name__: d("", generateName(description))
			});
		};

		setupStandardSymbols(SymbolPolyfill);
		setupSymbolRegistry(SymbolPolyfill);

		// Internal tweaks for real symbol producer
		defineProperties(HiddenSymbol.prototype, {
			constructor: d(SymbolPolyfill),
			toString: d("", function () { return this.__name__; })
		});

		// Proper implementation of methods exposed on Symbol.prototype
		// They won't be accessible on produced symbol instances as they derive from HiddenSymbol.prototype
		defineProperties(SymbolPolyfill.prototype, {
			toString: d(function () { return "Symbol (" + validateSymbol(this).__description__ + ")"; }),
			valueOf: d(function () { return validateSymbol(this); })
		});
		defineProperty(
			SymbolPolyfill.prototype, SymbolPolyfill.toPrimitive,
			d("", function () {
				var symbol = validateSymbol(this);
				if (typeof symbol === "symbol") return symbol;
				return symbol.toString();
			})
		);
		defineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toStringTag, d("c", "Symbol"));

		// Proper implementaton of toPrimitive and toStringTag for returned symbol instances
		defineProperty(
			HiddenSymbol.prototype, SymbolPolyfill.toStringTag,
			d("c", SymbolPolyfill.prototype[SymbolPolyfill.toStringTag])
		);

		// Note: It's important to define `toPrimitive` as last one, as some implementations
		// implement `toPrimitive` natively without implementing `toStringTag` (or other specified symbols)
		// And that may invoke error in definition flow:
		// See: https://github.com/medikoo/es6-symbol/issues/13#issuecomment-164146149
		defineProperty(
			HiddenSymbol.prototype, SymbolPolyfill.toPrimitive,
			d("c", SymbolPolyfill.prototype[SymbolPolyfill.toPrimitive])
		);
		return polyfill;
	}

	var es6Symbol;
	var hasRequiredEs6Symbol;

	function requireEs6Symbol () {
		if (hasRequiredEs6Symbol) return es6Symbol;
		hasRequiredEs6Symbol = 1;

		es6Symbol = requireIsImplemented$3()()
			? requireGlobalThis().Symbol
			: requirePolyfill();
		return es6Symbol;
	}

	var isArguments;
	var hasRequiredIsArguments;

	function requireIsArguments () {
		if (hasRequiredIsArguments) return isArguments;
		hasRequiredIsArguments = 1;

		var objToString = Object.prototype.toString
		  , id = objToString.call((function () { return arguments; })());

		isArguments = function (value) { return objToString.call(value) === id; };
		return isArguments;
	}

	var isFunction$1;
	var hasRequiredIsFunction;

	function requireIsFunction () {
		if (hasRequiredIsFunction) return isFunction$1;
		hasRequiredIsFunction = 1;

		var objToString = Object.prototype.toString
		  , isFunctionStringTag = RegExp.prototype.test.bind(/^[object [A-Za-z0-9]*Function]$/);

		isFunction$1 = function (value) {
			return typeof value === "function" && isFunctionStringTag(objToString.call(value));
		};
		return isFunction$1;
	}

	var isString$1;
	var hasRequiredIsString;

	function requireIsString () {
		if (hasRequiredIsString) return isString$1;
		hasRequiredIsString = 1;

		var objToString = Object.prototype.toString, id = objToString.call("");

		isString$1 = function (value) {
			return (
				typeof value === "string" ||
				(value &&
					typeof value === "object" &&
					(value instanceof String || objToString.call(value) === id)) ||
				false
			);
		};
		return isString$1;
	}

	var shim$3;
	var hasRequiredShim$3;

	function requireShim$3 () {
		if (hasRequiredShim$3) return shim$3;
		hasRequiredShim$3 = 1;

		var iteratorSymbol = requireEs6Symbol().iterator
		  , isArguments    = requireIsArguments()
		  , isFunction     = requireIsFunction()
		  , toPosInt       = requireToPosInteger()
		  , callable       = requireValidCallable()
		  , validValue     = requireValidValue()
		  , isValue        = requireIsValue()
		  , isString       = requireIsString()
		  , isArray        = Array.isArray
		  , call           = Function.prototype.call
		  , desc           = { configurable: true, enumerable: true, writable: true, value: null }
		  , defineProperty = Object.defineProperty;

		// eslint-disable-next-line complexity, max-lines-per-function
		shim$3 = function (arrayLike /*, mapFn, thisArg*/) {
			var mapFn = arguments[1]
			  , thisArg = arguments[2]
			  , Context
			  , i
			  , j
			  , arr
			  , length
			  , code
			  , iterator
			  , result
			  , getIterator
			  , value;

			arrayLike = Object(validValue(arrayLike));

			if (isValue(mapFn)) callable(mapFn);
			if (!this || this === Array || !isFunction(this)) {
				// Result: Plain array
				if (!mapFn) {
					if (isArguments(arrayLike)) {
						// Source: Arguments
						length = arrayLike.length;
						if (length !== 1) return Array.apply(null, arrayLike);
						arr = new Array(1);
						arr[0] = arrayLike[0];
						return arr;
					}
					if (isArray(arrayLike)) {
						// Source: Array
						arr = new Array((length = arrayLike.length));
						for (i = 0; i < length; ++i) arr[i] = arrayLike[i];
						return arr;
					}
				}
				arr = [];
			} else {
				// Result: Non plain array
				Context = this;
			}

			if (!isArray(arrayLike)) {
				if ((getIterator = arrayLike[iteratorSymbol]) !== undefined) {
					// Source: Iterator
					iterator = callable(getIterator).call(arrayLike);
					if (Context) arr = new Context();
					result = iterator.next();
					i = 0;
					while (!result.done) {
						value = mapFn ? call.call(mapFn, thisArg, result.value, i) : result.value;
						if (Context) {
							desc.value = value;
							defineProperty(arr, i, desc);
						} else {
							arr[i] = value;
						}
						result = iterator.next();
						++i;
					}
					length = i;
				} else if (isString(arrayLike)) {
					// Source: String
					length = arrayLike.length;
					if (Context) arr = new Context();
					for (i = 0, j = 0; i < length; ++i) {
						value = arrayLike[i];
						if (i + 1 < length) {
							code = value.charCodeAt(0);
							// eslint-disable-next-line max-depth
							if (code >= 0xd800 && code <= 0xdbff) value += arrayLike[++i];
						}
						value = mapFn ? call.call(mapFn, thisArg, value, j) : value;
						if (Context) {
							desc.value = value;
							defineProperty(arr, j, desc);
						} else {
							arr[j] = value;
						}
						++j;
					}
					length = j;
				}
			}
			if (length === undefined) {
				// Source: array or array-like
				length = toPosInt(arrayLike.length);
				if (Context) arr = new Context(length);
				for (i = 0; i < length; ++i) {
					value = mapFn ? call.call(mapFn, thisArg, arrayLike[i], i) : arrayLike[i];
					if (Context) {
						desc.value = value;
						defineProperty(arr, i, desc);
					} else {
						arr[i] = value;
					}
				}
			}
			if (Context) {
				desc.value = null;
				arr.length = length;
			}
			return arr;
		};
		return shim$3;
	}

	var from$1;
	var hasRequiredFrom;

	function requireFrom () {
		if (hasRequiredFrom) return from$1;
		hasRequiredFrom = 1;

		from$1 = requireIsImplemented$5()() ? Array.from : requireShim$3();
		return from$1;
	}

	var toArray$1;
	var hasRequiredToArray;

	function requireToArray () {
		if (hasRequiredToArray) return toArray$1;
		hasRequiredToArray = 1;

		var from    = requireFrom()
		  , isArray = Array.isArray;

		toArray$1 = function (arrayLike) { return isArray(arrayLike) ? arrayLike : from(arrayLike); };
		return toArray$1;
	}

	var resolveResolve;
	var hasRequiredResolveResolve;

	function requireResolveResolve () {
		if (hasRequiredResolveResolve) return resolveResolve;
		hasRequiredResolveResolve = 1;

		var toArray  = requireToArray()
		  , isValue  = requireIsValue()
		  , callable = requireValidCallable();

		var slice = Array.prototype.slice, resolveArgs;

		resolveArgs = function (args) {
			return this.map(function (resolve, i) {
				return resolve ? resolve(args[i]) : args[i];
			}).concat(slice.call(args, this.length));
		};

		resolveResolve = function (resolvers) {
			resolvers = toArray(resolvers);
			resolvers.forEach(function (resolve) {
				if (isValue(resolve)) callable(resolve);
			});
			return resolveArgs.bind(resolvers);
		};
		return resolveResolve;
	}

	var resolveNormalize;
	var hasRequiredResolveNormalize;

	function requireResolveNormalize () {
		if (hasRequiredResolveNormalize) return resolveNormalize;
		hasRequiredResolveNormalize = 1;

		var callable = requireValidCallable();

		resolveNormalize = function (userNormalizer) {
			var normalizer;
			if (typeof userNormalizer === "function") return { set: userNormalizer, get: userNormalizer };
			normalizer = { get: callable(userNormalizer.get) };
			if (userNormalizer.set !== undefined) {
				normalizer.set = callable(userNormalizer.set);
				if (userNormalizer.delete) normalizer.delete = callable(userNormalizer.delete);
				if (userNormalizer.clear) normalizer.clear = callable(userNormalizer.clear);
				return normalizer;
			}
			normalizer.set = normalizer.get;
			return normalizer;
		};
		return resolveNormalize;
	}

	/* eslint no-eq-null: 0, eqeqeq: 0, no-unused-vars: 0 */

	var configureMap;
	var hasRequiredConfigureMap;

	function requireConfigureMap () {
		if (hasRequiredConfigureMap) return configureMap;
		hasRequiredConfigureMap = 1;

		var customError      = requireCustom()
		  , defineLength     = require_defineLength()
		  , d                = requireD()
		  , ee               = requireEventEmitter().methods
		  , resolveResolve   = requireResolveResolve()
		  , resolveNormalize = requireResolveNormalize();

		var apply = Function.prototype.apply
		  , call = Function.prototype.call
		  , create = Object.create
		  , defineProperties = Object.defineProperties
		  , on = ee.on
		  , emit = ee.emit;

		configureMap = function (original, length, options) {
			var cache = create(null)
			  , conf
			  , memLength
			  , get
			  , set
			  , del
			  , clear
			  , extDel
			  , extGet
			  , extHas
			  , normalizer
			  , getListeners
			  , setListeners
			  , deleteListeners
			  , memoized
			  , resolve;
			if (length !== false) memLength = length;
			else if (isNaN(original.length)) memLength = 1;
			else memLength = original.length;

			if (options.normalizer) {
				normalizer = resolveNormalize(options.normalizer);
				get = normalizer.get;
				set = normalizer.set;
				del = normalizer.delete;
				clear = normalizer.clear;
			}
			if (options.resolvers != null) resolve = resolveResolve(options.resolvers);

			if (get) {
				memoized = defineLength(function (arg) {
					var id, result, args = arguments;
					if (resolve) args = resolve(args);
					id = get(args);
					if (id !== null) {
						if (hasOwnProperty.call(cache, id)) {
							if (getListeners) conf.emit("get", id, args, this);
							return cache[id];
						}
					}
					if (args.length === 1) result = call.call(original, this, args[0]);
					else result = apply.call(original, this, args);
					if (id === null) {
						id = get(args);
						if (id !== null) throw customError("Circular invocation", "CIRCULAR_INVOCATION");
						id = set(args);
					} else if (hasOwnProperty.call(cache, id)) {
						throw customError("Circular invocation", "CIRCULAR_INVOCATION");
					}
					cache[id] = result;
					if (setListeners) conf.emit("set", id, null, result);
					return result;
				}, memLength);
			} else if (length === 0) {
				memoized = function () {
					var result;
					if (hasOwnProperty.call(cache, "data")) {
						if (getListeners) conf.emit("get", "data", arguments, this);
						return cache.data;
					}
					if (arguments.length) result = apply.call(original, this, arguments);
					else result = call.call(original, this);
					if (hasOwnProperty.call(cache, "data")) {
						throw customError("Circular invocation", "CIRCULAR_INVOCATION");
					}
					cache.data = result;
					if (setListeners) conf.emit("set", "data", null, result);
					return result;
				};
			} else {
				memoized = function (arg) {
					var result, args = arguments, id;
					if (resolve) args = resolve(arguments);
					id = String(args[0]);
					if (hasOwnProperty.call(cache, id)) {
						if (getListeners) conf.emit("get", id, args, this);
						return cache[id];
					}
					if (args.length === 1) result = call.call(original, this, args[0]);
					else result = apply.call(original, this, args);
					if (hasOwnProperty.call(cache, id)) {
						throw customError("Circular invocation", "CIRCULAR_INVOCATION");
					}
					cache[id] = result;
					if (setListeners) conf.emit("set", id, null, result);
					return result;
				};
			}
			conf = {
				original: original,
				memoized: memoized,
				profileName: options.profileName,
				get: function (args) {
					if (resolve) args = resolve(args);
					if (get) return get(args);
					return String(args[0]);
				},
				has: function (id) { return hasOwnProperty.call(cache, id); },
				delete: function (id) {
					var result;
					if (!hasOwnProperty.call(cache, id)) return;
					if (del) del(id);
					result = cache[id];
					delete cache[id];
					if (deleteListeners) conf.emit("delete", id, result);
				},
				clear: function () {
					var oldCache = cache;
					if (clear) clear();
					cache = create(null);
					conf.emit("clear", oldCache);
				},
				on: function (type, listener) {
					if (type === "get") getListeners = true;
					else if (type === "set") setListeners = true;
					else if (type === "delete") deleteListeners = true;
					return on.call(this, type, listener);
				},
				emit: emit,
				updateEnv: function () { original = conf.original; }
			};
			if (get) {
				extDel = defineLength(function (arg) {
					var id, args = arguments;
					if (resolve) args = resolve(args);
					id = get(args);
					if (id === null) return;
					conf.delete(id);
				}, memLength);
			} else if (length === 0) {
				extDel = function () { return conf.delete("data"); };
			} else {
				extDel = function (arg) {
					if (resolve) arg = resolve(arguments)[0];
					return conf.delete(arg);
				};
			}
			extGet = defineLength(function () {
				var id, args = arguments;
				if (length === 0) return cache.data;
				if (resolve) args = resolve(args);
				if (get) id = get(args);
				else id = String(args[0]);
				return cache[id];
			});
			extHas = defineLength(function () {
				var id, args = arguments;
				if (length === 0) return conf.has("data");
				if (resolve) args = resolve(args);
				if (get) id = get(args);
				else id = String(args[0]);
				if (id === null) return false;
				return conf.has(id);
			});
			defineProperties(memoized, {
				__memoized__: d(true),
				delete: d(extDel),
				clear: d(conf.clear),
				_get: d(extGet),
				_has: d(extHas)
			});
			return conf;
		};
		return configureMap;
	}

	var plain;
	var hasRequiredPlain;

	function requirePlain () {
		if (hasRequiredPlain) return plain;
		hasRequiredPlain = 1;

		var callable      = requireValidCallable()
		  , forEach       = requireForEach()
		  , extensions    = requireRegisteredExtensions()
		  , configure     = requireConfigureMap()
		  , resolveLength = requireResolveLength();

		plain = function self(fn /*, options */) {
			var options, length, conf;

			callable(fn);
			options = Object(arguments[1]);

			if (options.async && options.promise) {
				throw new Error("Options 'async' and 'promise' cannot be used together");
			}

			// Do not memoize already memoized function
			if (hasOwnProperty.call(fn, "__memoized__") && !options.force) return fn;

			// Resolve length;
			length = resolveLength(options.length, fn.length, options.async && extensions.async);

			// Configure cache map
			conf = configure(fn, length, options);

			// Bind eventual extensions
			forEach(extensions, function (extFn, name) {
				if (options[name]) extFn(options[name], conf, options);
			});

			if (self.__profiler__) self.__profiler__(conf);

			conf.updateEnv();
			return conf.memoized;
		};
		return plain;
	}

	var primitive;
	var hasRequiredPrimitive;

	function requirePrimitive () {
		if (hasRequiredPrimitive) return primitive;
		hasRequiredPrimitive = 1;

		primitive = function (args) {
			var id, i, length = args.length;
			if (!length) return "\u0002";
			id = String(args[i = 0]);
			while (--length) id += "\u0001" + args[++i];
			return id;
		};
		return primitive;
	}

	var getPrimitiveFixed;
	var hasRequiredGetPrimitiveFixed;

	function requireGetPrimitiveFixed () {
		if (hasRequiredGetPrimitiveFixed) return getPrimitiveFixed;
		hasRequiredGetPrimitiveFixed = 1;

		getPrimitiveFixed = function (length) {
			if (!length) {
				return function () {
					return "";
				};
			}
			return function (args) {
				var id = String(args[0]), i = 0, currentLength = length;
				while (--currentLength) {
					id += "\u0001" + args[++i];
				}
				return id;
			};
		};
		return getPrimitiveFixed;
	}

	var isImplemented$2;
	var hasRequiredIsImplemented$2;

	function requireIsImplemented$2 () {
		if (hasRequiredIsImplemented$2) return isImplemented$2;
		hasRequiredIsImplemented$2 = 1;

		isImplemented$2 = function () {
			var numberIsNaN = Number.isNaN;
			if (typeof numberIsNaN !== "function") return false;
			return !numberIsNaN({}) && numberIsNaN(NaN) && !numberIsNaN(34);
		};
		return isImplemented$2;
	}

	var shim$2;
	var hasRequiredShim$2;

	function requireShim$2 () {
		if (hasRequiredShim$2) return shim$2;
		hasRequiredShim$2 = 1;

		shim$2 = function (value) {
			// eslint-disable-next-line no-self-compare
			return value !== value;
		};
		return shim$2;
	}

	var isNan;
	var hasRequiredIsNan;

	function requireIsNan () {
		if (hasRequiredIsNan) return isNan;
		hasRequiredIsNan = 1;

		isNan = requireIsImplemented$2()() ? Number.isNaN : requireShim$2();
		return isNan;
	}

	var eIndexOf;
	var hasRequiredEIndexOf;

	function requireEIndexOf () {
		if (hasRequiredEIndexOf) return eIndexOf;
		hasRequiredEIndexOf = 1;

		var numberIsNaN       = requireIsNan()
		  , toPosInt          = requireToPosInteger()
		  , value             = requireValidValue()
		  , indexOf           = Array.prototype.indexOf
		  , objHasOwnProperty = Object.prototype.hasOwnProperty
		  , abs               = Math.abs
		  , floor             = Math.floor;

		eIndexOf = function (searchElement /*, fromIndex*/) {
			var i, length, fromIndex, val;
			if (!numberIsNaN(searchElement)) return indexOf.apply(this, arguments);

			length = toPosInt(value(this).length);
			fromIndex = arguments[1];
			if (isNaN(fromIndex)) fromIndex = 0;
			else if (fromIndex >= 0) fromIndex = floor(fromIndex);
			else fromIndex = toPosInt(this.length) - floor(abs(fromIndex));

			for (i = fromIndex; i < length; ++i) {
				if (objHasOwnProperty.call(this, i)) {
					val = this[i];
					if (numberIsNaN(val)) return i; // Jslint: ignore
				}
			}
			return -1;
		};
		return eIndexOf;
	}

	/* eslint max-statements: 0 */

	var get$1;
	var hasRequiredGet$1;

	function requireGet$1 () {
		if (hasRequiredGet$1) return get$1;
		hasRequiredGet$1 = 1;

		var indexOf = requireEIndexOf();

		var create = Object.create;

		get$1 = function () {
			var lastId = 0, map = [], cache = create(null);
			return {
				get: function (args) {
					var index = 0, set = map, i, length = args.length;
					if (length === 0) return set[length] || null;
					if ((set = set[length])) {
						while (index < length - 1) {
							i = indexOf.call(set[0], args[index]);
							if (i === -1) return null;
							set = set[1][i];
							++index;
						}
						i = indexOf.call(set[0], args[index]);
						if (i === -1) return null;
						return set[1][i] || null;
					}
					return null;
				},
				set: function (args) {
					var index = 0, set = map, i, length = args.length;
					if (length === 0) {
						set[length] = ++lastId;
					} else {
						if (!set[length]) {
							set[length] = [[], []];
						}
						set = set[length];
						while (index < length - 1) {
							i = indexOf.call(set[0], args[index]);
							if (i === -1) {
								i = set[0].push(args[index]) - 1;
								set[1].push([[], []]);
							}
							set = set[1][i];
							++index;
						}
						i = indexOf.call(set[0], args[index]);
						if (i === -1) {
							i = set[0].push(args[index]) - 1;
						}
						set[1][i] = ++lastId;
					}
					cache[lastId] = args;
					return lastId;
				},
				delete: function (id) {
					var index = 0, set = map, i, args = cache[id], length = args.length, path = [];
					if (length === 0) {
						delete set[length];
					} else if ((set = set[length])) {
						while (index < length - 1) {
							i = indexOf.call(set[0], args[index]);
							if (i === -1) {
								return;
							}
							path.push(set, i);
							set = set[1][i];
							++index;
						}
						i = indexOf.call(set[0], args[index]);
						if (i === -1) {
							return;
						}
						id = set[1][i];
						set[0].splice(i, 1);
						set[1].splice(i, 1);
						while (!set[0].length && path.length) {
							i = path.pop();
							set = path.pop();
							set[0].splice(i, 1);
							set[1].splice(i, 1);
						}
					}
					delete cache[id];
				},
				clear: function () {
					map = [];
					cache = create(null);
				}
			};
		};
		return get$1;
	}

	var get1;
	var hasRequiredGet1;

	function requireGet1 () {
		if (hasRequiredGet1) return get1;
		hasRequiredGet1 = 1;

		var indexOf = requireEIndexOf();

		get1 = function () {
			var lastId = 0, argsMap = [], cache = [];
			return {
				get: function (args) {
					var index = indexOf.call(argsMap, args[0]);
					return index === -1 ? null : cache[index];
				},
				set: function (args) {
					argsMap.push(args[0]);
					cache.push(++lastId);
					return lastId;
				},
				delete: function (id) {
					var index = indexOf.call(cache, id);
					if (index !== -1) {
						argsMap.splice(index, 1);
						cache.splice(index, 1);
					}
				},
				clear: function () {
					argsMap = [];
					cache = [];
				}
			};
		};
		return get1;
	}

	var getFixed;
	var hasRequiredGetFixed;

	function requireGetFixed () {
		if (hasRequiredGetFixed) return getFixed;
		hasRequiredGetFixed = 1;

		var indexOf = requireEIndexOf()
		  , create  = Object.create;

		getFixed = function (length) {
			var lastId = 0, map = [[], []], cache = create(null);
			return {
				get: function (args) {
					var index = 0, set = map, i;
					while (index < length - 1) {
						i = indexOf.call(set[0], args[index]);
						if (i === -1) return null;
						set = set[1][i];
						++index;
					}
					i = indexOf.call(set[0], args[index]);
					if (i === -1) return null;
					return set[1][i] || null;
				},
				set: function (args) {
					var index = 0, set = map, i;
					while (index < length - 1) {
						i = indexOf.call(set[0], args[index]);
						if (i === -1) {
							i = set[0].push(args[index]) - 1;
							set[1].push([[], []]);
						}
						set = set[1][i];
						++index;
					}
					i = indexOf.call(set[0], args[index]);
					if (i === -1) {
						i = set[0].push(args[index]) - 1;
					}
					set[1][i] = ++lastId;
					cache[lastId] = args;
					return lastId;
				},
				delete: function (id) {
					var index = 0, set = map, i, path = [], args = cache[id];
					while (index < length - 1) {
						i = indexOf.call(set[0], args[index]);
						if (i === -1) {
							return;
						}
						path.push(set, i);
						set = set[1][i];
						++index;
					}
					i = indexOf.call(set[0], args[index]);
					if (i === -1) {
						return;
					}
					id = set[1][i];
					set[0].splice(i, 1);
					set[1].splice(i, 1);
					while (!set[0].length && path.length) {
						i = path.pop();
						set = path.pop();
						set[0].splice(i, 1);
						set[1].splice(i, 1);
					}
					delete cache[id];
				},
				clear: function () {
					map = [[], []];
					cache = create(null);
				}
			};
		};
		return getFixed;
	}

	var async = {};

	var nextTick;
	var hasRequiredNextTick;

	function requireNextTick () {
		if (hasRequiredNextTick) return nextTick;
		hasRequiredNextTick = 1;

		var ensureCallable = function (fn) {
			if (typeof fn !== 'function') throw new TypeError(fn + " is not a function");
			return fn;
		};

		var byObserver = function (Observer) {
			var node = document.createTextNode(''), queue, currentQueue, i = 0;
			new Observer(function () {
				var callback;
				if (!queue) {
					if (!currentQueue) return;
					queue = currentQueue;
				} else if (currentQueue) {
					queue = currentQueue.concat(queue);
				}
				currentQueue = queue;
				queue = null;
				if (typeof currentQueue === 'function') {
					callback = currentQueue;
					currentQueue = null;
					callback();
					return;
				}
				node.data = (i = ++i % 2); // Invoke other batch, to handle leftover callbacks in case of crash
				while (currentQueue) {
					callback = currentQueue.shift();
					if (!currentQueue.length) currentQueue = null;
					callback();
				}
			}).observe(node, { characterData: true });
			return function (fn) {
				ensureCallable(fn);
				if (queue) {
					if (typeof queue === 'function') queue = [queue, fn];
					else queue.push(fn);
					return;
				}
				queue = fn;
				node.data = (i = ++i % 2);
			};
		};

		nextTick = (function () {
			// Node.js
			if ((typeof browser$1 === 'object') && browser$1 && (typeof browser$1.nextTick === 'function')) {
				return browser$1.nextTick;
			}

			// queueMicrotask
			if (typeof queueMicrotask === "function") {
				return function (cb) { queueMicrotask(ensureCallable(cb)); };
			}

			// MutationObserver
			if ((typeof document === 'object') && document) {
				if (typeof MutationObserver === 'function') return byObserver(MutationObserver);
				if (typeof WebKitMutationObserver === 'function') return byObserver(WebKitMutationObserver);
			}

			// W3C Draft
			// http://dvcs.w3.org/hg/webperf/raw-file/tip/specs/setImmediate/Overview.html
			if (typeof setImmediate === 'function') {
				return function (cb) { setImmediate(ensureCallable(cb)); };
			}

			// Wide available standard
			if ((typeof setTimeout === 'function') || (typeof setTimeout === 'object')) {
				return function (cb) { setTimeout(ensureCallable(cb), 0); };
			}

			return null;
		}());
		return nextTick;
	}

	/* eslint consistent-this: 0, no-shadow:0, no-eq-null: 0, eqeqeq: 0, no-unused-vars: 0 */

	var hasRequiredAsync;

	function requireAsync () {
		if (hasRequiredAsync) return async;
		hasRequiredAsync = 1;

		var aFrom        = requireFrom()
		  , objectMap    = requireMap()
		  , mixin        = requireMixin()
		  , defineLength = require_defineLength()
		  , nextTick     = requireNextTick();

		var slice = Array.prototype.slice, apply = Function.prototype.apply, create = Object.create;

		requireRegisteredExtensions().async = function (tbi, conf) {
			var waiting = create(null)
			  , cache = create(null)
			  , base = conf.memoized
			  , original = conf.original
			  , currentCallback
			  , currentContext
			  , currentArgs;

			// Initial
			conf.memoized = defineLength(function (arg) {
				var args = arguments, last = args[args.length - 1];
				if (typeof last === "function") {
					currentCallback = last;
					args = slice.call(args, 0, -1);
				}
				return base.apply(currentContext = this, currentArgs = args);
			}, base);
			try { mixin(conf.memoized, base); }
			catch (ignore) {}

			// From cache (sync)
			conf.on("get", function (id) {
				var cb, context, args;
				if (!currentCallback) return;

				// Unresolved
				if (waiting[id]) {
					if (typeof waiting[id] === "function") waiting[id] = [waiting[id], currentCallback];
					else waiting[id].push(currentCallback);
					currentCallback = null;
					return;
				}

				// Resolved, assure next tick invocation
				cb = currentCallback;
				context = currentContext;
				args = currentArgs;
				currentCallback = currentContext = currentArgs = null;
				nextTick(function () {
					var data;
					if (hasOwnProperty.call(cache, id)) {
						data = cache[id];
						conf.emit("getasync", id, args, context);
						apply.call(cb, data.context, data.args);
					} else {
						// Purged in a meantime, we shouldn't rely on cached value, recall
						currentCallback = cb;
						currentContext = context;
						currentArgs = args;
						base.apply(context, args);
					}
				});
			});

			// Not from cache
			conf.original = function () {
				var args, cb, origCb, result;
				if (!currentCallback) return apply.call(original, this, arguments);
				args = aFrom(arguments);
				cb = function self(err) {
					var cb, args, id = self.id;
					if (id == null) {
						// Shouldn't happen, means async callback was called sync way
						nextTick(apply.bind(self, this, arguments));
						return undefined;
					}
					delete self.id;
					cb = waiting[id];
					delete waiting[id];
					if (!cb) {
						// Already processed,
						// outcome of race condition: asyncFn(1, cb), asyncFn.clear(), asyncFn(1, cb)
						return undefined;
					}
					args = aFrom(arguments);
					if (conf.has(id)) {
						if (err) {
							conf.delete(id);
						} else {
							cache[id] = { context: this, args: args };
							conf.emit("setasync", id, typeof cb === "function" ? 1 : cb.length);
						}
					}
					if (typeof cb === "function") {
						result = apply.call(cb, this, args);
					} else {
						cb.forEach(function (cb) { result = apply.call(cb, this, args); }, this);
					}
					return result;
				};
				origCb = currentCallback;
				currentCallback = currentContext = currentArgs = null;
				args.push(cb);
				result = apply.call(original, this, args);
				cb.cb = origCb;
				currentCallback = cb;
				return result;
			};

			// After not from cache call
			conf.on("set", function (id) {
				if (!currentCallback) {
					conf.delete(id);
					return;
				}
				if (waiting[id]) {
					// Race condition: asyncFn(1, cb), asyncFn.clear(), asyncFn(1, cb)
					if (typeof waiting[id] === "function") waiting[id] = [waiting[id], currentCallback.cb];
					else waiting[id].push(currentCallback.cb);
				} else {
					waiting[id] = currentCallback.cb;
				}
				delete currentCallback.cb;
				currentCallback.id = id;
				currentCallback = null;
			});

			// On delete
			conf.on("delete", function (id) {
				var result;
				// If false, we don't have value yet, so we assume that intention is not
				// to memoize this call. After value is obtained we don't cache it but
				// gracefully pass to callback
				if (hasOwnProperty.call(waiting, id)) return;
				if (!cache[id]) return;
				result = cache[id];
				delete cache[id];
				conf.emit("deleteasync", id, slice.call(result.args, 1));
			});

			// On clear
			conf.on("clear", function () {
				var oldCache = cache;
				cache = create(null);
				conf.emit(
					"clearasync", objectMap(oldCache, function (data) { return slice.call(data.args, 1); })
				);
			});
		};
		return async;
	}

	var promise = {};

	var isCallable;
	var hasRequiredIsCallable;

	function requireIsCallable () {
		if (hasRequiredIsCallable) return isCallable;
		hasRequiredIsCallable = 1;

		isCallable = function (obj) { return typeof obj === "function"; };
		return isCallable;
	}

	var validateStringifiable;
	var hasRequiredValidateStringifiable;

	function requireValidateStringifiable () {
		if (hasRequiredValidateStringifiable) return validateStringifiable;
		hasRequiredValidateStringifiable = 1;

		var isCallable = requireIsCallable();

		validateStringifiable = function (stringifiable) {
			try {
				if (stringifiable && isCallable(stringifiable.toString)) return stringifiable.toString();
				return String(stringifiable);
			} catch (e) {
				throw new TypeError("Passed argument cannot be stringifed");
			}
		};
		return validateStringifiable;
	}

	var validateStringifiableValue;
	var hasRequiredValidateStringifiableValue;

	function requireValidateStringifiableValue () {
		if (hasRequiredValidateStringifiableValue) return validateStringifiableValue;
		hasRequiredValidateStringifiableValue = 1;

		var ensureValue   = requireValidValue()
		  , stringifiable = requireValidateStringifiable();

		validateStringifiableValue = function (value) { return stringifiable(ensureValue(value)); };
		return validateStringifiableValue;
	}

	var safeToString$1;
	var hasRequiredSafeToString$1;

	function requireSafeToString$1 () {
		if (hasRequiredSafeToString$1) return safeToString$1;
		hasRequiredSafeToString$1 = 1;

		var isCallable = requireIsCallable();

		safeToString$1 = function (value) {
			try {
				if (value && isCallable(value.toString)) return value.toString();
				return String(value);
			} catch (e) {
				return "<Non-coercible to string value>";
			}
		};
		return safeToString$1;
	}

	var toShortStringRepresentation;
	var hasRequiredToShortStringRepresentation;

	function requireToShortStringRepresentation () {
		if (hasRequiredToShortStringRepresentation) return toShortStringRepresentation;
		hasRequiredToShortStringRepresentation = 1;

		var safeToString = requireSafeToString$1();

		var reNewLine = /[\n\r\u2028\u2029]/g;

		toShortStringRepresentation = function (value) {
			var string = safeToString(value);
			// Trim if too long
			if (string.length > 100) string = string.slice(0, 99) + "";
			// Replace eventual new lines
			string = string.replace(reNewLine, function (char) {
				return JSON.stringify(char).slice(1, -1);
			});
			return string;
		};
		return toShortStringRepresentation;
	}

	var isPromise = {exports: {}};

	var hasRequiredIsPromise;

	function requireIsPromise () {
		if (hasRequiredIsPromise) return isPromise.exports;
		hasRequiredIsPromise = 1;
		isPromise.exports = isPromise$1;
		isPromise.exports.default = isPromise$1;

		function isPromise$1(obj) {
		  return !!obj && (typeof obj === 'object' || typeof obj === 'function') && typeof obj.then === 'function';
		}
		return isPromise.exports;
	}

	/* eslint max-statements: 0 */

	var hasRequiredPromise;

	function requirePromise () {
		if (hasRequiredPromise) return promise;
		hasRequiredPromise = 1;

		var objectMap     = requireMap()
		  , primitiveSet  = requirePrimitiveSet()
		  , ensureString  = requireValidateStringifiableValue()
		  , toShortString = requireToShortStringRepresentation()
		  , isPromise     = requireIsPromise()
		  , nextTick      = requireNextTick();

		var create = Object.create
		  , supportedModes = primitiveSet("then", "then:finally", "done", "done:finally");

		requireRegisteredExtensions().promise = function (mode, conf) {
			var waiting = create(null), cache = create(null), promises = create(null);

			if (mode === true) {
				mode = null;
			} else {
				mode = ensureString(mode);
				if (!supportedModes[mode]) {
					throw new TypeError("'" + toShortString(mode) + "' is not valid promise mode");
				}
			}

			// After not from cache call
			conf.on("set", function (id, ignore, promise) {
				var isFailed = false;

				if (!isPromise(promise)) {
					// Non promise result
					cache[id] = promise;
					conf.emit("setasync", id, 1);
					return;
				}
				waiting[id] = 1;
				promises[id] = promise;
				var onSuccess = function (result) {
					var count = waiting[id];
					if (isFailed) {
						throw new Error(
							"Memoizee error: Detected unordered then|done & finally resolution, which " +
								"in turn makes proper detection of success/failure impossible (when in " +
								"'done:finally' mode)\n" +
								"Consider to rely on 'then' or 'done' mode instead."
						);
					}
					if (!count) return; // Deleted from cache before resolved
					delete waiting[id];
					cache[id] = result;
					conf.emit("setasync", id, count);
				};
				var onFailure = function () {
					isFailed = true;
					if (!waiting[id]) return; // Deleted from cache (or succeed in case of finally)
					delete waiting[id];
					delete promises[id];
					conf.delete(id);
				};

				var resolvedMode = mode;
				if (!resolvedMode) resolvedMode = "then";

				if (resolvedMode === "then") {
					var nextTickFailure = function () { nextTick(onFailure); };
					// Eventual finally needs to be attached to non rejected promise
					// (so we not force propagation of unhandled rejection)
					promise = promise.then(function (result) {
						nextTick(onSuccess.bind(this, result));
					}, nextTickFailure);
					// If `finally` is a function we attach to it to remove cancelled promises.
					if (typeof promise.finally === "function") {
						promise.finally(nextTickFailure);
					}
				} else if (resolvedMode === "done") {
					// Not recommended, as it may mute any eventual "Unhandled error" events
					if (typeof promise.done !== "function") {
						throw new Error(
							"Memoizee error: Retrieved promise does not implement 'done' " +
								"in 'done' mode"
						);
					}
					promise.done(onSuccess, onFailure);
				} else if (resolvedMode === "done:finally") {
					// The only mode with no side effects assuming library does not throw unconditionally
					// for rejected promises.
					if (typeof promise.done !== "function") {
						throw new Error(
							"Memoizee error: Retrieved promise does not implement 'done' " +
								"in 'done:finally' mode"
						);
					}
					if (typeof promise.finally !== "function") {
						throw new Error(
							"Memoizee error: Retrieved promise does not implement 'finally' " +
								"in 'done:finally' mode"
						);
					}
					promise.done(onSuccess);
					promise.finally(onFailure);
				}
			});

			// From cache (sync)
			conf.on("get", function (id, args, context) {
				var promise;
				if (waiting[id]) {
					++waiting[id]; // Still waiting
					return;
				}
				promise = promises[id];
				var emit = function () { conf.emit("getasync", id, args, context); };
				if (isPromise(promise)) {
					if (typeof promise.done === "function") promise.done(emit);
					else {
						promise.then(function () { nextTick(emit); });
					}
				} else {
					emit();
				}
			});

			// On delete
			conf.on("delete", function (id) {
				delete promises[id];
				if (waiting[id]) {
					delete waiting[id];
					return; // Not yet resolved
				}
				if (!hasOwnProperty.call(cache, id)) return;
				var result = cache[id];
				delete cache[id];
				conf.emit("deleteasync", id, [result]);
			});

			// On clear
			conf.on("clear", function () {
				var oldCache = cache;
				cache = create(null);
				waiting = create(null);
				promises = create(null);
				conf.emit("clearasync", objectMap(oldCache, function (data) { return [data]; }));
			});
		};
		return promise;
	}

	var dispose = {};

	var hasRequiredDispose;

	function requireDispose () {
		if (hasRequiredDispose) return dispose;
		hasRequiredDispose = 1;

		var callable   = requireValidCallable()
		  , forEach    = requireForEach()
		  , extensions = requireRegisteredExtensions()

		  , apply = Function.prototype.apply;

		extensions.dispose = function (dispose, conf, options) {
			var del;
			callable(dispose);
			if ((options.async && extensions.async) || (options.promise && extensions.promise)) {
				conf.on("deleteasync", del = function (id, resultArray) {
					apply.call(dispose, null, resultArray);
				});
				conf.on("clearasync", function (cache) {
					forEach(cache, function (result, id) {
		 del(id, result);
		});
				});
				return;
			}
			conf.on("delete", del = function (id, result) {
		 dispose(result);
		});
			conf.on("clear", function (cache) {
				forEach(cache, function (result, id) {
		 del(id, result);
		});
			});
		};
		return dispose;
	}

	var maxAge = {};

	var maxTimeout;
	var hasRequiredMaxTimeout;

	function requireMaxTimeout () {
		if (hasRequiredMaxTimeout) return maxTimeout;
		hasRequiredMaxTimeout = 1;

		maxTimeout = 2147483647;
		return maxTimeout;
	}

	var validTimeout;
	var hasRequiredValidTimeout;

	function requireValidTimeout () {
		if (hasRequiredValidTimeout) return validTimeout;
		hasRequiredValidTimeout = 1;

		var toPosInt   = requireToPosInteger()
		  , maxTimeout = requireMaxTimeout();

		validTimeout = function (value) {
			value = toPosInt(value);
			if (value > maxTimeout) throw new TypeError(value + " exceeds maximum possible timeout");
			return value;
		};
		return validTimeout;
	}

	/* eslint consistent-this: 0 */

	var hasRequiredMaxAge;

	function requireMaxAge () {
		if (hasRequiredMaxAge) return maxAge;
		hasRequiredMaxAge = 1;

		var aFrom      = requireFrom()
		  , forEach    = requireForEach()
		  , nextTick   = requireNextTick()
		  , isPromise  = requireIsPromise()
		  , timeout    = requireValidTimeout()
		  , extensions = requireRegisteredExtensions();

		var noop = Function.prototype, max = Math.max, min = Math.min, create = Object.create;

		extensions.maxAge = function (maxAge, conf, options) {
			var timeouts, postfix, preFetchAge, preFetchTimeouts;

			maxAge = timeout(maxAge);
			if (!maxAge) return;

			timeouts = create(null);
			postfix =
				(options.async && extensions.async) || (options.promise && extensions.promise)
					? "async"
					: "";
			conf.on("set" + postfix, function (id) {
				timeouts[id] = setTimeout(function () { conf.delete(id); }, maxAge);
				if (typeof timeouts[id].unref === "function") timeouts[id].unref();
				if (!preFetchTimeouts) return;
				if (preFetchTimeouts[id]) {
					if (preFetchTimeouts[id] !== "nextTick") clearTimeout(preFetchTimeouts[id]);
				}
				preFetchTimeouts[id] = setTimeout(function () {
					delete preFetchTimeouts[id];
				}, preFetchAge);
				if (typeof preFetchTimeouts[id].unref === "function") preFetchTimeouts[id].unref();
			});
			conf.on("delete" + postfix, function (id) {
				clearTimeout(timeouts[id]);
				delete timeouts[id];
				if (!preFetchTimeouts) return;
				if (preFetchTimeouts[id] !== "nextTick") clearTimeout(preFetchTimeouts[id]);
				delete preFetchTimeouts[id];
			});

			if (options.preFetch) {
				if (options.preFetch === true || isNaN(options.preFetch)) {
					preFetchAge = 0.333;
				} else {
					preFetchAge = max(min(Number(options.preFetch), 1), 0);
				}
				if (preFetchAge) {
					preFetchTimeouts = {};
					preFetchAge = (1 - preFetchAge) * maxAge;
					conf.on("get" + postfix, function (id, args, context) {
						if (!preFetchTimeouts[id]) {
							preFetchTimeouts[id] = "nextTick";
							nextTick(function () {
								var result;
								if (preFetchTimeouts[id] !== "nextTick") return;
								delete preFetchTimeouts[id];
								conf.delete(id);
								if (options.async) {
									args = aFrom(args);
									args.push(noop);
								}
								result = conf.memoized.apply(context, args);
								if (options.promise) {
									// Supress eventual error warnings
									if (isPromise(result)) {
										if (typeof result.done === "function") result.done(noop, noop);
										else result.then(noop, noop);
									}
								}
							});
						}
					});
				}
			}

			conf.on("clear" + postfix, function () {
				forEach(timeouts, function (id) { clearTimeout(id); });
				timeouts = {};
				if (preFetchTimeouts) {
					forEach(preFetchTimeouts, function (id) { if (id !== "nextTick") clearTimeout(id); });
					preFetchTimeouts = {};
				}
			});
		};
		return maxAge;
	}

	var max = {};

	var lruQueue;
	var hasRequiredLruQueue;

	function requireLruQueue () {
		if (hasRequiredLruQueue) return lruQueue;
		hasRequiredLruQueue = 1;

		var toPosInt = requireToPosInteger()

		  , create = Object.create, hasOwnProperty = Object.prototype.hasOwnProperty;

		lruQueue = function (limit) {
			var size = 0, base = 1, queue = create(null), map = create(null), index = 0, del;
			limit = toPosInt(limit);
			return {
				hit: function (id) {
					var oldIndex = map[id], nuIndex = ++index;
					queue[nuIndex] = id;
					map[id] = nuIndex;
					if (!oldIndex) {
						++size;
						if (size <= limit) return;
						id = queue[base];
						del(id);
						return id;
					}
					delete queue[oldIndex];
					if (base !== oldIndex) return;
					while (!hasOwnProperty.call(queue, ++base)) continue; //jslint: skip
				},
				delete: del = function (id) {
					var oldIndex = map[id];
					if (!oldIndex) return;
					delete queue[oldIndex];
					delete map[id];
					--size;
					if (base !== oldIndex) return;
					if (!size) {
						index = 0;
						base = 1;
						return;
					}
					while (!hasOwnProperty.call(queue, ++base)) continue; //jslint: skip
				},
				clear: function () {
					size = 0;
					base = 1;
					queue = create(null);
					map = create(null);
					index = 0;
				}
			};
		};
		return lruQueue;
	}

	var hasRequiredMax;

	function requireMax () {
		if (hasRequiredMax) return max;
		hasRequiredMax = 1;

		var toPosInteger = requireToPosInteger()
		  , lruQueue     = requireLruQueue()
		  , extensions   = requireRegisteredExtensions();

		extensions.max = function (max, conf, options) {
			var postfix, queue, hit;

			max = toPosInteger(max);
			if (!max) return;

			queue = lruQueue(max);
			postfix = (options.async && extensions.async) || (options.promise && extensions.promise)
				? "async" : "";

			conf.on("set" + postfix, hit = function (id) {
				id = queue.hit(id);
				if (id === undefined) return;
				conf.delete(id);
			});
			conf.on("get" + postfix, hit);
			conf.on("delete" + postfix, queue.delete);
			conf.on("clear" + postfix, queue.clear);
		};
		return max;
	}

	var refCounter = {};

	var hasRequiredRefCounter;

	function requireRefCounter () {
		if (hasRequiredRefCounter) return refCounter;
		hasRequiredRefCounter = 1;

		var d          = requireD()
		  , extensions = requireRegisteredExtensions()

		  , create = Object.create, defineProperties = Object.defineProperties;

		extensions.refCounter = function (ignore, conf, options) {
			var cache, postfix;

			cache = create(null);
			postfix = (options.async && extensions.async) || (options.promise && extensions.promise)
				? "async" : "";

			conf.on("set" + postfix, function (id, length) {
		 cache[id] = length || 1;
		});
			conf.on("get" + postfix, function (id) {
		 ++cache[id];
		});
			conf.on("delete" + postfix, function (id) {
		 delete cache[id];
		});
			conf.on("clear" + postfix, function () {
		 cache = {};
		});

			defineProperties(conf.memoized, {
				deleteRef: d(function () {
					var id = conf.get(arguments);
					if (id === null) return null;
					if (!cache[id]) return null;
					if (!--cache[id]) {
						conf.delete(id);
						return true;
					}
					return false;
				}),
				getRefCount: d(function () {
					var id = conf.get(arguments);
					if (id === null) return 0;
					if (!cache[id]) return 0;
					return cache[id];
				})
			});
		};
		return refCounter;
	}

	var memoizee;
	var hasRequiredMemoizee;

	function requireMemoizee () {
		if (hasRequiredMemoizee) return memoizee;
		hasRequiredMemoizee = 1;

		var normalizeOpts = requireNormalizeOptions()
		  , resolveLength = requireResolveLength()
		  , plain         = requirePlain();

		memoizee = function (fn/*, options*/) {
			var options = normalizeOpts(arguments[1]), length;

			if (!options.normalizer) {
				length = options.length = resolveLength(options.length, fn.length, options.async);
				if (length !== 0) {
					if (options.primitive) {
						if (length === false) {
							options.normalizer = requirePrimitive();
						} else if (length > 1) {
							options.normalizer = requireGetPrimitiveFixed()(length);
						}
					} else if (length === false) options.normalizer = requireGet$1()();
						else if (length === 1) options.normalizer = requireGet1()();
						else options.normalizer = requireGetFixed()(length);
				}
			}

			// Assure extensions
			if (options.async) requireAsync();
			if (options.promise) requirePromise();
			if (options.dispose) requireDispose();
			if (options.maxAge) requireMaxAge();
			if (options.max) requireMax();
			if (options.refCounter) requireRefCounter();

			return plain(fn, options);
		};
		return memoizee;
	}

	var coerce;
	var hasRequiredCoerce;

	function requireCoerce () {
		if (hasRequiredCoerce) return coerce;
		hasRequiredCoerce = 1;

		var isValue  = requireIs$5()
		  , isObject = requireIs$4();

		var objectToString = Object.prototype.toString;

		coerce = function (value) {
			if (!isValue(value)) return null;
			if (isObject(value)) {
				// Reject Object.prototype.toString coercion
				var valueToString = value.toString;
				if (typeof valueToString !== "function") return null;
				if (valueToString === objectToString) return null;
				// Note: It can be object coming from other realm, still as there's no ES3 and CSP compliant
				// way to resolve its realm's Object.prototype.toString it's left as not addressed edge case
			}
			try {
				return "" + value; // Ensure implicit coercion
			} catch (error) {
				return null;
			}
		};
		return coerce;
	}

	var safeToString;
	var hasRequiredSafeToString;

	function requireSafeToString () {
		if (hasRequiredSafeToString) return safeToString;
		hasRequiredSafeToString = 1;

		safeToString = function (value) {
			try {
				return value.toString();
			} catch (error) {
				try { return String(value); }
				catch (error2) { return null; }
			}
		};
		return safeToString;
	}

	var toShortString;
	var hasRequiredToShortString;

	function requireToShortString () {
		if (hasRequiredToShortString) return toShortString;
		hasRequiredToShortString = 1;

		var safeToString = requireSafeToString();

		var reNewLine = /[\n\r\u2028\u2029]/g;

		toShortString = function (value) {
			var string = safeToString(value);
			if (string === null) return "<Non-coercible to string value>";
			// Trim if too long
			if (string.length > 100) string = string.slice(0, 99) + "";
			// Replace eventual new lines
			string = string.replace(reNewLine, function (char) {
				switch (char) {
					case "\n":
						return "\\n";
					case "\r":
						return "\\r";
					case "\u2028":
						return "\\u2028";
					case "\u2029":
						return "\\u2029";
					/* istanbul ignore next */
					default:
						throw new Error("Unexpected character");
				}
			});
			return string;
		};
		return toShortString;
	}

	var resolveErrorMessage;
	var hasRequiredResolveErrorMessage;

	function requireResolveErrorMessage () {
		if (hasRequiredResolveErrorMessage) return resolveErrorMessage;
		hasRequiredResolveErrorMessage = 1;

		var stringCoerce  = requireCoerce()
		  , toShortString = requireToShortString();

		resolveErrorMessage = function (errorMessage, value, inputOptions) {
			if (inputOptions && inputOptions.errorMessage) {
				errorMessage = stringCoerce(inputOptions.errorMessage);
			}

			var valueInsertIndex = errorMessage.indexOf("%v");
			var valueToken = valueInsertIndex > -1 ? toShortString(value) : null;
			if (inputOptions && inputOptions.name) {
				var nameInsertIndex = errorMessage.indexOf("%n");
				if (nameInsertIndex > -1) {
					if (valueInsertIndex > -1) {
						var firstToken, secondToken, firstInsertIndex, secondInsertIndex;
						if (nameInsertIndex > valueInsertIndex) {
							firstToken = valueToken;
							firstInsertIndex = valueInsertIndex;
							secondToken = inputOptions.name;
							secondInsertIndex = nameInsertIndex;
						} else {
							firstToken = inputOptions.name;
							firstInsertIndex = nameInsertIndex;
							secondToken = valueToken;
							secondInsertIndex = valueInsertIndex;
						}
						return (
							errorMessage.slice(0, firstInsertIndex) +
							firstToken +
							errorMessage.slice(firstInsertIndex + 2, secondInsertIndex) +
							secondToken +
							errorMessage.slice(secondInsertIndex + 2)
						);
					}
					return (
						errorMessage.slice(0, nameInsertIndex) +
						inputOptions.name +
						errorMessage.slice(nameInsertIndex + 2)
					);
				}
			}
			if (valueInsertIndex > -1) {
				return (
					errorMessage.slice(0, valueInsertIndex) +
					valueToken +
					errorMessage.slice(valueInsertIndex + 2)
				);
			}
			return errorMessage;
		};
		return resolveErrorMessage;
	}

	var resolveException;
	var hasRequiredResolveException;

	function requireResolveException () {
		if (hasRequiredResolveException) return resolveException;
		hasRequiredResolveException = 1;

		var isValue             = requireIs$5()
		  , resolveErrorMessage = requireResolveErrorMessage();

		resolveException = function (value, defaultMessage, inputOptions) {
			if (inputOptions && !isValue(value)) {
				if ("default" in inputOptions) return inputOptions["default"];
				if (inputOptions.isOptional) return null;
			}
			var ErrorConstructor = (inputOptions && inputOptions.Error) || TypeError;
			var error = new ErrorConstructor(resolveErrorMessage(defaultMessage, value, inputOptions));
			if (inputOptions && inputOptions.errorCode) error.code = inputOptions.errorCode;
			throw error;
		};
		return resolveException;
	}

	var ensure$1;
	var hasRequiredEnsure$1;

	function requireEnsure$1 () {
		if (hasRequiredEnsure$1) return ensure$1;
		hasRequiredEnsure$1 = 1;

		var resolveException = requireResolveException()
		  , is               = requireIs$5();

		ensure$1 = function (value/*, options*/) {
			if (is(value)) return value;
			var options = arguments[1];
			var errorMessage =
				options && options.name ? "Expected a value for %n, received %v" : "Cannot use %v";
			return resolveException(value, errorMessage, options);
		};
		return ensure$1;
	}

	var lazy;
	var hasRequiredLazy;

	function requireLazy () {
		if (hasRequiredLazy) return lazy;
		hasRequiredLazy = 1;

		var isPlainFunction = requireIs$1()
		  , ensureValue     = requireEnsure$1()
		  , isValue         = requireIs$5()
		  , map             = requireMap()
		  , contains        = requireContains();

		var call = Function.prototype.call
		  , defineProperty = Object.defineProperty
		  , getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor
		  , getPrototypeOf = Object.getPrototypeOf
		  , hasOwnProperty = Object.prototype.hasOwnProperty
		  , cacheDesc = { configurable: false, enumerable: false, writable: false, value: null }
		  , define;

		define = function (name, options) {
			var value, dgs, cacheName, desc, writable = false, resolvable, flat;
			options = Object(ensureValue(options));
			cacheName = options.cacheName;
			flat = options.flat;
			if (!isValue(cacheName)) cacheName = name;
			delete options.cacheName;
			value = options.value;
			resolvable = isPlainFunction(value);
			delete options.value;
			dgs = { configurable: Boolean(options.configurable), enumerable: Boolean(options.enumerable) };
			if (name !== cacheName) {
				dgs.get = function () {
					if (hasOwnProperty.call(this, cacheName)) return this[cacheName];
					cacheDesc.value = resolvable ? call.call(value, this, options) : value;
					cacheDesc.writable = writable;
					defineProperty(this, cacheName, cacheDesc);
					cacheDesc.value = null;
					if (desc) defineProperty(this, name, desc);
					return this[cacheName];
				};
			} else if (!flat) {
				dgs.get = function self() {
					var ownDesc;
					if (hasOwnProperty.call(this, name)) {
						ownDesc = getOwnPropertyDescriptor(this, name);
						// It happens in Safari, that getter is still called after property
						// was defined with a value, following workarounds that
						// While in IE11 it may happen that here ownDesc is undefined (go figure)
						if (ownDesc) {
							if (ownDesc.hasOwnProperty("value")) return ownDesc.value;
							if (typeof ownDesc.get === "function" && ownDesc.get !== self) {
								return ownDesc.get.call(this);
							}
							return value;
						}
					}
					desc.value = resolvable ? call.call(value, this, options) : value;
					defineProperty(this, name, desc);
					desc.value = null;
					return this[name];
				};
			} else {
				dgs.get = function self() {
					var base = this, ownDesc;
					if (hasOwnProperty.call(this, name)) {
						// It happens in Safari, that getter is still called after property
						// was defined with a value, following workarounds that
						ownDesc = getOwnPropertyDescriptor(this, name);
						if (ownDesc.hasOwnProperty("value")) return ownDesc.value;
						if (typeof ownDesc.get === "function" && ownDesc.get !== self) {
							return ownDesc.get.call(this);
						}
					}
					while (!hasOwnProperty.call(base, name)) base = getPrototypeOf(base);
					desc.value = resolvable ? call.call(value, base, options) : value;
					defineProperty(base, name, desc);
					desc.value = null;
					return base[name];
				};
			}
			dgs.set = function (value) {
				if (hasOwnProperty.call(this, name)) {
					throw new TypeError("Cannot assign to lazy defined '" + name + "' property of " + this);
				}
				dgs.get.call(this);
				this[cacheName] = value;
			};
			if (options.desc) {
				desc = {
					configurable: contains.call(options.desc, "c"),
					enumerable: contains.call(options.desc, "e")
				};
				if (cacheName === name) {
					desc.writable = contains.call(options.desc, "w");
					desc.value = null;
				} else {
					writable = contains.call(options.desc, "w");
					desc.get = dgs.get;
					desc.set = dgs.set;
				}
				delete options.desc;
			} else if (cacheName === name) {
				desc = {
					configurable: Boolean(options.configurable),
					enumerable: Boolean(options.enumerable),
					writable: Boolean(options.writable),
					value: null
				};
			}
			delete options.configurable;
			delete options.enumerable;
			delete options.writable;
			return dgs;
		};

		lazy = function (props) {
			return map(props, function (desc, name) { return define(name, desc); });
		};
		return lazy;
	}

	var methods$1;
	var hasRequiredMethods$1;

	function requireMethods$1 () {
		if (hasRequiredMethods$1) return methods$1;
		hasRequiredMethods$1 = 1;

		var forEach       = requireForEach()
		  , normalizeOpts = requireNormalizeOptions()
		  , callable      = requireValidCallable()
		  , lazy          = requireLazy()
		  , resolveLength = requireResolveLength()
		  , extensions    = requireRegisteredExtensions();

		methods$1 = function (memoize) {
			return function (props) {
				forEach(props, function (desc) {
					var fn = callable(desc.value), length;
					desc.value = function (options) {
						if (options.getNormalizer) {
							options = normalizeOpts(options);
							if (length === undefined) {
								length = resolveLength(
									options.length,
									fn.length,
									options.async && extensions.async
								);
							}
							options.normalizer = options.getNormalizer(length);
							delete options.getNormalizer;
						}
						return memoize(fn.bind(this), options);
					};
				});
				return lazy(props);
			};
		};
		return methods$1;
	}

	var methods;
	var hasRequiredMethods;

	function requireMethods () {
		if (hasRequiredMethods) return methods;
		hasRequiredMethods = 1;

		methods = requireMethods$1()(requireMemoizee());
		return methods;
	}

	var firstKey;
	var hasRequiredFirstKey;

	function requireFirstKey () {
		if (hasRequiredFirstKey) return firstKey;
		hasRequiredFirstKey = 1;

		var value                   = requireValidValue()
		  , objPropertyIsEnumerable = Object.prototype.propertyIsEnumerable;

		firstKey = function (obj) {
			var i;
			value(obj);
			for (i in obj) {
				if (objPropertyIsEnumerable.call(obj, i)) return i;
			}
			return null;
		};
		return firstKey;
	}

	var forEachRight;
	var hasRequiredForEachRight;

	function requireForEachRight () {
		if (hasRequiredForEachRight) return forEachRight;
		hasRequiredForEachRight = 1;

		var toPosInt          = requireToPosInteger()
		  , callable          = requireValidCallable()
		  , value             = requireValidValue()
		  , objHasOwnProperty = Object.prototype.hasOwnProperty
		  , call              = Function.prototype.call;

		forEachRight = function (cb /*, thisArg*/) {
			var i, self, thisArg;

			self = Object(value(this));
			callable(cb);
			thisArg = arguments[1];

			for (i = toPosInt(self.length) - 1; i >= 0; --i) {
				if (objHasOwnProperty.call(self, i)) call.call(cb, thisArg, self[i], i, self);
			}
		};
		return forEachRight;
	}

	var uniq;
	var hasRequiredUniq;

	function requireUniq () {
		if (hasRequiredUniq) return uniq;
		hasRequiredUniq = 1;

		var indexOf = requireEIndexOf()
		  , filter  = Array.prototype.filter
		  , isFirst;

		isFirst = function (value, index) { return indexOf.call(this, value) === index; };

		uniq = function () { return filter.call(this, isFirst, this); };
		return uniq;
	}

	var sgr_1;
	var hasRequiredSgr;

	function requireSgr () {
		if (hasRequiredSgr) return sgr_1;
		hasRequiredSgr = 1;

		/* CSI - control sequence introducer */
		/* SGR - set graphic rendition */

		var assign       = requireAssign()
		  , includes     = requireContains()
		  , forOwn       = requireForEach()
		  , onlyKey      = requireFirstKey()
		  , forEachRight = requireForEachRight()
		  , uniq         = requireUniq();

		var CSI = "\x1b[";

		var sgr = function (code) { return CSI + code + "m"; };

		sgr.CSI = CSI;

		var mods = assign(
			{
				// Style
				bold: { _bold: [1, 22] },
				italic: { _italic: [3, 23] },
				underline: { _underline: [4, 24] },
				blink: { _blink: [5, 25] },
				inverse: { _inverse: [7, 27] },
				strike: { _strike: [9, 29] }

				// Color
			},
			["black", "red", "green", "yellow", "blue", "magenta", "cyan", "white"].reduce(function (
				obj,
				color,
				index
			) {
				// foreground
				obj[color] = { _fg: [30 + index, 39] };
				obj[color + "Bright"] = { _fg: [90 + index, 39] };

				// background
				obj["bg" + color[0].toUpperCase() + color.slice(1)] = { _bg: [40 + index, 49] };
				obj["bg" + color[0].toUpperCase() + color.slice(1) + "Bright"] = { _bg: [100 + index, 49] };

				return obj;
			}, {})
		);

		sgr.mods = mods;

		sgr.openers = {};
		sgr.closers = {};

		forOwn(mods, function (mod) {
			var modPair = mod[onlyKey(mod)];

			sgr.openers[modPair[0]] = modPair;
			sgr.closers[modPair[1]] = modPair;
		});

		sgr.openStyle = function (openedMods, code) { openedMods.push(sgr.openers[code]); };

		sgr.closeStyle = function (openedMods, code) {
			forEachRight.call(openedMods, function (modPair, index) {
				if (modPair[1] === code) {
					openedMods.splice(index, 1);
				}
			});
		};

		/* prepend openers */
		sgr.prepend = function (currentMods) {
			return currentMods.map(function (modPair) { return sgr(modPair[0]); });
		};

		/* complete non-closed openers with corresponding closers */
		sgr.complete = function (openedMods, closerCodes) {
			closerCodes.forEach(function (code) { sgr.closeStyle(openedMods, code); });

			// mods must be closed from the last opened to first opened
			openedMods = openedMods.reverse();

			openedMods = openedMods.map(function (modPair) { return modPair[1]; });

			// one closer can close many openers (31, 32 -> 39)
			openedMods = uniq.call(openedMods);

			return openedMods.map(sgr);
		};

		var hasCSI = function (str) { return includes.call(str, CSI); };

		sgr.hasCSI = hasCSI;

		var extractCode = function (csi) {
			var code = csi.slice(2, -1);
			code = Number(code);
			return code;
		};

		sgr.extractCode = extractCode;

		sgr_1 = sgr;
		return sgr_1;
	}

	var supportsColor;
	var hasRequiredSupportsColor;

	function requireSupportsColor () {
		if (hasRequiredSupportsColor) return supportsColor;
		hasRequiredSupportsColor = 1;

		// store whether supports-color mode is enabled or not.
		var state = null;

		// force supports-color mode
		var enableColor = function () { state = true; };

		// disable supports-color mode
		var disableColor = function () { state = false; };

		// use the NO_COLOR environment variable (default)
		var autoDetectSupport = function () { state = null; };

		// determine whether supports-color mode is enabled.
		var isColorSupported = function () { return state === null ? !browser$1.env.NO_COLOR : state; };

		supportsColor = {
			enableColor: enableColor,
			disableColor: disableColor,
			autoDetectSupport: autoDetectSupport,
			isColorSupported: isColorSupported
		};
		return supportsColor;
	}

	var bare;
	var hasRequiredBare;

	function requireBare () {
		if (hasRequiredBare) return bare;
		hasRequiredBare = 1;

		var d              = requireD()
		  , assign         = requireAssign()
		  , forEach        = requireForEach()
		  , map            = requireMap()
		  , primitiveSet   = requirePrimitiveSet()
		  , setPrototypeOf = requireSetPrototypeOf()
		  , memoize        = requireMemoizee()
		  , memoizeMethods = requireMethods()
		  , sgr            = requireSgr()
		  , supportsColor  = requireSupportsColor();

		var mods           = sgr.mods
		  , join           = Array.prototype.join
		  , defineProperty = Object.defineProperty
		  , max            = Math.max
		  , min            = Math.min
		  , variantModes   = primitiveSet("_fg", "_bg")
		  , xtermMatch     = null;

		var getFn;

		// Some use cli-color as: console.log(clc.red('Error!'));
		// Which is inefficient as on each call it configures new clc object
		// with memoization we reuse once created object
		var memoized = memoize(function (scope, mod) {
			return defineProperty(getFn(), "_cliColorData", d(assign({}, scope._cliColorData, mod)));
		});

		var proto = Object.create(
			Function.prototype,
			assign(
				map(mods, function (mod) {
					return d.gs(function () { return memoized(this, mod); });
				}),
				memoizeMethods({
					// xterm (255) color
					xterm: d(function (code) {
						code = isNaN(code) ? 255 : min(max(code, 0), 255);
						return defineProperty(
							getFn(), "_cliColorData",
							d(
								assign({}, this._cliColorData, {
									_fg: ["38;5;" + code, 39]
								})
							)
						);
					}),
					bgXterm: d(function (code) {
						code = isNaN(code) ? 255 : min(max(code, 0), 255);
						return defineProperty(
							getFn(), "_cliColorData",
							d(
								assign({}, this._cliColorData, {
									_bg: ["48;5;" + code, 49]
								})
							)
						);
					})
				})
			)
		);

		var getEndRe = memoize(function (code) { return new RegExp("\x1b\\[" + code + "m", "g"); }, {
			primitive: true
		});

		getFn = function () {
			return setPrototypeOf(
				function self(/* msg*/) {
					var start = ""
					  , end = ""
					  , msg = join.call(arguments, " ")
					  , conf = self._cliColorData
					  , hasAnsi = sgr.hasCSI(msg);
					forEach(
						conf,
						function (mod, key) {
							end = sgr(mod[1]) + end;
							start += sgr(mod[0]);
							if (hasAnsi) {
								msg = msg.replace(getEndRe(mod[1]), variantModes[key] ? sgr(mod[0]) : "");
							}
						},
						null,
						true
					);
					if (!supportsColor.isColorSupported()) return msg;
					return start + msg + end;
				},
				proto
			);
		};

		bare = Object.defineProperties(getFn(), {
			xtermSupported: d(!xtermMatch),
			_cliColorData: d("", {})
		});
		return bare;
	}

	var windowSize = {};

	var hasRequiredWindowSize;

	function requireWindowSize () {
		if (hasRequiredWindowSize) return windowSize;
		hasRequiredWindowSize = 1;
		(function (exports) {

			var d = requireD();

			Object.defineProperties(exports, {
				width: d.gs("ce", function () { return browser$1.stdout.columns || 0; }),
				height: d.gs("ce", function () { return browser$1.stdout.rows || 0; })
			}); 
		} (windowSize));
		return windowSize;
	}

	var erase;
	var hasRequiredErase;

	function requireErase () {
		if (hasRequiredErase) return erase;
		hasRequiredErase = 1;

		erase = {
			screen: "\x1b[2J",
			screenLeft: "\x1b[1J",
			screenRight: "\x1b[J",
			line: "\x1b[2K",
			lineLeft: "\x1b[1K",
			lineRight: "\x1b[K"
		};
		return erase;
	}

	var isImplemented$1;
	var hasRequiredIsImplemented$1;

	function requireIsImplemented$1 () {
		if (hasRequiredIsImplemented$1) return isImplemented$1;
		hasRequiredIsImplemented$1 = 1;

		isImplemented$1 = function () {
			var trunc = Math.trunc;
			if (typeof trunc !== "function") return false;
			return trunc(13.67) === 13 && trunc(-13.67) === -13;
		};
		return isImplemented$1;
	}

	var shim$1;
	var hasRequiredShim$1;

	function requireShim$1 () {
		if (hasRequiredShim$1) return shim$1;
		hasRequiredShim$1 = 1;

		var floor = Math.floor;

		shim$1 = function (value) {
			if (isNaN(value)) return NaN;
			value = Number(value);
			if (value === 0) return value;
			if (value === Infinity) return Infinity;
			if (value === -Infinity) return -Infinity;
			if (value > 0) return floor(value);
			return -floor(-value);
		};
		return shim$1;
	}

	var trunc;
	var hasRequiredTrunc;

	function requireTrunc () {
		if (hasRequiredTrunc) return trunc;
		hasRequiredTrunc = 1;

		trunc = requireIsImplemented$1()() ? Math.trunc : requireShim$1();
		return trunc;
	}

	var move;
	var hasRequiredMove;

	function requireMove () {
		if (hasRequiredMove) return move;
		hasRequiredMove = 1;

		var d     = requireD()
		  , trunc = requireTrunc();

		var up, down, right, left, abs = Math.abs, floor = Math.floor, max = Math.max;

		var getMove = function (control) {
			return function (num) {
				num = isNaN(num) ? 0 : max(floor(num), 0);
				return num ? "\x1b[" + num + control : "";
			};
		};

		move = Object.defineProperties(
			function (x, y) {
				x = isNaN(x) ? 0 : floor(x);
				y = isNaN(y) ? 0 : floor(y);
				return (x > 0 ? right(x) : left(-x)) + (y > 0 ? down(y) : up(-y));
			},
			{
				up: d((up = getMove("A"))),
				down: d((down = getMove("B"))),
				right: d((right = getMove("C"))),
				left: d((left = getMove("D"))),
				to: d(function (x, y) {
					x = isNaN(x) ? 1 : max(floor(x), 0) + 1;
					y = isNaN(y) ? 1 : max(floor(y), 0) + 1;
					return "\x1b[" + y + ";" + x + "H";
				}),
				lines: d(function (n) {
					var dir;
					n = trunc(n) || 0;
					dir = n >= 0 ? "B" : "A";
					n = floor(abs(n));
					return "\x1b[" + n + dir + "\x1b[1G";
				}),
				top: d("\x1b[5000F"),
				bottom: d("\x1b[5000B"),
				lineBegin: d("\x1b[5000D"),
				lineEnd: d("\x1b[5000C")
			}
		);
		return move;
	}

	var beep;
	var hasRequiredBeep;

	function requireBeep () {
		if (hasRequiredBeep) return beep;
		hasRequiredBeep = 1;

		beep = "\x07";
		return beep;
	}

	var generate;
	var hasRequiredGenerate;

	function requireGenerate () {
		if (hasRequiredGenerate) return generate;
		hasRequiredGenerate = 1;

		var toPosInt = requireToPosInteger()
		  , value    = requireValidValue()
		  , slice    = Array.prototype.slice;

		generate = function (length /*, fill*/) {
			var arr, currentLength;
			length = toPosInt(value(length));
			if (length === 0) return [];

			arr = arguments.length < 2 ? [undefined] : slice.call(arguments, 1, 1 + length);

			while ((currentLength = arr.length) < length) {
				arr = arr.concat(arr.slice(0, length - currentLength));
			}
			return arr;
		};
		return generate;
	}

	var isArrayLike;
	var hasRequiredIsArrayLike;

	function requireIsArrayLike () {
		if (hasRequiredIsArrayLike) return isArrayLike;
		hasRequiredIsArrayLike = 1;

		var isFunction = requireIsFunction()
		  , isObject   = requireIsObject()
		  , isValue    = requireIsValue();

		isArrayLike = function (value) {
			return (
				(isValue(value) &&
					typeof value.length === "number" &&
					// Just checking ((typeof x === 'object') && (typeof x !== 'function'))
					// won't work right for some cases, e.g.:
					// type of instance of NodeList in Safari is a 'function'
					((isObject(value) && !isFunction(value)) || typeof value === "string")) ||
				false
			);
		};
		return isArrayLike;
	}

	var is;
	var hasRequiredIs;

	function requireIs () {
		if (hasRequiredIs) return is;
		hasRequiredIs = 1;

		var iteratorSymbol = requireEs6Symbol().iterator
		  , isValue        = requireIsValue()
		  , isArrayLike    = requireIsArrayLike();

		is = function (value) {
			if (!isValue(value)) return false;
			if (typeof value[iteratorSymbol] === "function") return true;
			return isArrayLike(value);
		};
		return is;
	}

	var validateObject;
	var hasRequiredValidateObject;

	function requireValidateObject () {
		if (hasRequiredValidateObject) return validateObject;
		hasRequiredValidateObject = 1;

		var isObject = requireIsObject()
		  , is       = requireIs();

		validateObject = function (value) {
			if (is(value) && isObject(value)) return value;
			throw new TypeError(value + " is not an iterable or array-like object");
		};
		return validateObject;
	}

	var isImplemented;
	var hasRequiredIsImplemented;

	function requireIsImplemented () {
		if (hasRequiredIsImplemented) return isImplemented;
		hasRequiredIsImplemented = 1;

		var str = "foo";

		isImplemented = function () {
			if (typeof str.repeat !== "function") return false;
			return str.repeat(2) === "foofoo";
		};
		return isImplemented;
	}

	var shim;
	var hasRequiredShim;

	function requireShim () {
		if (hasRequiredShim) return shim;
		hasRequiredShim = 1;

		var value     = requireValidValue()
		  , toInteger = requireToInteger();

		shim = function (count) {
			var str = String(value(this)), result;
			count = toInteger(count);
			if (count < 0) throw new RangeError("Count must be >= 0");
			if (!isFinite(count)) throw new RangeError("Count must be < ");

			result = "";
			while (count) {
				if (count % 2) result += str;
				if (count > 1) str += str;
				// eslint-disable-next-line no-bitwise
				count >>= 1;
			}
			return result;
		};
		return shim;
	}

	var repeat$1;
	var hasRequiredRepeat;

	function requireRepeat () {
		if (hasRequiredRepeat) return repeat$1;
		hasRequiredRepeat = 1;

		repeat$1 = requireIsImplemented()() ? String.prototype.repeat : requireShim();
		return repeat$1;
	}

	var regexAnsi;
	var hasRequiredRegexAnsi;

	function requireRegexAnsi () {
		if (hasRequiredRegexAnsi) return regexAnsi;
		hasRequiredRegexAnsi = 1;

		regexAnsi = function () {
			// Borrowed from ansi-regex package
			// https://github.com/chalk/ansi-regex/blob/a28b8e7ee67aa9996ba44bf123f0436eea62d285/index.js

			return new RegExp(
				"[\\u001B\\u009B][[\\]()#;?]" +
					"*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]" +
					"+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)" +
					"|" +
					"(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))",
				"g"
			);
		};
		return regexAnsi;
	}

	var strip;
	var hasRequiredStrip;

	function requireStrip () {
		if (hasRequiredStrip) return strip;
		hasRequiredStrip = 1;

		var stringifiable = requireValidateStringifiable()
		  , r             = requireRegexAnsi()();

		strip = function (str) { return stringifiable(str).replace(r, ""); };
		return strip;
	}

	var getStrippedLength;
	var hasRequiredGetStrippedLength;

	function requireGetStrippedLength () {
		if (hasRequiredGetStrippedLength) return getStrippedLength;
		hasRequiredGetStrippedLength = 1;

		/*
		 * get actual length of ANSI-formatted string
		 */

		var strip = requireStrip();

		getStrippedLength = function (str) { return strip(str).length; };
		return getStrippedLength;
	}

	var columns;
	var hasRequiredColumns;

	function requireColumns () {
		if (hasRequiredColumns) return columns;
		hasRequiredColumns = 1;

		var generate          = requireGenerate()
		  , from              = requireFrom()
		  , iterable          = requireValidateObject()
		  , isValue           = requireIsValue()
		  , stringifiable     = requireValidateStringifiable()
		  , repeat            = requireRepeat()
		  , getStrippedLength = requireGetStrippedLength();

		var push = Array.prototype.push;

		columns = function (inputRows /*, options*/) {
			var options = Object(arguments[1])
			  , colsMeta = []
			  , colsOptions = options.columns || []
			  , rows = [];

			from(iterable(inputRows), function (row) {
				var rowRows = [[]];
				from(iterable(row), function (cellStr, columnIndex) {
					var cellRows = stringifiable(cellStr).split("\n");
					while (cellRows.length > rowRows.length) rowRows.push(generate(columnIndex, ""));
					cellRows.forEach(function (cellRow, rowRowIndex) {
						rowRows[rowRowIndex][columnIndex] = cellRow;
					});
				});
				push.apply(rows, rowRows);
			});

			return (
				rows
					.map(function (row) {
						return from(iterable(row), function (str, index) {
							var col = colsMeta[index], strLength;
							if (!col) col = colsMeta[index] = { width: 0 };
							str = stringifiable(str);
							strLength = getStrippedLength(str);
							if (strLength > col.width) col.width = strLength;
							return { str: str, length: strLength };
						});
					})
					.map(function (row) {
						return row
							.map(function (item, index) {
								var pad, align = "left", colOptions = colsOptions && colsOptions[index];
								align = colOptions && colOptions.align === "right" ? "right" : "left";
								pad = repeat.call(" ", colsMeta[index].width - item.length);
								if (align === "left") return item.str + pad;
								return pad + item.str;
							})
							.join(isValue(options.sep) ? options.sep : " | ");
					})
					.join("\n") + "\n"
			);
		};
		return columns;
	}

	/* eslint max-lines: "off" */

	var slice;
	var hasRequiredSlice;

	function requireSlice () {
		if (hasRequiredSlice) return slice;
		hasRequiredSlice = 1;

		var reAnsi        = requireRegexAnsi()
		  , stringifiable = requireValidateStringifiableValue()
		  , length        = requireGetStrippedLength()
		  , sgr           = requireSgr()
		  , max           = Math.max;

		var Token = function (token) { this.token = token; };

		var tokenize = function (str) {
			var match = reAnsi().exec(str);

			if (!match) {
				return [str];
			}

			var index = match.index, head, prehead, tail;

			if (index === 0) {
				head = match[0];
				tail = str.slice(head.length);

				return [new Token(head)].concat(tokenize(tail));
			}

			prehead = str.slice(0, index);
			head = match[0];
			tail = str.slice(index + head.length);

			return [prehead, new Token(head)].concat(tokenize(tail));
		};

		var isChunkInSlice = function (chunk, index, begin, end) {
			var endIndex = chunk.length + index;

			if (begin > endIndex) return false;
			if (end < index) return false;
			return true;
		};

		// eslint-disable-next-line max-lines-per-function
		var sliceSeq = function (seq, begin, end) {
			var sliced = seq.reduce(
				function (state, chunk) {
					var index = state.index;

					if (chunk instanceof Token) {
						var code = sgr.extractCode(chunk.token);

						if (index <= begin) {
							if (code in sgr.openers) {
								sgr.openStyle(state.preOpeners, code);
							}
							if (code in sgr.closers) {
								sgr.closeStyle(state.preOpeners, code);
							}
						} else if (index < end) {
							if (code in sgr.openers) {
								sgr.openStyle(state.inOpeners, code);
								state.seq.push(chunk);
							} else if (code in sgr.closers) {
								state.inClosers.push(code);
								state.seq.push(chunk);
							}
						}
					} else {
						var nextChunk = "";

						if (isChunkInSlice(chunk, index, begin, end)) {
							var relBegin = Math.max(begin - index, 0)
							  , relEnd = Math.min(end - index, chunk.length);

							nextChunk = chunk.slice(relBegin, relEnd);
						}

						state.seq.push(nextChunk);
						state.index = index + chunk.length;
					}

					return state;
				},
				{
					index: 0,
					seq: [],

					// preOpeners -> [ mod ]
					// preOpeners must be prepended to the slice if they wasn't closed til the end of it
					// preOpeners must be closed if they wasn't closed til the end of the slice
					preOpeners: [],

					// inOpeners  -> [ mod ]
					// inOpeners already in the slice and must not be prepended to the slice
					// inOpeners must be closed if they wasn't closed til the end of the slice
					inOpeners: [], // opener CSI inside slice

					// inClosers -> [ code ]
					// closer CSIs for determining which pre/in-Openers must be closed
					inClosers: []
				}
			);

			sliced.seq = [].concat(
				sgr.prepend(sliced.preOpeners), sliced.seq,
				sgr.complete([].concat(sliced.preOpeners, sliced.inOpeners), sliced.inClosers)
			);

			return sliced.seq;
		};

		slice = function (str /*, begin, end*/) {
			var seq, begin = Number(arguments[1]), end = Number(arguments[2]), len;

			str = stringifiable(str);
			len = length(str);

			if (isNaN(begin)) {
				begin = 0;
			}
			if (isNaN(end)) {
				end = len;
			}
			if (begin < 0) {
				begin = max(len + begin, 0);
			}
			if (end < 0) {
				end = max(len + end, 0);
			}

			seq = tokenize(str);
			seq = sliceSeq(seq, begin, end);
			return seq
				.map(function (chunk) {
					if (chunk instanceof Token) {
						return chunk.token;
					}

					return chunk;
				})
				.join("");
		};
		return slice;
	}

	var throbber = {exports: {}};

	var compose;
	var hasRequiredCompose;

	function requireCompose () {
		if (hasRequiredCompose) return compose;
		hasRequiredCompose = 1;

		var isValue  = requireIsValue()
		  , callable = requireValidCallable()
		  , aFrom    = requireFrom();

		var apply = Function.prototype.apply
		  , call = Function.prototype.call
		  , callFn = function (arg, fn) { return call.call(fn, this, arg); };

		compose = function (fnIgnored /*, fnn*/) {
			var fns, first;
			var args = aFrom(arguments);
			fns = isValue(this) ? [this].concat(args) : args;
			fns.forEach(callable);
			fns = fns.reverse();
			first = fns[0];
			fns = fns.slice(1);
			return function (argIgnored) { return fns.reduce(callFn, apply.call(first, this, arguments)); };
		};
		return compose;
	}

	var hasRequiredThrobber;

	function requireThrobber () {
		if (hasRequiredThrobber) return throbber.exports;
		hasRequiredThrobber = 1;
		(function (module, exports) {

			var compose      = requireCompose()
			  , callable     = requireValidCallable()
			  , d            = requireD()
			  , validTimeout = requireValidTimeout();

			var chars = "-\\|/", l = chars.length, ThrobberIterator;

			ThrobberIterator = function () {
				// no setup needed
			};
			Object.defineProperties(ThrobberIterator.prototype, {
				index: d(-1),
				running: d(false),
				next: d(function () {
					var str = this.running ? "\u0008" : "";
					if (!this.running) this.running = true;
					return str + chars[(this.index = (this.index + 1) % l)];
				}),
				reset: d(function () {
					if (!this.running) return "";
					this.index = -1;
					this.running = false;
					return "\u0008";
				})
			});

			module.exports = exports = function (write, interval /*, format*/) {
				var format = arguments[2], token, iterator = new ThrobberIterator();
				callable(write);
				interval = validTimeout(interval);
				if (format !== undefined) write = compose.call(write, callable(format));
				return {
					start: function () {
						if (token) return;
						token = setInterval(function () { write(iterator.next()); }, interval);
					},
					restart: function () {
						this.stop();
						this.start();
					},
					stop: function () {
						if (!token) return;
						clearInterval(token);
						token = null;
						write(iterator.reset());
					}
				};
			};

			Object.defineProperty(exports, "Iterator", d(ThrobberIterator)); 
		} (throbber, throbber.exports));
		return throbber.exports;
	}

	var reset;
	var hasRequiredReset;

	function requireReset () {
		if (hasRequiredReset) return reset;
		hasRequiredReset = 1;

		reset = "\x1b[2J\x1b[0;0H";
		return reset;
	}

	var validObject;
	var hasRequiredValidObject;

	function requireValidObject () {
		if (hasRequiredValidObject) return validObject;
		hasRequiredValidObject = 1;

		var isObject = requireIsObject();

		validObject = function (value) {
			if (!isObject(value)) throw new TypeError(value + " is not an Object");
			return value;
		};
		return validObject;
	}

	var array = {exports: {}};

	var clear;
	var hasRequiredClear;

	function requireClear () {
		if (hasRequiredClear) return clear;
		hasRequiredClear = 1;

		var value = requireValidValue();

		clear = function () {
			value(this).length = 0;
			return this;
		};
		return clear;
	}

	var ensure;
	var hasRequiredEnsure;

	function requireEnsure () {
		if (hasRequiredEnsure) return ensure;
		hasRequiredEnsure = 1;

		var resolveException = requireResolveException()
		  , is               = requireIs$1();

		ensure = function (value/*, options*/) {
			if (is(value)) return value;
			var options = arguments[1];
			var errorMessage =
				options && options.name
					? "Expected a plain function for %n, received %v"
					: "%v is not a plain function";
			return resolveException(value, errorMessage, options);
		};
		return ensure;
	}

	var copy;
	var hasRequiredCopy;

	function requireCopy () {
		if (hasRequiredCopy) return copy;
		hasRequiredCopy = 1;

		var aFrom  = requireFrom()
		  , assign = requireAssign()
		  , value  = requireValidValue();

		copy = function (obj /*, propertyNames, options*/) {
			var copy = Object(value(obj)), propertyNames = arguments[1], options = Object(arguments[2]);
			if (copy !== obj && !propertyNames) return copy;
			var result = {};
			if (propertyNames) {
				aFrom(propertyNames, function (propertyName) {
					if (options.ensure || propertyName in obj) result[propertyName] = obj[propertyName];
				});
			} else {
				assign(result, obj);
			}
			return result;
		};
		return copy;
	}

	var autoBind;
	var hasRequiredAutoBind;

	function requireAutoBind () {
		if (hasRequiredAutoBind) return autoBind;
		hasRequiredAutoBind = 1;

		var isValue             = requireIs$5()
		  , ensureValue         = requireEnsure$1()
		  , ensurePlainFunction = requireEnsure()
		  , copy                = requireCopy()
		  , normalizeOptions    = requireNormalizeOptions()
		  , map                 = requireMap();

		var bind = Function.prototype.bind
		  , defineProperty = Object.defineProperty
		  , hasOwnProperty = Object.prototype.hasOwnProperty
		  , define;

		define = function (name, desc, options) {
			var value = ensureValue(desc) && ensurePlainFunction(desc.value), dgs;
			dgs = copy(desc);
			delete dgs.writable;
			delete dgs.value;
			dgs.get = function () {
				if (!options.overwriteDefinition && hasOwnProperty.call(this, name)) return value;
				desc.value = bind.call(value, options.resolveContext ? options.resolveContext(this) : this);
				defineProperty(this, name, desc);
				return this[name];
			};
			return dgs;
		};

		autoBind = function (props/*, options*/) {
			var options = normalizeOptions(arguments[1]);
			if (isValue(options.resolveContext)) ensurePlainFunction(options.resolveContext);
			return map(props, function (desc, name) { return define(name, desc, options); });
		};
		return autoBind;
	}

	var es6Iterator;
	var hasRequiredEs6Iterator;

	function requireEs6Iterator () {
		if (hasRequiredEs6Iterator) return es6Iterator;
		hasRequiredEs6Iterator = 1;

		var clear    = requireClear()
		  , assign   = requireAssign()
		  , callable = requireValidCallable()
		  , value    = requireValidValue()
		  , d        = requireD()
		  , autoBind = requireAutoBind()
		  , Symbol   = requireEs6Symbol();

		var defineProperty = Object.defineProperty, defineProperties = Object.defineProperties, Iterator;

		es6Iterator = Iterator = function (list, context) {
			if (!(this instanceof Iterator)) throw new TypeError("Constructor requires 'new'");
			defineProperties(this, {
				__list__: d("w", value(list)),
				__context__: d("w", context),
				__nextIndex__: d("w", 0)
			});
			if (!context) return;
			callable(context.on);
			context.on("_add", this._onAdd);
			context.on("_delete", this._onDelete);
			context.on("_clear", this._onClear);
		};

		// Internal %IteratorPrototype% doesn't expose its constructor
		delete Iterator.prototype.constructor;

		defineProperties(
			Iterator.prototype,
			assign(
				{
					_next: d(function () {
						var i;
						if (!this.__list__) return undefined;
						if (this.__redo__) {
							i = this.__redo__.shift();
							if (i !== undefined) return i;
						}
						if (this.__nextIndex__ < this.__list__.length) return this.__nextIndex__++;
						this._unBind();
						return undefined;
					}),
					next: d(function () {
						return this._createResult(this._next());
					}),
					_createResult: d(function (i) {
						if (i === undefined) return { done: true, value: undefined };
						return { done: false, value: this._resolve(i) };
					}),
					_resolve: d(function (i) {
						return this.__list__[i];
					}),
					_unBind: d(function () {
						this.__list__ = null;
						delete this.__redo__;
						if (!this.__context__) return;
						this.__context__.off("_add", this._onAdd);
						this.__context__.off("_delete", this._onDelete);
						this.__context__.off("_clear", this._onClear);
						this.__context__ = null;
					}),
					toString: d(function () {
						return "[object " + (this[Symbol.toStringTag] || "Object") + "]";
					})
				},
				autoBind({
					_onAdd: d(function (index) {
						if (index >= this.__nextIndex__) return;
						++this.__nextIndex__;
						if (!this.__redo__) {
							defineProperty(this, "__redo__", d("c", [index]));
							return;
						}
						this.__redo__.forEach(function (redo, i) {
							if (redo >= index) this.__redo__[i] = ++redo;
						}, this);
						this.__redo__.push(index);
					}),
					_onDelete: d(function (index) {
						var i;
						if (index >= this.__nextIndex__) return;
						--this.__nextIndex__;
						if (!this.__redo__) return;
						i = this.__redo__.indexOf(index);
						if (i !== -1) this.__redo__.splice(i, 1);
						this.__redo__.forEach(function (redo, j) {
							if (redo > index) this.__redo__[j] = --redo;
						}, this);
					}),
					_onClear: d(function () {
						if (this.__redo__) clear.call(this.__redo__);
						this.__nextIndex__ = 0;
					})
				})
			)
		);

		defineProperty(
			Iterator.prototype,
			Symbol.iterator,
			d(function () {
				return this;
			})
		);
		return es6Iterator;
	}

	var hasRequiredArray;

	function requireArray () {
		if (hasRequiredArray) return array.exports;
		hasRequiredArray = 1;

		var setPrototypeOf = requireSetPrototypeOf()
		  , contains       = requireContains()
		  , d              = requireD()
		  , Symbol         = requireEs6Symbol()
		  , Iterator       = requireEs6Iterator();

		var defineProperty = Object.defineProperty, ArrayIterator;

		ArrayIterator = array.exports = function (arr, kind) {
			if (!(this instanceof ArrayIterator)) throw new TypeError("Constructor requires 'new'");
			Iterator.call(this, arr);
			if (!kind) kind = "value";
			else if (contains.call(kind, "key+value")) kind = "key+value";
			else if (contains.call(kind, "key")) kind = "key";
			else kind = "value";
			defineProperty(this, "__kind__", d("", kind));
		};
		if (setPrototypeOf) setPrototypeOf(ArrayIterator, Iterator);

		// Internal %ArrayIteratorPrototype% doesn't expose its constructor
		delete ArrayIterator.prototype.constructor;

		ArrayIterator.prototype = Object.create(Iterator.prototype, {
			_resolve: d(function (i) {
				if (this.__kind__ === "value") return this.__list__[i];
				if (this.__kind__ === "key+value") return [i, this.__list__[i]];
				return i;
			})
		});
		defineProperty(ArrayIterator.prototype, Symbol.toStringTag, d("c", "Array Iterator"));
		return array.exports;
	}

	var string = {exports: {}};

	var hasRequiredString;

	function requireString () {
		if (hasRequiredString) return string.exports;
		hasRequiredString = 1;

		var setPrototypeOf = requireSetPrototypeOf()
		  , d              = requireD()
		  , Symbol         = requireEs6Symbol()
		  , Iterator       = requireEs6Iterator();

		var defineProperty = Object.defineProperty, StringIterator;

		StringIterator = string.exports = function (str) {
			if (!(this instanceof StringIterator)) throw new TypeError("Constructor requires 'new'");
			str = String(str);
			Iterator.call(this, str);
			defineProperty(this, "__length__", d("", str.length));
		};
		if (setPrototypeOf) setPrototypeOf(StringIterator, Iterator);

		// Internal %ArrayIteratorPrototype% doesn't expose its constructor
		delete StringIterator.prototype.constructor;

		StringIterator.prototype = Object.create(Iterator.prototype, {
			_next: d(function () {
				if (!this.__list__) return undefined;
				if (this.__nextIndex__ < this.__length__) return this.__nextIndex__++;
				this._unBind();
				return undefined;
			}),
			_resolve: d(function (i) {
				var char = this.__list__[i], code;
				if (this.__nextIndex__ === this.__length__) return char;
				code = char.charCodeAt(0);
				if (code >= 0xd800 && code <= 0xdbff) return char + this.__list__[this.__nextIndex__++];
				return char;
			})
		});
		defineProperty(StringIterator.prototype, Symbol.toStringTag, d("c", "String Iterator"));
		return string.exports;
	}

	var isIterable;
	var hasRequiredIsIterable;

	function requireIsIterable () {
		if (hasRequiredIsIterable) return isIterable;
		hasRequiredIsIterable = 1;

		var isArguments = requireIsArguments()
		  , isValue     = requireIsValue()
		  , isString    = requireIsString();

		var iteratorSymbol = requireEs6Symbol().iterator
		  , isArray        = Array.isArray;

		isIterable = function (value) {
			if (!isValue(value)) return false;
			if (isArray(value)) return true;
			if (isString(value)) return true;
			if (isArguments(value)) return true;
			return typeof value[iteratorSymbol] === "function";
		};
		return isIterable;
	}

	var validIterable;
	var hasRequiredValidIterable;

	function requireValidIterable () {
		if (hasRequiredValidIterable) return validIterable;
		hasRequiredValidIterable = 1;

		var isIterable = requireIsIterable();

		validIterable = function (value) {
			if (!isIterable(value)) throw new TypeError(value + " is not iterable");
			return value;
		};
		return validIterable;
	}

	var get;
	var hasRequiredGet;

	function requireGet () {
		if (hasRequiredGet) return get;
		hasRequiredGet = 1;

		var isArguments    = requireIsArguments()
		  , isString       = requireIsString()
		  , ArrayIterator  = requireArray()
		  , StringIterator = requireString()
		  , iterable       = requireValidIterable()
		  , iteratorSymbol = requireEs6Symbol().iterator;

		get = function (obj) {
			if (typeof iterable(obj)[iteratorSymbol] === "function") return obj[iteratorSymbol]();
			if (isArguments(obj)) return new ArrayIterator(obj);
			if (isString(obj)) return new StringIterator(obj);
			return new ArrayIterator(obj);
		};
		return get;
	}

	var forOf;
	var hasRequiredForOf;

	function requireForOf () {
		if (hasRequiredForOf) return forOf;
		hasRequiredForOf = 1;

		var isArguments = requireIsArguments()
		  , callable    = requireValidCallable()
		  , isString    = requireIsString()
		  , get         = requireGet();

		var isArray = Array.isArray, call = Function.prototype.call, some = Array.prototype.some;

		forOf = function (iterable, cb /*, thisArg*/) {
			var mode, thisArg = arguments[2], result, doBreak, broken, i, length, char, code;
			if (isArray(iterable) || isArguments(iterable)) mode = "array";
			else if (isString(iterable)) mode = "string";
			else iterable = get(iterable);

			callable(cb);
			doBreak = function () {
				broken = true;
			};
			if (mode === "array") {
				some.call(iterable, function (value) {
					call.call(cb, thisArg, value, doBreak);
					return broken;
				});
				return;
			}
			if (mode === "string") {
				length = iterable.length;
				for (i = 0; i < length; ++i) {
					char = iterable[i];
					if (i + 1 < length) {
						code = char.charCodeAt(0);
						if (code >= 0xd800 && code <= 0xdbff) char += iterable[++i];
					}
					call.call(cb, thisArg, char, doBreak);
					if (broken) break;
				}
				return;
			}
			result = iterable.next();

			while (!result.done) {
				call.call(cb, thisArg, result.value, doBreak);
				if (broken) return;
				result = iterable.next();
			}
		};
		return forOf;
	}

	var art;
	var hasRequiredArt;

	function requireArt () {
		if (hasRequiredArt) return art;
		hasRequiredArt = 1;

		var object        = requireValidObject()
		  , stringifiable = requireValidateStringifiableValue()
		  , forOf         = requireForOf();

		art = function (text, style) {
			var result = "";
			text = stringifiable(text);
			object(style);
			forOf(text, function (char) { result += style[char] || char; });
			return result;
		};
		return art;
	}

	var cliColor;
	var hasRequiredCliColor;

	function requireCliColor () {
		if (hasRequiredCliColor) return cliColor;
		hasRequiredCliColor = 1;

		var d = requireD();

		cliColor = Object.defineProperties(requireBare(), {
			windowSize: d(requireWindowSize()),
			erase: d(requireErase()),
			move: d(requireMove()),
			beep: d(requireBeep()),
			columns: d(requireColumns()),
			strip: d(requireStrip()),
			getStrippedLength: d(requireGetStrippedLength()),
			slice: d(requireSlice()),
			throbber: d(requireThrobber()),
			reset: d(requireReset()),
			art: d(requireArt())
		});
		return cliColor;
	}

	var __spreadArray$1 = (commonjsGlobal && commonjsGlobal.__spreadArray) || function (to, from, pack) {
	    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
	        if (ar || !(i in from)) {
	            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
	            ar[i] = from[i];
	        }
	    }
	    return to.concat(ar || Array.prototype.slice.call(from));
	};
	Object.defineProperty(utils, "__esModule", { value: true });
	utils.isSchemaLike = utils.appendToDescription = utils.maybeStripNameHints = utils.maybeStripDefault = utils.pathTransform = utils.escapeBlockComment = utils.log = utils.error = utils.generateName = utils.toSafeString = utils.stripExtension = utils.justName = utils.traverse = utils.Try = void 0;
	var lodash_1$3 = lodashExports;
	var path_1 = require$$2;
	var JSONSchema_1$4 = JSONSchema;
	// TODO: pull out into a separate package
	function Try(fn, err) {
	    try {
	        return fn();
	    }
	    catch (e) {
	        return err(e);
	    }
	}
	utils.Try = Try;
	// keys that shouldn't be traversed by the catchall step
	var BLACKLISTED_KEYS = new Set([
	    'id',
	    '$defs',
	    '$id',
	    '$schema',
	    'title',
	    'description',
	    'default',
	    'multipleOf',
	    'maximum',
	    'exclusiveMaximum',
	    'minimum',
	    'exclusiveMinimum',
	    'maxLength',
	    'minLength',
	    'pattern',
	    'additionalItems',
	    'items',
	    'maxItems',
	    'minItems',
	    'uniqueItems',
	    'maxProperties',
	    'minProperties',
	    'required',
	    'additionalProperties',
	    'definitions',
	    'properties',
	    'patternProperties',
	    'dependencies',
	    'enum',
	    'type',
	    'allOf',
	    'anyOf',
	    'oneOf',
	    'not',
	]);
	function traverseObjectKeys(obj, callback, processed) {
	    Object.keys(obj).forEach(function (k) {
	        if (obj[k] && typeof obj[k] === 'object' && !Array.isArray(obj[k])) {
	            traverse(obj[k], callback, processed, k);
	        }
	    });
	}
	function traverseArray(arr, callback, processed) {
	    arr.forEach(function (s, k) { return traverse(s, callback, processed, k.toString()); });
	}
	function traverse(schema, callback, processed, key) {
	    if (processed === void 0) { processed = new Set(); }
	    // Handle recursive schemas
	    if (processed.has(schema)) {
	        return;
	    }
	    processed.add(schema);
	    callback(schema, key !== null && key !== void 0 ? key : null);
	    if (schema.anyOf) {
	        traverseArray(schema.anyOf, callback, processed);
	    }
	    if (schema.allOf) {
	        traverseArray(schema.allOf, callback, processed);
	    }
	    if (schema.oneOf) {
	        traverseArray(schema.oneOf, callback, processed);
	    }
	    if (schema.properties) {
	        traverseObjectKeys(schema.properties, callback, processed);
	    }
	    if (schema.patternProperties) {
	        traverseObjectKeys(schema.patternProperties, callback, processed);
	    }
	    if (schema.additionalProperties && typeof schema.additionalProperties === 'object') {
	        traverse(schema.additionalProperties, callback, processed);
	    }
	    if (schema.items) {
	        var items = schema.items;
	        if (Array.isArray(items)) {
	            traverseArray(items, callback, processed);
	        }
	        else {
	            traverse(items, callback, processed);
	        }
	    }
	    if (schema.additionalItems && typeof schema.additionalItems === 'object') {
	        traverse(schema.additionalItems, callback, processed);
	    }
	    if (schema.dependencies) {
	        if (Array.isArray(schema.dependencies)) {
	            traverseArray(schema.dependencies, callback, processed);
	        }
	        else {
	            traverseObjectKeys(schema.dependencies, callback, processed);
	        }
	    }
	    if (schema.definitions) {
	        traverseObjectKeys(schema.definitions, callback, processed);
	    }
	    if (schema.$defs) {
	        traverseObjectKeys(schema.$defs, callback, processed);
	    }
	    if (schema.not) {
	        traverse(schema.not, callback, processed);
	    }
	    // technically you can put definitions on any key
	    Object.keys(schema)
	        .filter(function (key) { return !BLACKLISTED_KEYS.has(key); })
	        .forEach(function (key) {
	        var child = schema[key];
	        if (child && typeof child === 'object') {
	            traverseObjectKeys(child, callback, processed);
	        }
	    });
	}
	utils.traverse = traverse;
	/**
	 * Eg. `foo/bar/baz.json` => `baz`
	 */
	function justName(filename) {
	    if (filename === void 0) { filename = ''; }
	    return stripExtension((0, path_1.basename)(filename));
	}
	utils.justName = justName;
	/**
	 * Avoid appending "js" to top-level unnamed schemas
	 */
	function stripExtension(filename) {
	    return filename.replace((0, path_1.extname)(filename), '');
	}
	utils.stripExtension = stripExtension;
	/**
	 * Convert a string that might contain spaces or special characters to one that
	 * can safely be used as a TypeScript interface or enum name.
	 */
	function toSafeString(string) {
	    // identifiers in javaScript/ts:
	    // First character: a-zA-Z | _ | $
	    // Rest: a-zA-Z | _ | $ | 0-9
	    return (0, lodash_1$3.upperFirst)(
	    // remove accents, umlauts, ... by their basic latin letters
	    (0, lodash_1$3.deburr)(string)
	        // replace chars which are not valid for typescript identifiers with whitespace
	        .replace(/(^\s*[^a-zA-Z_$])|([^a-zA-Z_$\d])/g, ' ')
	        // uppercase leading underscores followed by lowercase
	        .replace(/^_[a-z]/g, function (match) { return match.toUpperCase(); })
	        // remove non-leading underscores followed by lowercase (convert snake_case)
	        .replace(/_[a-z]/g, function (match) { return match.substr(1, match.length).toUpperCase(); })
	        // uppercase letters after digits, dollars
	        .replace(/([\d$]+[a-zA-Z])/g, function (match) { return match.toUpperCase(); })
	        // uppercase first letter after whitespace
	        .replace(/\s+([a-zA-Z])/g, function (match) { return (0, lodash_1$3.trim)(match.toUpperCase()); })
	        // remove remaining whitespace
	        .replace(/\s/g, ''));
	}
	utils.toSafeString = toSafeString;
	function generateName(from, usedNames) {
	    var name = toSafeString(from);
	    if (!name) {
	        name = 'NoName';
	    }
	    // increment counter until we find a free name
	    if (usedNames.has(name)) {
	        var counter = 1;
	        var nameWithCounter = "".concat(name).concat(counter);
	        while (usedNames.has(nameWithCounter)) {
	            nameWithCounter = "".concat(name).concat(counter);
	            counter++;
	        }
	        name = nameWithCounter;
	    }
	    usedNames.add(name);
	    return name;
	}
	utils.generateName = generateName;
	function error() {
	    var _a;
	    var messages = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        messages[_i] = arguments[_i];
	    }
	    if (!browser$1.env.VERBOSE) {
	        return console.error(messages);
	    }
	    console.error.apply(console, __spreadArray$1([(_a = getStyledTextForLogging('red')) === null || _a === void 0 ? void 0 : _a('error')], messages, false));
	}
	utils.error = error;
	function log$1(style, title) {
	    var _a;
	    var messages = [];
	    for (var _i = 2; _i < arguments.length; _i++) {
	        messages[_i - 2] = arguments[_i];
	    }
	    if (!browser$1.env.VERBOSE) {
	        return;
	    }
	    var lastMessage = null;
	    if (messages.length > 1 && typeof messages[messages.length - 1] !== 'string') {
	        lastMessage = messages.splice(messages.length - 1, 1);
	    }
	    console.info.apply(console, __spreadArray$1([requireCliColor().whiteBright.bgCyan('debug'), (_a = getStyledTextForLogging(style)) === null || _a === void 0 ? void 0 : _a(title)], messages, false));
	    if (lastMessage) {
	        console.dir(lastMessage, { depth: 6, maxArrayLength: 6 });
	    }
	}
	utils.log = log$1;
	function getStyledTextForLogging(style) {
	    if (!browser$1.env.VERBOSE) {
	        return;
	    }
	    switch (style) {
	        case 'blue':
	            return requireCliColor().whiteBright.bgBlue;
	        case 'cyan':
	            return requireCliColor().whiteBright.bgCyan;
	        case 'green':
	            return requireCliColor().whiteBright.bgGreen;
	        case 'magenta':
	            return requireCliColor().whiteBright.bgMagenta;
	        case 'red':
	            return requireCliColor().whiteBright.bgRedBright;
	        case 'white':
	            return requireCliColor().black.bgWhite;
	        case 'yellow':
	            return requireCliColor().whiteBright.bgYellow;
	    }
	}
	/**
	 * escape block comments in schema descriptions so that they don't unexpectedly close JSDoc comments in generated typescript interfaces
	 */
	function escapeBlockComment(schema) {
	    var replacer = '* /';
	    if (schema === null || typeof schema !== 'object') {
	        return;
	    }
	    for (var _i = 0, _a = Object.keys(schema); _i < _a.length; _i++) {
	        var key = _a[_i];
	        if (key === 'description' && typeof schema[key] === 'string') {
	            schema[key] = schema[key].replace(/\*\//g, replacer);
	        }
	    }
	}
	utils.escapeBlockComment = escapeBlockComment;
	/*
	the following logic determines the out path by comparing the in path to the users specified out path.
	For example, if input directory MultiSchema looks like:
	  MultiSchema/foo/a.json
	  MultiSchema/bar/fuzz/c.json
	  MultiSchema/bar/d.json
	And the user wants the outputs to be in MultiSchema/Out, then this code will be able to map the inner directories foo, bar, and fuzz into the intended Out directory like so:
	  MultiSchema/Out/foo/a.json
	  MultiSchema/Out/bar/fuzz/c.json
	  MultiSchema/Out/bar/d.json
	*/
	function pathTransform(outputPath, inputPath, filePath) {
	    var inPathList = (0, path_1.normalize)(inputPath).split(path_1.sep);
	    var filePathList = (0, path_1.dirname)((0, path_1.normalize)(filePath)).split(path_1.sep);
	    var filePathRel = filePathList.filter(function (f, i) { return f !== inPathList[i]; });
	    return path_1.posix.join.apply(path_1.posix, __spreadArray$1([path_1.posix.normalize(outputPath)], filePathRel, false));
	}
	utils.pathTransform = pathTransform;
	/**
	 * Removes the schema's `default` property if it doesn't match the schema's `type` property.
	 * Useful when parsing unions.
	 *
	 * Mutates `schema`.
	 */
	function maybeStripDefault(schema) {
	    if (!('default' in schema)) {
	        return schema;
	    }
	    switch (schema.type) {
	        case 'array':
	            if (Array.isArray(schema.default)) {
	                return schema;
	            }
	            break;
	        case 'boolean':
	            if (typeof schema.default === 'boolean') {
	                return schema;
	            }
	            break;
	        case 'integer':
	        case 'number':
	            if (typeof schema.default === 'number') {
	                return schema;
	            }
	            break;
	        case 'string':
	            if (typeof schema.default === 'string') {
	                return schema;
	            }
	            break;
	        case 'null':
	            if (schema.default === null) {
	                return schema;
	            }
	            break;
	        case 'object':
	            if ((0, lodash_1$3.isPlainObject)(schema.default)) {
	                return schema;
	            }
	            break;
	    }
	    delete schema.default;
	    return schema;
	}
	utils.maybeStripDefault = maybeStripDefault;
	/**
	 * Removes the schema's `$id`, `name`, and `description` properties
	 * if they exist.
	 * Useful when parsing intersections.
	 *
	 * Mutates `schema`.
	 */
	function maybeStripNameHints(schema) {
	    if ('$id' in schema) {
	        delete schema.$id;
	    }
	    if ('description' in schema) {
	        delete schema.description;
	    }
	    if ('name' in schema) {
	        delete schema.name;
	    }
	    return schema;
	}
	utils.maybeStripNameHints = maybeStripNameHints;
	function appendToDescription(existingDescription) {
	    var values = [];
	    for (var _i = 1; _i < arguments.length; _i++) {
	        values[_i - 1] = arguments[_i];
	    }
	    if (existingDescription) {
	        return "".concat(existingDescription, "\n\n").concat(values.join('\n'));
	    }
	    return values.join('\n');
	}
	utils.appendToDescription = appendToDescription;
	function isSchemaLike(schema) {
	    if (!(0, lodash_1$3.isPlainObject)(schema)) {
	        return false;
	    }
	    var parent = schema[JSONSchema_1$4.Parent];
	    if (parent === null) {
	        return true;
	    }
	    var JSON_SCHEMA_KEYWORDS = [
	        '$defs',
	        'allOf',
	        'anyOf',
	        'definitions',
	        'dependencies',
	        'enum',
	        'not',
	        'oneOf',
	        'patternProperties',
	        'properties',
	        'required',
	    ];
	    if (JSON_SCHEMA_KEYWORDS.some(function (_) { return parent[_] === schema; })) {
	        return false;
	    }
	    return true;
	}
	utils.isSchemaLike = isSchemaLike;

	var hasRequiredGenerator;

	function requireGenerator () {
		if (hasRequiredGenerator) return generator;
		hasRequiredGenerator = 1;
		(function (exports) {
			var __spreadArray = (commonjsGlobal && commonjsGlobal.__spreadArray) || function (to, from, pack) {
			    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
			        if (ar || !(i in from)) {
			            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
			            ar[i] = from[i];
			        }
			    }
			    return to.concat(ar || Array.prototype.slice.call(from));
			};
			Object.defineProperty(exports, "__esModule", { value: true });
			exports.generateType = exports.generate = void 0;
			var lodash_1 = lodashExports;
			var index_1 = requireSrc();
			var AST_1 = AST;
			var utils_1 = utils;
			function generate(ast, options) {
			    if (options === void 0) { options = index_1.DEFAULT_OPTIONS; }
			    return ([
			        options.bannerComment,
			        declareNamedTypes(ast, options, ast.standaloneName),
			        declareNamedInterfaces(ast, options, ast.standaloneName),
			        declareEnums(ast, options),
			    ]
			        .filter(Boolean)
			        .join('\n\n') + '\n'); // trailing newline
			}
			exports.generate = generate;
			function declareEnums(ast, options, processed) {
			    if (processed === void 0) { processed = new Set(); }
			    if (processed.has(ast)) {
			        return '';
			    }
			    processed.add(ast);
			    var type = '';
			    switch (ast.type) {
			        case 'ENUM':
			            return generateStandaloneEnum(ast, options) + '\n';
			        case 'ARRAY':
			            return declareEnums(ast.params, options, processed);
			        case 'UNION':
			        case 'INTERSECTION':
			            return ast.params.reduce(function (prev, ast) { return prev + declareEnums(ast, options, processed); }, '');
			        case 'TUPLE':
			            type = ast.params.reduce(function (prev, ast) { return prev + declareEnums(ast, options, processed); }, '');
			            if (ast.spreadParam) {
			                type += declareEnums(ast.spreadParam, options, processed);
			            }
			            return type;
			        case 'INTERFACE':
			            return getSuperTypesAndParams(ast).reduce(function (prev, ast) { return prev + declareEnums(ast, options, processed); }, '');
			        default:
			            return '';
			    }
			}
			function declareNamedInterfaces(ast, options, rootASTName, processed) {
			    if (processed === void 0) { processed = new Set(); }
			    if (processed.has(ast)) {
			        return '';
			    }
			    processed.add(ast);
			    var type = '';
			    switch (ast.type) {
			        case 'ARRAY':
			            type = declareNamedInterfaces(ast.params, options, rootASTName, processed);
			            break;
			        case 'INTERFACE':
			            type = [
			                (0, AST_1.hasStandaloneName)(ast) &&
			                    (ast.standaloneName === rootASTName || options.declareExternallyReferenced) &&
			                    generateStandaloneInterface(ast, options),
			                getSuperTypesAndParams(ast)
			                    .map(function (ast) { return declareNamedInterfaces(ast, options, rootASTName, processed); })
			                    .filter(Boolean)
			                    .join('\n'),
			            ]
			                .filter(Boolean)
			                .join('\n');
			            break;
			        case 'INTERSECTION':
			        case 'TUPLE':
			        case 'UNION':
			            type = ast.params
			                .map(function (_) { return declareNamedInterfaces(_, options, rootASTName, processed); })
			                .filter(Boolean)
			                .join('\n');
			            if (ast.type === 'TUPLE' && ast.spreadParam) {
			                type += declareNamedInterfaces(ast.spreadParam, options, rootASTName, processed);
			            }
			            break;
			        default:
			            type = '';
			    }
			    return type;
			}
			function declareNamedTypes(ast, options, rootASTName, processed) {
			    if (processed === void 0) { processed = new Set(); }
			    if (processed.has(ast)) {
			        return '';
			    }
			    processed.add(ast);
			    switch (ast.type) {
			        case 'ARRAY':
			            return [
			                declareNamedTypes(ast.params, options, rootASTName, processed),
			                (0, AST_1.hasStandaloneName)(ast) ? generateStandaloneType(ast, options) : undefined,
			            ]
			                .filter(Boolean)
			                .join('\n');
			        case 'ENUM':
			            return '';
			        case 'INTERFACE':
			            return getSuperTypesAndParams(ast)
			                .map(function (ast) {
			                return (ast.standaloneName === rootASTName || options.declareExternallyReferenced) &&
			                    declareNamedTypes(ast, options, rootASTName, processed);
			            })
			                .filter(Boolean)
			                .join('\n');
			        case 'INTERSECTION':
			        case 'TUPLE':
			        case 'UNION':
			            return [
			                (0, AST_1.hasStandaloneName)(ast) ? generateStandaloneType(ast, options) : undefined,
			                ast.params
			                    .map(function (ast) { return declareNamedTypes(ast, options, rootASTName, processed); })
			                    .filter(Boolean)
			                    .join('\n'),
			                'spreadParam' in ast && ast.spreadParam
			                    ? declareNamedTypes(ast.spreadParam, options, rootASTName, processed)
			                    : undefined,
			            ]
			                .filter(Boolean)
			                .join('\n');
			        default:
			            if ((0, AST_1.hasStandaloneName)(ast)) {
			                return generateStandaloneType(ast, options);
			            }
			            return '';
			    }
			}
			function generateTypeUnmemoized(ast, options) {
			    var type = generateRawType(ast, options);
			    if (options.strictIndexSignatures && ast.keyName === '[k: string]') {
			        return "".concat(type, " | undefined");
			    }
			    return type;
			}
			exports.generateType = (0, lodash_1.memoize)(generateTypeUnmemoized);
			function generateRawType(ast, options) {
			    (0, utils_1.log)('magenta', 'generator', ast);
			    if ((0, AST_1.hasStandaloneName)(ast)) {
			        return (0, utils_1.toSafeString)(ast.standaloneName);
			    }
			    switch (ast.type) {
			        case 'ANY':
			            return 'any';
			        case 'ARRAY':
			            return (function () {
			                var type = (0, exports.generateType)(ast.params, options);
			                return type.endsWith('"') ? '(' + type + ')[]' : type + '[]';
			            })();
			        case 'BOOLEAN':
			            return 'boolean';
			        case 'INTERFACE':
			            return generateInterface(ast, options);
			        case 'INTERSECTION':
			            return generateSetOperation(ast, options);
			        case 'LITERAL':
			            return JSON.stringify(ast.params);
			        case 'NEVER':
			            return 'never';
			        case 'NUMBER':
			            return 'number';
			        case 'NULL':
			            return 'null';
			        case 'OBJECT':
			            return 'object';
			        case 'REFERENCE':
			            return ast.params;
			        case 'STRING':
			            return 'string';
			        case 'TUPLE':
			            return (function () {
			                var minItems = ast.minItems;
			                var maxItems = ast.maxItems || -1;
			                var spreadParam = ast.spreadParam;
			                var astParams = __spreadArray([], ast.params, true);
			                if (minItems > 0 && minItems > astParams.length && ast.spreadParam === undefined) {
			                    // this is a valid state, and JSONSchema doesn't care about the item type
			                    if (maxItems < 0) {
			                        // no max items and no spread param, so just spread any
			                        spreadParam = options.unknownAny ? AST_1.T_UNKNOWN : AST_1.T_ANY;
			                    }
			                }
			                if (maxItems > astParams.length && ast.spreadParam === undefined) {
			                    // this is a valid state, and JSONSchema doesn't care about the item type
			                    // fill the tuple with any elements
			                    for (var i = astParams.length; i < maxItems; i += 1) {
			                        astParams.push(options.unknownAny ? AST_1.T_UNKNOWN : AST_1.T_ANY);
			                    }
			                }
			                function addSpreadParam(params) {
			                    if (spreadParam) {
			                        var spread = '...(' + (0, exports.generateType)(spreadParam, options) + ')[]';
			                        params.push(spread);
			                    }
			                    return params;
			                }
			                function paramsToString(params) {
			                    return '[' + params.join(', ') + ']';
			                }
			                var paramsList = astParams.map(function (param) { return (0, exports.generateType)(param, options); });
			                if (paramsList.length > minItems) {
			                    /*
			                  if there are more items than the min, we return a union of tuples instead of
			                  using the optional element operator. This is done because it is more typesafe.
			          
			                  // optional element operator
			                  type A = [string, string?, string?]
			                  const a: A = ['a', undefined, 'c'] // no error
			          
			                  // union of tuples
			                  type B = [string] | [string, string] | [string, string, string]
			                  const b: B = ['a', undefined, 'c'] // TS error
			                  */
			                    var cumulativeParamsList = paramsList.slice(0, minItems);
			                    var typesToUnion = [];
			                    if (cumulativeParamsList.length > 0) {
			                        // actually has minItems, so add the initial state
			                        typesToUnion.push(paramsToString(cumulativeParamsList));
			                    }
			                    else {
			                        // no minItems means it's acceptable to have an empty tuple type
			                        typesToUnion.push(paramsToString([]));
			                    }
			                    for (var i = minItems; i < paramsList.length; i += 1) {
			                        cumulativeParamsList.push(paramsList[i]);
			                        if (i === paramsList.length - 1) {
			                            // only the last item in the union should have the spread parameter
			                            addSpreadParam(cumulativeParamsList);
			                        }
			                        typesToUnion.push(paramsToString(cumulativeParamsList));
			                    }
			                    return typesToUnion.join('|');
			                }
			                // no max items so only need to return one type
			                return paramsToString(addSpreadParam(paramsList));
			            })();
			        case 'UNION':
			            return generateSetOperation(ast, options);
			        case 'UNKNOWN':
			            return 'unknown';
			        case 'CUSTOM_TYPE':
			            return ast.params;
			    }
			}
			/**
			 * Generate a Union or Intersection
			 */
			function generateSetOperation(ast, options) {
			    var members = ast.params.map(function (_) { return (0, exports.generateType)(_, options); });
			    var separator = ast.type === 'UNION' ? '|' : '&';
			    return members.length === 1 ? members[0] : '(' + members.join(' ' + separator + ' ') + ')';
			}
			function generateInterface(ast, options) {
			    return ("{" +
			        '\n' +
			        ast.params
			            .filter(function (_) { return !_.isPatternProperty && !_.isUnreachableDefinition; })
			            .map(function (_a) {
			            var isRequired = _a.isRequired, keyName = _a.keyName, ast = _a.ast;
			            return [isRequired, keyName, ast, (0, exports.generateType)(ast, options)];
			        })
			            .map(function (_a) {
			            var isRequired = _a[0], keyName = _a[1], ast = _a[2], type = _a[3];
			            return ((0, AST_1.hasComment)(ast) && !ast.standaloneName ? generateComment(ast.comment, ast.deprecated) + '\n' : '') +
			                escapeKeyName(keyName) +
			                (isRequired ? '' : '?') +
			                ': ' +
			                type;
			        })
			            .join('\n') +
			        '\n' +
			        '}');
			}
			function generateComment(comment, deprecated) {
			    var commentLines = ['/**'];
			    if (deprecated) {
			        commentLines.push(' * @deprecated');
			    }
			    if (typeof comment !== 'undefined') {
			        commentLines.push.apply(commentLines, comment.split('\n').map(function (_) { return ' * ' + _; }));
			    }
			    commentLines.push(' */');
			    return commentLines.join('\n');
			}
			function generateStandaloneEnum(ast, options) {
			    return (((0, AST_1.hasComment)(ast) ? generateComment(ast.comment, ast.deprecated) + '\n' : '') +
			        'export ' +
			        (options.enableConstEnums ? 'const ' : '') +
			        "enum ".concat((0, utils_1.toSafeString)(ast.standaloneName), " {") +
			        '\n' +
			        ast.params.map(function (_a) {
			            var ast = _a.ast, keyName = _a.keyName;
			            return keyName + ' = ' + (0, exports.generateType)(ast, options);
			        }).join(',\n') +
			        '\n' +
			        '}');
			}
			function generateStandaloneInterface(ast, options) {
			    return (((0, AST_1.hasComment)(ast) ? generateComment(ast.comment, ast.deprecated) + '\n' : '') +
			        "export interface ".concat((0, utils_1.toSafeString)(ast.standaloneName), " ") +
			        (ast.superTypes.length > 0
			            ? "extends ".concat(ast.superTypes.map(function (superType) { return (0, utils_1.toSafeString)(superType.standaloneName); }).join(', '), " ")
			            : '') +
			        generateInterface(ast, options));
			}
			function generateStandaloneType(ast, options) {
			    return (((0, AST_1.hasComment)(ast) ? generateComment(ast.comment) + '\n' : '') +
			        "export type ".concat((0, utils_1.toSafeString)(ast.standaloneName), " = ").concat((0, exports.generateType)((0, lodash_1.omit)(ast, 'standaloneName') /* TODO */, options)));
			}
			function escapeKeyName(keyName) {
			    if (keyName.length && /[A-Za-z_$]/.test(keyName.charAt(0)) && /^[\w$]+$/.test(keyName)) {
			        return keyName;
			    }
			    if (keyName === '[k: string]') {
			        return keyName;
			    }
			    return JSON.stringify(keyName);
			}
			function getSuperTypesAndParams(ast) {
			    return ast.params.map(function (param) { return param.ast; }).concat(ast.superTypes);
			}
			
		} (generator));
		return generator;
	}

	var normalizer = {};

	var lookup = [];
	var revLookup = [];
	var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;
	var inited = false;
	function init () {
	  inited = true;
	  var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
	  for (var i = 0, len = code.length; i < len; ++i) {
	    lookup[i] = code[i];
	    revLookup[code.charCodeAt(i)] = i;
	  }

	  revLookup['-'.charCodeAt(0)] = 62;
	  revLookup['_'.charCodeAt(0)] = 63;
	}

	function toByteArray (b64) {
	  if (!inited) {
	    init();
	  }
	  var i, j, l, tmp, placeHolders, arr;
	  var len = b64.length;

	  if (len % 4 > 0) {
	    throw new Error('Invalid string. Length must be a multiple of 4')
	  }

	  // the number of equal signs (place holders)
	  // if there are two placeholders, than the two characters before it
	  // represent one byte
	  // if there is only one, then the three characters before it represent 2 bytes
	  // this is just a cheap hack to not do indexOf twice
	  placeHolders = b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0;

	  // base64 is 4/3 + up to two characters of the original data
	  arr = new Arr(len * 3 / 4 - placeHolders);

	  // if there are placeholders, only get up to the last complete 4 chars
	  l = placeHolders > 0 ? len - 4 : len;

	  var L = 0;

	  for (i = 0, j = 0; i < l; i += 4, j += 3) {
	    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)];
	    arr[L++] = (tmp >> 16) & 0xFF;
	    arr[L++] = (tmp >> 8) & 0xFF;
	    arr[L++] = tmp & 0xFF;
	  }

	  if (placeHolders === 2) {
	    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4);
	    arr[L++] = tmp & 0xFF;
	  } else if (placeHolders === 1) {
	    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2);
	    arr[L++] = (tmp >> 8) & 0xFF;
	    arr[L++] = tmp & 0xFF;
	  }

	  return arr
	}

	function tripletToBase64 (num) {
	  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]
	}

	function encodeChunk (uint8, start, end) {
	  var tmp;
	  var output = [];
	  for (var i = start; i < end; i += 3) {
	    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2]);
	    output.push(tripletToBase64(tmp));
	  }
	  return output.join('')
	}

	function fromByteArray (uint8) {
	  if (!inited) {
	    init();
	  }
	  var tmp;
	  var len = uint8.length;
	  var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes
	  var output = '';
	  var parts = [];
	  var maxChunkLength = 16383; // must be multiple of 3

	  // go through the array every three bytes, we'll deal with trailing stuff later
	  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
	    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)));
	  }

	  // pad the end with zeros, but make sure to not forget the extra bytes
	  if (extraBytes === 1) {
	    tmp = uint8[len - 1];
	    output += lookup[tmp >> 2];
	    output += lookup[(tmp << 4) & 0x3F];
	    output += '==';
	  } else if (extraBytes === 2) {
	    tmp = (uint8[len - 2] << 8) + (uint8[len - 1]);
	    output += lookup[tmp >> 10];
	    output += lookup[(tmp >> 4) & 0x3F];
	    output += lookup[(tmp << 2) & 0x3F];
	    output += '=';
	  }

	  parts.push(output);

	  return parts.join('')
	}

	function read (buffer, offset, isLE, mLen, nBytes) {
	  var e, m;
	  var eLen = nBytes * 8 - mLen - 1;
	  var eMax = (1 << eLen) - 1;
	  var eBias = eMax >> 1;
	  var nBits = -7;
	  var i = isLE ? (nBytes - 1) : 0;
	  var d = isLE ? -1 : 1;
	  var s = buffer[offset + i];

	  i += d;

	  e = s & ((1 << (-nBits)) - 1);
	  s >>= (-nBits);
	  nBits += eLen;
	  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

	  m = e & ((1 << (-nBits)) - 1);
	  e >>= (-nBits);
	  nBits += mLen;
	  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

	  if (e === 0) {
	    e = 1 - eBias;
	  } else if (e === eMax) {
	    return m ? NaN : ((s ? -1 : 1) * Infinity)
	  } else {
	    m = m + Math.pow(2, mLen);
	    e = e - eBias;
	  }
	  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
	}

	function write (buffer, value, offset, isLE, mLen, nBytes) {
	  var e, m, c;
	  var eLen = nBytes * 8 - mLen - 1;
	  var eMax = (1 << eLen) - 1;
	  var eBias = eMax >> 1;
	  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0);
	  var i = isLE ? 0 : (nBytes - 1);
	  var d = isLE ? 1 : -1;
	  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

	  value = Math.abs(value);

	  if (isNaN(value) || value === Infinity) {
	    m = isNaN(value) ? 1 : 0;
	    e = eMax;
	  } else {
	    e = Math.floor(Math.log(value) / Math.LN2);
	    if (value * (c = Math.pow(2, -e)) < 1) {
	      e--;
	      c *= 2;
	    }
	    if (e + eBias >= 1) {
	      value += rt / c;
	    } else {
	      value += rt * Math.pow(2, 1 - eBias);
	    }
	    if (value * c >= 2) {
	      e++;
	      c /= 2;
	    }

	    if (e + eBias >= eMax) {
	      m = 0;
	      e = eMax;
	    } else if (e + eBias >= 1) {
	      m = (value * c - 1) * Math.pow(2, mLen);
	      e = e + eBias;
	    } else {
	      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
	      e = 0;
	    }
	  }

	  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

	  e = (e << mLen) | m;
	  eLen += mLen;
	  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

	  buffer[offset + i - d] |= s * 128;
	}

	var toString = {}.toString;

	var isArray$1 = Array.isArray || function (arr) {
	  return toString.call(arr) == '[object Array]';
	};

	/*!
	 * The buffer module from node.js, for the browser.
	 *
	 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
	 * @license  MIT
	 */
	/* eslint-disable no-proto */


	var INSPECT_MAX_BYTES = 50;

	/**
	 * If `Buffer.TYPED_ARRAY_SUPPORT`:
	 *   === true    Use Uint8Array implementation (fastest)
	 *   === false   Use Object implementation (most compatible, even IE6)
	 *
	 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
	 * Opera 11.6+, iOS 4.2+.
	 *
	 * Due to various browser bugs, sometimes the Object implementation will be used even
	 * when the browser supports typed arrays.
	 *
	 * Note:
	 *
	 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
	 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
	 *
	 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
	 *
	 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
	 *     incorrect length in some situations.

	 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
	 * get the Object implementation, which is slower but behaves correctly.
	 */
	Buffer.TYPED_ARRAY_SUPPORT = global$1.TYPED_ARRAY_SUPPORT !== undefined
	  ? global$1.TYPED_ARRAY_SUPPORT
	  : true;

	/*
	 * Export kMaxLength after typed array support is determined.
	 */
	kMaxLength();

	function kMaxLength () {
	  return Buffer.TYPED_ARRAY_SUPPORT
	    ? 0x7fffffff
	    : 0x3fffffff
	}

	function createBuffer (that, length) {
	  if (kMaxLength() < length) {
	    throw new RangeError('Invalid typed array length')
	  }
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    // Return an augmented `Uint8Array` instance, for best performance
	    that = new Uint8Array(length);
	    that.__proto__ = Buffer.prototype;
	  } else {
	    // Fallback: Return an object instance of the Buffer class
	    if (that === null) {
	      that = new Buffer(length);
	    }
	    that.length = length;
	  }

	  return that
	}

	/**
	 * The Buffer constructor returns instances of `Uint8Array` that have their
	 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
	 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
	 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
	 * returns a single octet.
	 *
	 * The `Uint8Array` prototype remains unmodified.
	 */

	function Buffer (arg, encodingOrOffset, length) {
	  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
	    return new Buffer(arg, encodingOrOffset, length)
	  }

	  // Common case.
	  if (typeof arg === 'number') {
	    if (typeof encodingOrOffset === 'string') {
	      throw new Error(
	        'If encoding is specified then the first argument must be a string'
	      )
	    }
	    return allocUnsafe(this, arg)
	  }
	  return from(this, arg, encodingOrOffset, length)
	}

	Buffer.poolSize = 8192; // not used by this implementation

	// TODO: Legacy, not needed anymore. Remove in next major version.
	Buffer._augment = function (arr) {
	  arr.__proto__ = Buffer.prototype;
	  return arr
	};

	function from (that, value, encodingOrOffset, length) {
	  if (typeof value === 'number') {
	    throw new TypeError('"value" argument must not be a number')
	  }

	  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
	    return fromArrayBuffer(that, value, encodingOrOffset, length)
	  }

	  if (typeof value === 'string') {
	    return fromString(that, value, encodingOrOffset)
	  }

	  return fromObject(that, value)
	}

	/**
	 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
	 * if value is a number.
	 * Buffer.from(str[, encoding])
	 * Buffer.from(array)
	 * Buffer.from(buffer)
	 * Buffer.from(arrayBuffer[, byteOffset[, length]])
	 **/
	Buffer.from = function (value, encodingOrOffset, length) {
	  return from(null, value, encodingOrOffset, length)
	};

	if (Buffer.TYPED_ARRAY_SUPPORT) {
	  Buffer.prototype.__proto__ = Uint8Array.prototype;
	  Buffer.__proto__ = Uint8Array;
	  if (typeof Symbol !== 'undefined' && Symbol.species &&
	      Buffer[Symbol.species] === Buffer) ;
	}

	function assertSize (size) {
	  if (typeof size !== 'number') {
	    throw new TypeError('"size" argument must be a number')
	  } else if (size < 0) {
	    throw new RangeError('"size" argument must not be negative')
	  }
	}

	function alloc (that, size, fill, encoding) {
	  assertSize(size);
	  if (size <= 0) {
	    return createBuffer(that, size)
	  }
	  if (fill !== undefined) {
	    // Only pay attention to encoding if it's a string. This
	    // prevents accidentally sending in a number that would
	    // be interpretted as a start offset.
	    return typeof encoding === 'string'
	      ? createBuffer(that, size).fill(fill, encoding)
	      : createBuffer(that, size).fill(fill)
	  }
	  return createBuffer(that, size)
	}

	/**
	 * Creates a new filled Buffer instance.
	 * alloc(size[, fill[, encoding]])
	 **/
	Buffer.alloc = function (size, fill, encoding) {
	  return alloc(null, size, fill, encoding)
	};

	function allocUnsafe (that, size) {
	  assertSize(size);
	  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);
	  if (!Buffer.TYPED_ARRAY_SUPPORT) {
	    for (var i = 0; i < size; ++i) {
	      that[i] = 0;
	    }
	  }
	  return that
	}

	/**
	 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
	 * */
	Buffer.allocUnsafe = function (size) {
	  return allocUnsafe(null, size)
	};
	/**
	 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
	 */
	Buffer.allocUnsafeSlow = function (size) {
	  return allocUnsafe(null, size)
	};

	function fromString (that, string, encoding) {
	  if (typeof encoding !== 'string' || encoding === '') {
	    encoding = 'utf8';
	  }

	  if (!Buffer.isEncoding(encoding)) {
	    throw new TypeError('"encoding" must be a valid string encoding')
	  }

	  var length = byteLength(string, encoding) | 0;
	  that = createBuffer(that, length);

	  var actual = that.write(string, encoding);

	  if (actual !== length) {
	    // Writing a hex string, for example, that contains invalid characters will
	    // cause everything after the first invalid character to be ignored. (e.g.
	    // 'abxxcd' will be treated as 'ab')
	    that = that.slice(0, actual);
	  }

	  return that
	}

	function fromArrayLike (that, array) {
	  var length = array.length < 0 ? 0 : checked(array.length) | 0;
	  that = createBuffer(that, length);
	  for (var i = 0; i < length; i += 1) {
	    that[i] = array[i] & 255;
	  }
	  return that
	}

	function fromArrayBuffer (that, array, byteOffset, length) {
	  array.byteLength; // this throws if `array` is not a valid ArrayBuffer

	  if (byteOffset < 0 || array.byteLength < byteOffset) {
	    throw new RangeError('\'offset\' is out of bounds')
	  }

	  if (array.byteLength < byteOffset + (length || 0)) {
	    throw new RangeError('\'length\' is out of bounds')
	  }

	  if (byteOffset === undefined && length === undefined) {
	    array = new Uint8Array(array);
	  } else if (length === undefined) {
	    array = new Uint8Array(array, byteOffset);
	  } else {
	    array = new Uint8Array(array, byteOffset, length);
	  }

	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    // Return an augmented `Uint8Array` instance, for best performance
	    that = array;
	    that.__proto__ = Buffer.prototype;
	  } else {
	    // Fallback: Return an object instance of the Buffer class
	    that = fromArrayLike(that, array);
	  }
	  return that
	}

	function fromObject (that, obj) {
	  if (internalIsBuffer(obj)) {
	    var len = checked(obj.length) | 0;
	    that = createBuffer(that, len);

	    if (that.length === 0) {
	      return that
	    }

	    obj.copy(that, 0, 0, len);
	    return that
	  }

	  if (obj) {
	    if ((typeof ArrayBuffer !== 'undefined' &&
	        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
	      if (typeof obj.length !== 'number' || isnan(obj.length)) {
	        return createBuffer(that, 0)
	      }
	      return fromArrayLike(that, obj)
	    }

	    if (obj.type === 'Buffer' && isArray$1(obj.data)) {
	      return fromArrayLike(that, obj.data)
	    }
	  }

	  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
	}

	function checked (length) {
	  // Note: cannot use `length < kMaxLength()` here because that fails when
	  // length is NaN (which is otherwise coerced to zero.)
	  if (length >= kMaxLength()) {
	    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
	                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
	  }
	  return length | 0
	}
	Buffer.isBuffer = isBuffer$1;
	function internalIsBuffer (b) {
	  return !!(b != null && b._isBuffer)
	}

	Buffer.compare = function compare (a, b) {
	  if (!internalIsBuffer(a) || !internalIsBuffer(b)) {
	    throw new TypeError('Arguments must be Buffers')
	  }

	  if (a === b) return 0

	  var x = a.length;
	  var y = b.length;

	  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
	    if (a[i] !== b[i]) {
	      x = a[i];
	      y = b[i];
	      break
	    }
	  }

	  if (x < y) return -1
	  if (y < x) return 1
	  return 0
	};

	Buffer.isEncoding = function isEncoding (encoding) {
	  switch (String(encoding).toLowerCase()) {
	    case 'hex':
	    case 'utf8':
	    case 'utf-8':
	    case 'ascii':
	    case 'latin1':
	    case 'binary':
	    case 'base64':
	    case 'ucs2':
	    case 'ucs-2':
	    case 'utf16le':
	    case 'utf-16le':
	      return true
	    default:
	      return false
	  }
	};

	Buffer.concat = function concat (list, length) {
	  if (!isArray$1(list)) {
	    throw new TypeError('"list" argument must be an Array of Buffers')
	  }

	  if (list.length === 0) {
	    return Buffer.alloc(0)
	  }

	  var i;
	  if (length === undefined) {
	    length = 0;
	    for (i = 0; i < list.length; ++i) {
	      length += list[i].length;
	    }
	  }

	  var buffer = Buffer.allocUnsafe(length);
	  var pos = 0;
	  for (i = 0; i < list.length; ++i) {
	    var buf = list[i];
	    if (!internalIsBuffer(buf)) {
	      throw new TypeError('"list" argument must be an Array of Buffers')
	    }
	    buf.copy(buffer, pos);
	    pos += buf.length;
	  }
	  return buffer
	};

	function byteLength (string, encoding) {
	  if (internalIsBuffer(string)) {
	    return string.length
	  }
	  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
	      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
	    return string.byteLength
	  }
	  if (typeof string !== 'string') {
	    string = '' + string;
	  }

	  var len = string.length;
	  if (len === 0) return 0

	  // Use a for loop to avoid recursion
	  var loweredCase = false;
	  for (;;) {
	    switch (encoding) {
	      case 'ascii':
	      case 'latin1':
	      case 'binary':
	        return len
	      case 'utf8':
	      case 'utf-8':
	      case undefined:
	        return utf8ToBytes(string).length
	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return len * 2
	      case 'hex':
	        return len >>> 1
	      case 'base64':
	        return base64ToBytes(string).length
	      default:
	        if (loweredCase) return utf8ToBytes(string).length // assume utf8
	        encoding = ('' + encoding).toLowerCase();
	        loweredCase = true;
	    }
	  }
	}
	Buffer.byteLength = byteLength;

	function slowToString (encoding, start, end) {
	  var loweredCase = false;

	  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
	  // property of a typed array.

	  // This behaves neither like String nor Uint8Array in that we set start/end
	  // to their upper/lower bounds if the value passed is out of range.
	  // undefined is handled specially as per ECMA-262 6th Edition,
	  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
	  if (start === undefined || start < 0) {
	    start = 0;
	  }
	  // Return early if start > this.length. Done here to prevent potential uint32
	  // coercion fail below.
	  if (start > this.length) {
	    return ''
	  }

	  if (end === undefined || end > this.length) {
	    end = this.length;
	  }

	  if (end <= 0) {
	    return ''
	  }

	  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
	  end >>>= 0;
	  start >>>= 0;

	  if (end <= start) {
	    return ''
	  }

	  if (!encoding) encoding = 'utf8';

	  while (true) {
	    switch (encoding) {
	      case 'hex':
	        return hexSlice(this, start, end)

	      case 'utf8':
	      case 'utf-8':
	        return utf8Slice(this, start, end)

	      case 'ascii':
	        return asciiSlice(this, start, end)

	      case 'latin1':
	      case 'binary':
	        return latin1Slice(this, start, end)

	      case 'base64':
	        return base64Slice(this, start, end)

	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return utf16leSlice(this, start, end)

	      default:
	        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
	        encoding = (encoding + '').toLowerCase();
	        loweredCase = true;
	    }
	  }
	}

	// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
	// Buffer instances.
	Buffer.prototype._isBuffer = true;

	function swap (b, n, m) {
	  var i = b[n];
	  b[n] = b[m];
	  b[m] = i;
	}

	Buffer.prototype.swap16 = function swap16 () {
	  var len = this.length;
	  if (len % 2 !== 0) {
	    throw new RangeError('Buffer size must be a multiple of 16-bits')
	  }
	  for (var i = 0; i < len; i += 2) {
	    swap(this, i, i + 1);
	  }
	  return this
	};

	Buffer.prototype.swap32 = function swap32 () {
	  var len = this.length;
	  if (len % 4 !== 0) {
	    throw new RangeError('Buffer size must be a multiple of 32-bits')
	  }
	  for (var i = 0; i < len; i += 4) {
	    swap(this, i, i + 3);
	    swap(this, i + 1, i + 2);
	  }
	  return this
	};

	Buffer.prototype.swap64 = function swap64 () {
	  var len = this.length;
	  if (len % 8 !== 0) {
	    throw new RangeError('Buffer size must be a multiple of 64-bits')
	  }
	  for (var i = 0; i < len; i += 8) {
	    swap(this, i, i + 7);
	    swap(this, i + 1, i + 6);
	    swap(this, i + 2, i + 5);
	    swap(this, i + 3, i + 4);
	  }
	  return this
	};

	Buffer.prototype.toString = function toString () {
	  var length = this.length | 0;
	  if (length === 0) return ''
	  if (arguments.length === 0) return utf8Slice(this, 0, length)
	  return slowToString.apply(this, arguments)
	};

	Buffer.prototype.equals = function equals (b) {
	  if (!internalIsBuffer(b)) throw new TypeError('Argument must be a Buffer')
	  if (this === b) return true
	  return Buffer.compare(this, b) === 0
	};

	Buffer.prototype.inspect = function inspect () {
	  var str = '';
	  var max = INSPECT_MAX_BYTES;
	  if (this.length > 0) {
	    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');
	    if (this.length > max) str += ' ... ';
	  }
	  return '<Buffer ' + str + '>'
	};

	Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
	  if (!internalIsBuffer(target)) {
	    throw new TypeError('Argument must be a Buffer')
	  }

	  if (start === undefined) {
	    start = 0;
	  }
	  if (end === undefined) {
	    end = target ? target.length : 0;
	  }
	  if (thisStart === undefined) {
	    thisStart = 0;
	  }
	  if (thisEnd === undefined) {
	    thisEnd = this.length;
	  }

	  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
	    throw new RangeError('out of range index')
	  }

	  if (thisStart >= thisEnd && start >= end) {
	    return 0
	  }
	  if (thisStart >= thisEnd) {
	    return -1
	  }
	  if (start >= end) {
	    return 1
	  }

	  start >>>= 0;
	  end >>>= 0;
	  thisStart >>>= 0;
	  thisEnd >>>= 0;

	  if (this === target) return 0

	  var x = thisEnd - thisStart;
	  var y = end - start;
	  var len = Math.min(x, y);

	  var thisCopy = this.slice(thisStart, thisEnd);
	  var targetCopy = target.slice(start, end);

	  for (var i = 0; i < len; ++i) {
	    if (thisCopy[i] !== targetCopy[i]) {
	      x = thisCopy[i];
	      y = targetCopy[i];
	      break
	    }
	  }

	  if (x < y) return -1
	  if (y < x) return 1
	  return 0
	};

	// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
	// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
	//
	// Arguments:
	// - buffer - a Buffer to search
	// - val - a string, Buffer, or number
	// - byteOffset - an index into `buffer`; will be clamped to an int32
	// - encoding - an optional encoding, relevant is val is a string
	// - dir - true for indexOf, false for lastIndexOf
	function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
	  // Empty buffer means no match
	  if (buffer.length === 0) return -1

	  // Normalize byteOffset
	  if (typeof byteOffset === 'string') {
	    encoding = byteOffset;
	    byteOffset = 0;
	  } else if (byteOffset > 0x7fffffff) {
	    byteOffset = 0x7fffffff;
	  } else if (byteOffset < -0x80000000) {
	    byteOffset = -0x80000000;
	  }
	  byteOffset = +byteOffset;  // Coerce to Number.
	  if (isNaN(byteOffset)) {
	    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
	    byteOffset = dir ? 0 : (buffer.length - 1);
	  }

	  // Normalize byteOffset: negative offsets start from the end of the buffer
	  if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
	  if (byteOffset >= buffer.length) {
	    if (dir) return -1
	    else byteOffset = buffer.length - 1;
	  } else if (byteOffset < 0) {
	    if (dir) byteOffset = 0;
	    else return -1
	  }

	  // Normalize val
	  if (typeof val === 'string') {
	    val = Buffer.from(val, encoding);
	  }

	  // Finally, search either indexOf (if dir is true) or lastIndexOf
	  if (internalIsBuffer(val)) {
	    // Special case: looking for empty string/buffer always fails
	    if (val.length === 0) {
	      return -1
	    }
	    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
	  } else if (typeof val === 'number') {
	    val = val & 0xFF; // Search for a byte value [0-255]
	    if (Buffer.TYPED_ARRAY_SUPPORT &&
	        typeof Uint8Array.prototype.indexOf === 'function') {
	      if (dir) {
	        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
	      } else {
	        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
	      }
	    }
	    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
	  }

	  throw new TypeError('val must be string, number or Buffer')
	}

	function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
	  var indexSize = 1;
	  var arrLength = arr.length;
	  var valLength = val.length;

	  if (encoding !== undefined) {
	    encoding = String(encoding).toLowerCase();
	    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
	        encoding === 'utf16le' || encoding === 'utf-16le') {
	      if (arr.length < 2 || val.length < 2) {
	        return -1
	      }
	      indexSize = 2;
	      arrLength /= 2;
	      valLength /= 2;
	      byteOffset /= 2;
	    }
	  }

	  function read (buf, i) {
	    if (indexSize === 1) {
	      return buf[i]
	    } else {
	      return buf.readUInt16BE(i * indexSize)
	    }
	  }

	  var i;
	  if (dir) {
	    var foundIndex = -1;
	    for (i = byteOffset; i < arrLength; i++) {
	      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
	        if (foundIndex === -1) foundIndex = i;
	        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
	      } else {
	        if (foundIndex !== -1) i -= i - foundIndex;
	        foundIndex = -1;
	      }
	    }
	  } else {
	    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
	    for (i = byteOffset; i >= 0; i--) {
	      var found = true;
	      for (var j = 0; j < valLength; j++) {
	        if (read(arr, i + j) !== read(val, j)) {
	          found = false;
	          break
	        }
	      }
	      if (found) return i
	    }
	  }

	  return -1
	}

	Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
	  return this.indexOf(val, byteOffset, encoding) !== -1
	};

	Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
	  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
	};

	Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
	  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
	};

	function hexWrite (buf, string, offset, length) {
	  offset = Number(offset) || 0;
	  var remaining = buf.length - offset;
	  if (!length) {
	    length = remaining;
	  } else {
	    length = Number(length);
	    if (length > remaining) {
	      length = remaining;
	    }
	  }

	  // must be an even number of digits
	  var strLen = string.length;
	  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

	  if (length > strLen / 2) {
	    length = strLen / 2;
	  }
	  for (var i = 0; i < length; ++i) {
	    var parsed = parseInt(string.substr(i * 2, 2), 16);
	    if (isNaN(parsed)) return i
	    buf[offset + i] = parsed;
	  }
	  return i
	}

	function utf8Write (buf, string, offset, length) {
	  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
	}

	function asciiWrite (buf, string, offset, length) {
	  return blitBuffer(asciiToBytes(string), buf, offset, length)
	}

	function latin1Write (buf, string, offset, length) {
	  return asciiWrite(buf, string, offset, length)
	}

	function base64Write (buf, string, offset, length) {
	  return blitBuffer(base64ToBytes(string), buf, offset, length)
	}

	function ucs2Write (buf, string, offset, length) {
	  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
	}

	Buffer.prototype.write = function write (string, offset, length, encoding) {
	  // Buffer#write(string)
	  if (offset === undefined) {
	    encoding = 'utf8';
	    length = this.length;
	    offset = 0;
	  // Buffer#write(string, encoding)
	  } else if (length === undefined && typeof offset === 'string') {
	    encoding = offset;
	    length = this.length;
	    offset = 0;
	  // Buffer#write(string, offset[, length][, encoding])
	  } else if (isFinite(offset)) {
	    offset = offset | 0;
	    if (isFinite(length)) {
	      length = length | 0;
	      if (encoding === undefined) encoding = 'utf8';
	    } else {
	      encoding = length;
	      length = undefined;
	    }
	  // legacy write(string, encoding, offset, length) - remove in v0.13
	  } else {
	    throw new Error(
	      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
	    )
	  }

	  var remaining = this.length - offset;
	  if (length === undefined || length > remaining) length = remaining;

	  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
	    throw new RangeError('Attempt to write outside buffer bounds')
	  }

	  if (!encoding) encoding = 'utf8';

	  var loweredCase = false;
	  for (;;) {
	    switch (encoding) {
	      case 'hex':
	        return hexWrite(this, string, offset, length)

	      case 'utf8':
	      case 'utf-8':
	        return utf8Write(this, string, offset, length)

	      case 'ascii':
	        return asciiWrite(this, string, offset, length)

	      case 'latin1':
	      case 'binary':
	        return latin1Write(this, string, offset, length)

	      case 'base64':
	        // Warning: maxLength not taken into account in base64Write
	        return base64Write(this, string, offset, length)

	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return ucs2Write(this, string, offset, length)

	      default:
	        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
	        encoding = ('' + encoding).toLowerCase();
	        loweredCase = true;
	    }
	  }
	};

	Buffer.prototype.toJSON = function toJSON () {
	  return {
	    type: 'Buffer',
	    data: Array.prototype.slice.call(this._arr || this, 0)
	  }
	};

	function base64Slice (buf, start, end) {
	  if (start === 0 && end === buf.length) {
	    return fromByteArray(buf)
	  } else {
	    return fromByteArray(buf.slice(start, end))
	  }
	}

	function utf8Slice (buf, start, end) {
	  end = Math.min(buf.length, end);
	  var res = [];

	  var i = start;
	  while (i < end) {
	    var firstByte = buf[i];
	    var codePoint = null;
	    var bytesPerSequence = (firstByte > 0xEF) ? 4
	      : (firstByte > 0xDF) ? 3
	      : (firstByte > 0xBF) ? 2
	      : 1;

	    if (i + bytesPerSequence <= end) {
	      var secondByte, thirdByte, fourthByte, tempCodePoint;

	      switch (bytesPerSequence) {
	        case 1:
	          if (firstByte < 0x80) {
	            codePoint = firstByte;
	          }
	          break
	        case 2:
	          secondByte = buf[i + 1];
	          if ((secondByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F);
	            if (tempCodePoint > 0x7F) {
	              codePoint = tempCodePoint;
	            }
	          }
	          break
	        case 3:
	          secondByte = buf[i + 1];
	          thirdByte = buf[i + 2];
	          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F);
	            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
	              codePoint = tempCodePoint;
	            }
	          }
	          break
	        case 4:
	          secondByte = buf[i + 1];
	          thirdByte = buf[i + 2];
	          fourthByte = buf[i + 3];
	          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F);
	            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
	              codePoint = tempCodePoint;
	            }
	          }
	      }
	    }

	    if (codePoint === null) {
	      // we did not generate a valid codePoint so insert a
	      // replacement char (U+FFFD) and advance only 1 byte
	      codePoint = 0xFFFD;
	      bytesPerSequence = 1;
	    } else if (codePoint > 0xFFFF) {
	      // encode to utf16 (surrogate pair dance)
	      codePoint -= 0x10000;
	      res.push(codePoint >>> 10 & 0x3FF | 0xD800);
	      codePoint = 0xDC00 | codePoint & 0x3FF;
	    }

	    res.push(codePoint);
	    i += bytesPerSequence;
	  }

	  return decodeCodePointsArray(res)
	}

	// Based on http://stackoverflow.com/a/22747272/680742, the browser with
	// the lowest limit is Chrome, with 0x10000 args.
	// We go 1 magnitude less, for safety
	var MAX_ARGUMENTS_LENGTH = 0x1000;

	function decodeCodePointsArray (codePoints) {
	  var len = codePoints.length;
	  if (len <= MAX_ARGUMENTS_LENGTH) {
	    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
	  }

	  // Decode in chunks to avoid "call stack size exceeded".
	  var res = '';
	  var i = 0;
	  while (i < len) {
	    res += String.fromCharCode.apply(
	      String,
	      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
	    );
	  }
	  return res
	}

	function asciiSlice (buf, start, end) {
	  var ret = '';
	  end = Math.min(buf.length, end);

	  for (var i = start; i < end; ++i) {
	    ret += String.fromCharCode(buf[i] & 0x7F);
	  }
	  return ret
	}

	function latin1Slice (buf, start, end) {
	  var ret = '';
	  end = Math.min(buf.length, end);

	  for (var i = start; i < end; ++i) {
	    ret += String.fromCharCode(buf[i]);
	  }
	  return ret
	}

	function hexSlice (buf, start, end) {
	  var len = buf.length;

	  if (!start || start < 0) start = 0;
	  if (!end || end < 0 || end > len) end = len;

	  var out = '';
	  for (var i = start; i < end; ++i) {
	    out += toHex(buf[i]);
	  }
	  return out
	}

	function utf16leSlice (buf, start, end) {
	  var bytes = buf.slice(start, end);
	  var res = '';
	  for (var i = 0; i < bytes.length; i += 2) {
	    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
	  }
	  return res
	}

	Buffer.prototype.slice = function slice (start, end) {
	  var len = this.length;
	  start = ~~start;
	  end = end === undefined ? len : ~~end;

	  if (start < 0) {
	    start += len;
	    if (start < 0) start = 0;
	  } else if (start > len) {
	    start = len;
	  }

	  if (end < 0) {
	    end += len;
	    if (end < 0) end = 0;
	  } else if (end > len) {
	    end = len;
	  }

	  if (end < start) end = start;

	  var newBuf;
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    newBuf = this.subarray(start, end);
	    newBuf.__proto__ = Buffer.prototype;
	  } else {
	    var sliceLen = end - start;
	    newBuf = new Buffer(sliceLen, undefined);
	    for (var i = 0; i < sliceLen; ++i) {
	      newBuf[i] = this[i + start];
	    }
	  }

	  return newBuf
	};

	/*
	 * Need to make sure that buffer isn't trying to write out of bounds.
	 */
	function checkOffset (offset, ext, length) {
	  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
	  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
	}

	Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
	  offset = offset | 0;
	  byteLength = byteLength | 0;
	  if (!noAssert) checkOffset(offset, byteLength, this.length);

	  var val = this[offset];
	  var mul = 1;
	  var i = 0;
	  while (++i < byteLength && (mul *= 0x100)) {
	    val += this[offset + i] * mul;
	  }

	  return val
	};

	Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
	  offset = offset | 0;
	  byteLength = byteLength | 0;
	  if (!noAssert) {
	    checkOffset(offset, byteLength, this.length);
	  }

	  var val = this[offset + --byteLength];
	  var mul = 1;
	  while (byteLength > 0 && (mul *= 0x100)) {
	    val += this[offset + --byteLength] * mul;
	  }

	  return val
	};

	Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 1, this.length);
	  return this[offset]
	};

	Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length);
	  return this[offset] | (this[offset + 1] << 8)
	};

	Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length);
	  return (this[offset] << 8) | this[offset + 1]
	};

	Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length);

	  return ((this[offset]) |
	      (this[offset + 1] << 8) |
	      (this[offset + 2] << 16)) +
	      (this[offset + 3] * 0x1000000)
	};

	Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length);

	  return (this[offset] * 0x1000000) +
	    ((this[offset + 1] << 16) |
	    (this[offset + 2] << 8) |
	    this[offset + 3])
	};

	Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
	  offset = offset | 0;
	  byteLength = byteLength | 0;
	  if (!noAssert) checkOffset(offset, byteLength, this.length);

	  var val = this[offset];
	  var mul = 1;
	  var i = 0;
	  while (++i < byteLength && (mul *= 0x100)) {
	    val += this[offset + i] * mul;
	  }
	  mul *= 0x80;

	  if (val >= mul) val -= Math.pow(2, 8 * byteLength);

	  return val
	};

	Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
	  offset = offset | 0;
	  byteLength = byteLength | 0;
	  if (!noAssert) checkOffset(offset, byteLength, this.length);

	  var i = byteLength;
	  var mul = 1;
	  var val = this[offset + --i];
	  while (i > 0 && (mul *= 0x100)) {
	    val += this[offset + --i] * mul;
	  }
	  mul *= 0x80;

	  if (val >= mul) val -= Math.pow(2, 8 * byteLength);

	  return val
	};

	Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 1, this.length);
	  if (!(this[offset] & 0x80)) return (this[offset])
	  return ((0xff - this[offset] + 1) * -1)
	};

	Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length);
	  var val = this[offset] | (this[offset + 1] << 8);
	  return (val & 0x8000) ? val | 0xFFFF0000 : val
	};

	Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length);
	  var val = this[offset + 1] | (this[offset] << 8);
	  return (val & 0x8000) ? val | 0xFFFF0000 : val
	};

	Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length);

	  return (this[offset]) |
	    (this[offset + 1] << 8) |
	    (this[offset + 2] << 16) |
	    (this[offset + 3] << 24)
	};

	Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length);

	  return (this[offset] << 24) |
	    (this[offset + 1] << 16) |
	    (this[offset + 2] << 8) |
	    (this[offset + 3])
	};

	Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length);
	  return read(this, offset, true, 23, 4)
	};

	Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length);
	  return read(this, offset, false, 23, 4)
	};

	Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 8, this.length);
	  return read(this, offset, true, 52, 8)
	};

	Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 8, this.length);
	  return read(this, offset, false, 52, 8)
	};

	function checkInt (buf, value, offset, ext, max, min) {
	  if (!internalIsBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
	  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
	  if (offset + ext > buf.length) throw new RangeError('Index out of range')
	}

	Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  byteLength = byteLength | 0;
	  if (!noAssert) {
	    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
	    checkInt(this, value, offset, byteLength, maxBytes, 0);
	  }

	  var mul = 1;
	  var i = 0;
	  this[offset] = value & 0xFF;
	  while (++i < byteLength && (mul *= 0x100)) {
	    this[offset + i] = (value / mul) & 0xFF;
	  }

	  return offset + byteLength
	};

	Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  byteLength = byteLength | 0;
	  if (!noAssert) {
	    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
	    checkInt(this, value, offset, byteLength, maxBytes, 0);
	  }

	  var i = byteLength - 1;
	  var mul = 1;
	  this[offset + i] = value & 0xFF;
	  while (--i >= 0 && (mul *= 0x100)) {
	    this[offset + i] = (value / mul) & 0xFF;
	  }

	  return offset + byteLength
	};

	Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
	  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
	  this[offset] = (value & 0xff);
	  return offset + 1
	};

	function objectWriteUInt16 (buf, value, offset, littleEndian) {
	  if (value < 0) value = 0xffff + value + 1;
	  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
	    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
	      (littleEndian ? i : 1 - i) * 8;
	  }
	}

	Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value & 0xff);
	    this[offset + 1] = (value >>> 8);
	  } else {
	    objectWriteUInt16(this, value, offset, true);
	  }
	  return offset + 2
	};

	Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 8);
	    this[offset + 1] = (value & 0xff);
	  } else {
	    objectWriteUInt16(this, value, offset, false);
	  }
	  return offset + 2
	};

	function objectWriteUInt32 (buf, value, offset, littleEndian) {
	  if (value < 0) value = 0xffffffff + value + 1;
	  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
	    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff;
	  }
	}

	Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset + 3] = (value >>> 24);
	    this[offset + 2] = (value >>> 16);
	    this[offset + 1] = (value >>> 8);
	    this[offset] = (value & 0xff);
	  } else {
	    objectWriteUInt32(this, value, offset, true);
	  }
	  return offset + 4
	};

	Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 24);
	    this[offset + 1] = (value >>> 16);
	    this[offset + 2] = (value >>> 8);
	    this[offset + 3] = (value & 0xff);
	  } else {
	    objectWriteUInt32(this, value, offset, false);
	  }
	  return offset + 4
	};

	Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  if (!noAssert) {
	    var limit = Math.pow(2, 8 * byteLength - 1);

	    checkInt(this, value, offset, byteLength, limit - 1, -limit);
	  }

	  var i = 0;
	  var mul = 1;
	  var sub = 0;
	  this[offset] = value & 0xFF;
	  while (++i < byteLength && (mul *= 0x100)) {
	    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
	      sub = 1;
	    }
	    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
	  }

	  return offset + byteLength
	};

	Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  if (!noAssert) {
	    var limit = Math.pow(2, 8 * byteLength - 1);

	    checkInt(this, value, offset, byteLength, limit - 1, -limit);
	  }

	  var i = byteLength - 1;
	  var mul = 1;
	  var sub = 0;
	  this[offset + i] = value & 0xFF;
	  while (--i >= 0 && (mul *= 0x100)) {
	    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
	      sub = 1;
	    }
	    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
	  }

	  return offset + byteLength
	};

	Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);
	  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
	  if (value < 0) value = 0xff + value + 1;
	  this[offset] = (value & 0xff);
	  return offset + 1
	};

	Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value & 0xff);
	    this[offset + 1] = (value >>> 8);
	  } else {
	    objectWriteUInt16(this, value, offset, true);
	  }
	  return offset + 2
	};

	Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 8);
	    this[offset + 1] = (value & 0xff);
	  } else {
	    objectWriteUInt16(this, value, offset, false);
	  }
	  return offset + 2
	};

	Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value & 0xff);
	    this[offset + 1] = (value >>> 8);
	    this[offset + 2] = (value >>> 16);
	    this[offset + 3] = (value >>> 24);
	  } else {
	    objectWriteUInt32(this, value, offset, true);
	  }
	  return offset + 4
	};

	Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
	  if (value < 0) value = 0xffffffff + value + 1;
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 24);
	    this[offset + 1] = (value >>> 16);
	    this[offset + 2] = (value >>> 8);
	    this[offset + 3] = (value & 0xff);
	  } else {
	    objectWriteUInt32(this, value, offset, false);
	  }
	  return offset + 4
	};

	function checkIEEE754 (buf, value, offset, ext, max, min) {
	  if (offset + ext > buf.length) throw new RangeError('Index out of range')
	  if (offset < 0) throw new RangeError('Index out of range')
	}

	function writeFloat (buf, value, offset, littleEndian, noAssert) {
	  if (!noAssert) {
	    checkIEEE754(buf, value, offset, 4);
	  }
	  write(buf, value, offset, littleEndian, 23, 4);
	  return offset + 4
	}

	Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
	  return writeFloat(this, value, offset, true, noAssert)
	};

	Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
	  return writeFloat(this, value, offset, false, noAssert)
	};

	function writeDouble (buf, value, offset, littleEndian, noAssert) {
	  if (!noAssert) {
	    checkIEEE754(buf, value, offset, 8);
	  }
	  write(buf, value, offset, littleEndian, 52, 8);
	  return offset + 8
	}

	Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
	  return writeDouble(this, value, offset, true, noAssert)
	};

	Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
	  return writeDouble(this, value, offset, false, noAssert)
	};

	// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
	Buffer.prototype.copy = function copy (target, targetStart, start, end) {
	  if (!start) start = 0;
	  if (!end && end !== 0) end = this.length;
	  if (targetStart >= target.length) targetStart = target.length;
	  if (!targetStart) targetStart = 0;
	  if (end > 0 && end < start) end = start;

	  // Copy 0 bytes; we're done
	  if (end === start) return 0
	  if (target.length === 0 || this.length === 0) return 0

	  // Fatal error conditions
	  if (targetStart < 0) {
	    throw new RangeError('targetStart out of bounds')
	  }
	  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
	  if (end < 0) throw new RangeError('sourceEnd out of bounds')

	  // Are we oob?
	  if (end > this.length) end = this.length;
	  if (target.length - targetStart < end - start) {
	    end = target.length - targetStart + start;
	  }

	  var len = end - start;
	  var i;

	  if (this === target && start < targetStart && targetStart < end) {
	    // descending copy from end
	    for (i = len - 1; i >= 0; --i) {
	      target[i + targetStart] = this[i + start];
	    }
	  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
	    // ascending copy from start
	    for (i = 0; i < len; ++i) {
	      target[i + targetStart] = this[i + start];
	    }
	  } else {
	    Uint8Array.prototype.set.call(
	      target,
	      this.subarray(start, start + len),
	      targetStart
	    );
	  }

	  return len
	};

	// Usage:
	//    buffer.fill(number[, offset[, end]])
	//    buffer.fill(buffer[, offset[, end]])
	//    buffer.fill(string[, offset[, end]][, encoding])
	Buffer.prototype.fill = function fill (val, start, end, encoding) {
	  // Handle string cases:
	  if (typeof val === 'string') {
	    if (typeof start === 'string') {
	      encoding = start;
	      start = 0;
	      end = this.length;
	    } else if (typeof end === 'string') {
	      encoding = end;
	      end = this.length;
	    }
	    if (val.length === 1) {
	      var code = val.charCodeAt(0);
	      if (code < 256) {
	        val = code;
	      }
	    }
	    if (encoding !== undefined && typeof encoding !== 'string') {
	      throw new TypeError('encoding must be a string')
	    }
	    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
	      throw new TypeError('Unknown encoding: ' + encoding)
	    }
	  } else if (typeof val === 'number') {
	    val = val & 255;
	  }

	  // Invalid ranges are not set to a default, so can range check early.
	  if (start < 0 || this.length < start || this.length < end) {
	    throw new RangeError('Out of range index')
	  }

	  if (end <= start) {
	    return this
	  }

	  start = start >>> 0;
	  end = end === undefined ? this.length : end >>> 0;

	  if (!val) val = 0;

	  var i;
	  if (typeof val === 'number') {
	    for (i = start; i < end; ++i) {
	      this[i] = val;
	    }
	  } else {
	    var bytes = internalIsBuffer(val)
	      ? val
	      : utf8ToBytes(new Buffer(val, encoding).toString());
	    var len = bytes.length;
	    for (i = 0; i < end - start; ++i) {
	      this[i + start] = bytes[i % len];
	    }
	  }

	  return this
	};

	// HELPER FUNCTIONS
	// ================

	var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;

	function base64clean (str) {
	  // Node strips out invalid characters like \n and \t from the string, base64-js does not
	  str = stringtrim(str).replace(INVALID_BASE64_RE, '');
	  // Node converts strings with length < 2 to ''
	  if (str.length < 2) return ''
	  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
	  while (str.length % 4 !== 0) {
	    str = str + '=';
	  }
	  return str
	}

	function stringtrim (str) {
	  if (str.trim) return str.trim()
	  return str.replace(/^\s+|\s+$/g, '')
	}

	function toHex (n) {
	  if (n < 16) return '0' + n.toString(16)
	  return n.toString(16)
	}

	function utf8ToBytes (string, units) {
	  units = units || Infinity;
	  var codePoint;
	  var length = string.length;
	  var leadSurrogate = null;
	  var bytes = [];

	  for (var i = 0; i < length; ++i) {
	    codePoint = string.charCodeAt(i);

	    // is surrogate component
	    if (codePoint > 0xD7FF && codePoint < 0xE000) {
	      // last char was a lead
	      if (!leadSurrogate) {
	        // no lead yet
	        if (codePoint > 0xDBFF) {
	          // unexpected trail
	          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
	          continue
	        } else if (i + 1 === length) {
	          // unpaired lead
	          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
	          continue
	        }

	        // valid lead
	        leadSurrogate = codePoint;

	        continue
	      }

	      // 2 leads in a row
	      if (codePoint < 0xDC00) {
	        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
	        leadSurrogate = codePoint;
	        continue
	      }

	      // valid surrogate pair
	      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
	    } else if (leadSurrogate) {
	      // valid bmp char, but last char was a lead
	      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
	    }

	    leadSurrogate = null;

	    // encode utf8
	    if (codePoint < 0x80) {
	      if ((units -= 1) < 0) break
	      bytes.push(codePoint);
	    } else if (codePoint < 0x800) {
	      if ((units -= 2) < 0) break
	      bytes.push(
	        codePoint >> 0x6 | 0xC0,
	        codePoint & 0x3F | 0x80
	      );
	    } else if (codePoint < 0x10000) {
	      if ((units -= 3) < 0) break
	      bytes.push(
	        codePoint >> 0xC | 0xE0,
	        codePoint >> 0x6 & 0x3F | 0x80,
	        codePoint & 0x3F | 0x80
	      );
	    } else if (codePoint < 0x110000) {
	      if ((units -= 4) < 0) break
	      bytes.push(
	        codePoint >> 0x12 | 0xF0,
	        codePoint >> 0xC & 0x3F | 0x80,
	        codePoint >> 0x6 & 0x3F | 0x80,
	        codePoint & 0x3F | 0x80
	      );
	    } else {
	      throw new Error('Invalid code point')
	    }
	  }

	  return bytes
	}

	function asciiToBytes (str) {
	  var byteArray = [];
	  for (var i = 0; i < str.length; ++i) {
	    // Node's code seems to be doing this and not & 0x7F..
	    byteArray.push(str.charCodeAt(i) & 0xFF);
	  }
	  return byteArray
	}

	function utf16leToBytes (str, units) {
	  var c, hi, lo;
	  var byteArray = [];
	  for (var i = 0; i < str.length; ++i) {
	    if ((units -= 2) < 0) break

	    c = str.charCodeAt(i);
	    hi = c >> 8;
	    lo = c % 256;
	    byteArray.push(lo);
	    byteArray.push(hi);
	  }

	  return byteArray
	}


	function base64ToBytes (str) {
	  return toByteArray(base64clean(str))
	}

	function blitBuffer (src, dst, offset, length) {
	  for (var i = 0; i < length; ++i) {
	    if ((i + offset >= dst.length) || (i >= src.length)) break
	    dst[i + offset] = src[i];
	  }
	  return i
	}

	function isnan (val) {
	  return val !== val // eslint-disable-line no-self-compare
	}


	// the following is from is-buffer, also by Feross Aboukhadijeh and with same lisence
	// The _isBuffer check is for Safari 5-7 support, because it's missing
	// Object.prototype.constructor. Remove this eventually
	function isBuffer$1(obj) {
	  return obj != null && (!!obj._isBuffer || isFastBuffer(obj) || isSlowBuffer(obj))
	}

	function isFastBuffer (obj) {
	  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
	}

	// For Node v0.10 support. Remove this eventually.
	function isSlowBuffer (obj) {
	  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isFastBuffer(obj.slice(0, 0))
	}

	var inherits;
	if (typeof Object.create === 'function'){
	  inherits = function inherits(ctor, superCtor) {
	    // implementation from standard node.js 'util' module
	    ctor.super_ = superCtor;
	    ctor.prototype = Object.create(superCtor.prototype, {
	      constructor: {
	        value: ctor,
	        enumerable: false,
	        writable: true,
	        configurable: true
	      }
	    });
	  };
	} else {
	  inherits = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor;
	    var TempCtor = function () {};
	    TempCtor.prototype = superCtor.prototype;
	    ctor.prototype = new TempCtor();
	    ctor.prototype.constructor = ctor;
	  };
	}
	var inherits$1 = inherits;

	var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors ||
	  function getOwnPropertyDescriptors(obj) {
	    var keys = Object.keys(obj);
	    var descriptors = {};
	    for (var i = 0; i < keys.length; i++) {
	      descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);
	    }
	    return descriptors;
	  };

	var formatRegExp = /%[sdj%]/g;
	function format$2(f) {
	  if (!isString(f)) {
	    var objects = [];
	    for (var i = 0; i < arguments.length; i++) {
	      objects.push(inspect$1(arguments[i]));
	    }
	    return objects.join(' ');
	  }

	  var i = 1;
	  var args = arguments;
	  var len = args.length;
	  var str = String(f).replace(formatRegExp, function(x) {
	    if (x === '%%') return '%';
	    if (i >= len) return x;
	    switch (x) {
	      case '%s': return String(args[i++]);
	      case '%d': return Number(args[i++]);
	      case '%j':
	        try {
	          return JSON.stringify(args[i++]);
	        } catch (_) {
	          return '[Circular]';
	        }
	      default:
	        return x;
	    }
	  });
	  for (var x = args[i]; i < len; x = args[++i]) {
	    if (isNull$1(x) || !isObject$1(x)) {
	      str += ' ' + x;
	    } else {
	      str += ' ' + inspect$1(x);
	    }
	  }
	  return str;
	}

	// Mark that a method should not be used.
	// Returns a modified function which warns once by default.
	// If --no-deprecation is set, then it is a no-op.
	function deprecate(fn, msg) {
	  // Allow for deprecating things in the process of starting up.
	  if (isUndefined(global$1.process)) {
	    return function() {
	      return deprecate(fn, msg).apply(this, arguments);
	    };
	  }

	  if (browser$1.noDeprecation === true) {
	    return fn;
	  }

	  var warned = false;
	  function deprecated() {
	    if (!warned) {
	      if (browser$1.throwDeprecation) {
	        throw new Error(msg);
	      } else if (browser$1.traceDeprecation) {
	        console.trace(msg);
	      } else {
	        console.error(msg);
	      }
	      warned = true;
	    }
	    return fn.apply(this, arguments);
	  }

	  return deprecated;
	}

	var debugs = {};
	var debugEnviron;
	function debuglog(set) {
	  if (isUndefined(debugEnviron))
	    debugEnviron = browser$1.env.NODE_DEBUG || '';
	  set = set.toUpperCase();
	  if (!debugs[set]) {
	    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
	      var pid = 0;
	      debugs[set] = function() {
	        var msg = format$2.apply(null, arguments);
	        console.error('%s %d: %s', set, pid, msg);
	      };
	    } else {
	      debugs[set] = function() {};
	    }
	  }
	  return debugs[set];
	}

	/**
	 * Echos the value of a value. Trys to print the value out
	 * in the best way possible given the different types.
	 *
	 * @param {Object} obj The object to print out.
	 * @param {Object} opts Optional options object that alters the output.
	 */
	/* legacy: obj, showHidden, depth, colors*/
	function inspect$1(obj, opts) {
	  // default options
	  var ctx = {
	    seen: [],
	    stylize: stylizeNoColor
	  };
	  // legacy...
	  if (arguments.length >= 3) ctx.depth = arguments[2];
	  if (arguments.length >= 4) ctx.colors = arguments[3];
	  if (isBoolean$1(opts)) {
	    // legacy...
	    ctx.showHidden = opts;
	  } else if (opts) {
	    // got an "options" object
	    _extend(ctx, opts);
	  }
	  // set default options
	  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
	  if (isUndefined(ctx.depth)) ctx.depth = 2;
	  if (isUndefined(ctx.colors)) ctx.colors = false;
	  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
	  if (ctx.colors) ctx.stylize = stylizeWithColor;
	  return formatValue(ctx, obj, ctx.depth);
	}

	// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
	inspect$1.colors = {
	  'bold' : [1, 22],
	  'italic' : [3, 23],
	  'underline' : [4, 24],
	  'inverse' : [7, 27],
	  'white' : [37, 39],
	  'grey' : [90, 39],
	  'black' : [30, 39],
	  'blue' : [34, 39],
	  'cyan' : [36, 39],
	  'green' : [32, 39],
	  'magenta' : [35, 39],
	  'red' : [31, 39],
	  'yellow' : [33, 39]
	};

	// Don't use 'blue' not visible on cmd.exe
	inspect$1.styles = {
	  'special': 'cyan',
	  'number': 'yellow',
	  'boolean': 'yellow',
	  'undefined': 'grey',
	  'null': 'bold',
	  'string': 'green',
	  'date': 'magenta',
	  // "name": intentionally not styling
	  'regexp': 'red'
	};


	function stylizeWithColor(str, styleType) {
	  var style = inspect$1.styles[styleType];

	  if (style) {
	    return '\u001b[' + inspect$1.colors[style][0] + 'm' + str +
	           '\u001b[' + inspect$1.colors[style][1] + 'm';
	  } else {
	    return str;
	  }
	}


	function stylizeNoColor(str, styleType) {
	  return str;
	}


	function arrayToHash(array) {
	  var hash = {};

	  array.forEach(function(val, idx) {
	    hash[val] = true;
	  });

	  return hash;
	}


	function formatValue(ctx, value, recurseTimes) {
	  // Provide a hook for user-specified inspect functions.
	  // Check that value is an object with an inspect function on it
	  if (ctx.customInspect &&
	      value &&
	      isFunction(value.inspect) &&
	      // Filter out the util module, it's inspect function is special
	      value.inspect !== inspect$1 &&
	      // Also filter out any prototype objects using the circular check.
	      !(value.constructor && value.constructor.prototype === value)) {
	    var ret = value.inspect(recurseTimes, ctx);
	    if (!isString(ret)) {
	      ret = formatValue(ctx, ret, recurseTimes);
	    }
	    return ret;
	  }

	  // Primitive types cannot have properties
	  var primitive = formatPrimitive(ctx, value);
	  if (primitive) {
	    return primitive;
	  }

	  // Look up the keys of the object.
	  var keys = Object.keys(value);
	  var visibleKeys = arrayToHash(keys);

	  if (ctx.showHidden) {
	    keys = Object.getOwnPropertyNames(value);
	  }

	  // IE doesn't make error fields non-enumerable
	  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
	  if (isError(value)
	      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
	    return formatError$1(value);
	  }

	  // Some type of object without properties can be shortcutted.
	  if (keys.length === 0) {
	    if (isFunction(value)) {
	      var name = value.name ? ': ' + value.name : '';
	      return ctx.stylize('[Function' + name + ']', 'special');
	    }
	    if (isRegExp(value)) {
	      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
	    }
	    if (isDate(value)) {
	      return ctx.stylize(Date.prototype.toString.call(value), 'date');
	    }
	    if (isError(value)) {
	      return formatError$1(value);
	    }
	  }

	  var base = '', array = false, braces = ['{', '}'];

	  // Make Array say that they are Array
	  if (isArray(value)) {
	    array = true;
	    braces = ['[', ']'];
	  }

	  // Make functions say that they are functions
	  if (isFunction(value)) {
	    var n = value.name ? ': ' + value.name : '';
	    base = ' [Function' + n + ']';
	  }

	  // Make RegExps say that they are RegExps
	  if (isRegExp(value)) {
	    base = ' ' + RegExp.prototype.toString.call(value);
	  }

	  // Make dates with properties first say the date
	  if (isDate(value)) {
	    base = ' ' + Date.prototype.toUTCString.call(value);
	  }

	  // Make error with message first say the error
	  if (isError(value)) {
	    base = ' ' + formatError$1(value);
	  }

	  if (keys.length === 0 && (!array || value.length == 0)) {
	    return braces[0] + base + braces[1];
	  }

	  if (recurseTimes < 0) {
	    if (isRegExp(value)) {
	      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
	    } else {
	      return ctx.stylize('[Object]', 'special');
	    }
	  }

	  ctx.seen.push(value);

	  var output;
	  if (array) {
	    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
	  } else {
	    output = keys.map(function(key) {
	      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
	    });
	  }

	  ctx.seen.pop();

	  return reduceToSingleString(output, base, braces);
	}


	function formatPrimitive(ctx, value) {
	  if (isUndefined(value))
	    return ctx.stylize('undefined', 'undefined');
	  if (isString(value)) {
	    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
	                                             .replace(/'/g, "\\'")
	                                             .replace(/\\"/g, '"') + '\'';
	    return ctx.stylize(simple, 'string');
	  }
	  if (isNumber(value))
	    return ctx.stylize('' + value, 'number');
	  if (isBoolean$1(value))
	    return ctx.stylize('' + value, 'boolean');
	  // For some reason typeof null is "object", so special case here.
	  if (isNull$1(value))
	    return ctx.stylize('null', 'null');
	}


	function formatError$1(value) {
	  return '[' + Error.prototype.toString.call(value) + ']';
	}


	function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
	  var output = [];
	  for (var i = 0, l = value.length; i < l; ++i) {
	    if (hasOwnProperty$1(value, String(i))) {
	      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
	          String(i), true));
	    } else {
	      output.push('');
	    }
	  }
	  keys.forEach(function(key) {
	    if (!key.match(/^\d+$/)) {
	      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
	          key, true));
	    }
	  });
	  return output;
	}


	function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
	  var name, str, desc;
	  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
	  if (desc.get) {
	    if (desc.set) {
	      str = ctx.stylize('[Getter/Setter]', 'special');
	    } else {
	      str = ctx.stylize('[Getter]', 'special');
	    }
	  } else {
	    if (desc.set) {
	      str = ctx.stylize('[Setter]', 'special');
	    }
	  }
	  if (!hasOwnProperty$1(visibleKeys, key)) {
	    name = '[' + key + ']';
	  }
	  if (!str) {
	    if (ctx.seen.indexOf(desc.value) < 0) {
	      if (isNull$1(recurseTimes)) {
	        str = formatValue(ctx, desc.value, null);
	      } else {
	        str = formatValue(ctx, desc.value, recurseTimes - 1);
	      }
	      if (str.indexOf('\n') > -1) {
	        if (array) {
	          str = str.split('\n').map(function(line) {
	            return '  ' + line;
	          }).join('\n').substr(2);
	        } else {
	          str = '\n' + str.split('\n').map(function(line) {
	            return '   ' + line;
	          }).join('\n');
	        }
	      }
	    } else {
	      str = ctx.stylize('[Circular]', 'special');
	    }
	  }
	  if (isUndefined(name)) {
	    if (array && key.match(/^\d+$/)) {
	      return str;
	    }
	    name = JSON.stringify('' + key);
	    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
	      name = name.substr(1, name.length - 2);
	      name = ctx.stylize(name, 'name');
	    } else {
	      name = name.replace(/'/g, "\\'")
	                 .replace(/\\"/g, '"')
	                 .replace(/(^"|"$)/g, "'");
	      name = ctx.stylize(name, 'string');
	    }
	  }

	  return name + ': ' + str;
	}


	function reduceToSingleString(output, base, braces) {
	  var length = output.reduce(function(prev, cur) {
	    if (cur.indexOf('\n') >= 0) ;
	    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
	  }, 0);

	  if (length > 60) {
	    return braces[0] +
	           (base === '' ? '' : base + '\n ') +
	           ' ' +
	           output.join(',\n  ') +
	           ' ' +
	           braces[1];
	  }

	  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
	}


	// NOTE: These type checking functions intentionally don't use `instanceof`
	// because it is fragile and can be easily faked with `Object.create()`.
	function isArray(ar) {
	  return Array.isArray(ar);
	}

	function isBoolean$1(arg) {
	  return typeof arg === 'boolean';
	}

	function isNull$1(arg) {
	  return arg === null;
	}

	function isNullOrUndefined(arg) {
	  return arg == null;
	}

	function isNumber(arg) {
	  return typeof arg === 'number';
	}

	function isString(arg) {
	  return typeof arg === 'string';
	}

	function isSymbol(arg) {
	  return typeof arg === 'symbol';
	}

	function isUndefined(arg) {
	  return arg === void 0;
	}

	function isRegExp(re) {
	  return isObject$1(re) && objectToString(re) === '[object RegExp]';
	}

	function isObject$1(arg) {
	  return typeof arg === 'object' && arg !== null;
	}

	function isDate(d) {
	  return isObject$1(d) && objectToString(d) === '[object Date]';
	}

	function isError(e) {
	  return isObject$1(e) &&
	      (objectToString(e) === '[object Error]' || e instanceof Error);
	}

	function isFunction(arg) {
	  return typeof arg === 'function';
	}

	function isPrimitive(arg) {
	  return arg === null ||
	         typeof arg === 'boolean' ||
	         typeof arg === 'number' ||
	         typeof arg === 'string' ||
	         typeof arg === 'symbol' ||  // ES6 symbol
	         typeof arg === 'undefined';
	}

	function isBuffer(maybeBuf) {
	  return Buffer.isBuffer(maybeBuf);
	}

	function objectToString(o) {
	  return Object.prototype.toString.call(o);
	}


	function pad(n) {
	  return n < 10 ? '0' + n.toString(10) : n.toString(10);
	}


	var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
	              'Oct', 'Nov', 'Dec'];

	// 26 Feb 16:19:34
	function timestamp$1() {
	  var d = new Date();
	  var time = [pad(d.getHours()),
	              pad(d.getMinutes()),
	              pad(d.getSeconds())].join(':');
	  return [d.getDate(), months[d.getMonth()], time].join(' ');
	}


	// log is just a thin wrapper to console.log that prepends a timestamp
	function log() {
	  console.log('%s - %s', timestamp$1(), format$2.apply(null, arguments));
	}

	function _extend(origin, add) {
	  // Don't do anything if add isn't an object
	  if (!add || !isObject$1(add)) return origin;

	  var keys = Object.keys(add);
	  var i = keys.length;
	  while (i--) {
	    origin[keys[i]] = add[keys[i]];
	  }
	  return origin;
	}
	function hasOwnProperty$1(obj, prop) {
	  return Object.prototype.hasOwnProperty.call(obj, prop);
	}

	var kCustomPromisifiedSymbol = typeof Symbol !== 'undefined' ? Symbol('util.promisify.custom') : undefined;

	function promisify(original) {
	  if (typeof original !== 'function')
	    throw new TypeError('The "original" argument must be of type Function');

	  if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {
	    var fn = original[kCustomPromisifiedSymbol];
	    if (typeof fn !== 'function') {
	      throw new TypeError('The "util.promisify.custom" argument must be of type Function');
	    }
	    Object.defineProperty(fn, kCustomPromisifiedSymbol, {
	      value: fn, enumerable: false, writable: false, configurable: true
	    });
	    return fn;
	  }

	  function fn() {
	    var promiseResolve, promiseReject;
	    var promise = new Promise(function (resolve, reject) {
	      promiseResolve = resolve;
	      promiseReject = reject;
	    });

	    var args = [];
	    for (var i = 0; i < arguments.length; i++) {
	      args.push(arguments[i]);
	    }
	    args.push(function (err, value) {
	      if (err) {
	        promiseReject(err);
	      } else {
	        promiseResolve(value);
	      }
	    });

	    try {
	      original.apply(this, args);
	    } catch (err) {
	      promiseReject(err);
	    }

	    return promise;
	  }

	  Object.setPrototypeOf(fn, Object.getPrototypeOf(original));

	  if (kCustomPromisifiedSymbol) Object.defineProperty(fn, kCustomPromisifiedSymbol, {
	    value: fn, enumerable: false, writable: false, configurable: true
	  });
	  return Object.defineProperties(
	    fn,
	    getOwnPropertyDescriptors(original)
	  );
	}

	promisify.custom = kCustomPromisifiedSymbol;

	function callbackifyOnRejected(reason, cb) {
	  // `!reason` guard inspired by bluebird (Ref: https://goo.gl/t5IS6M).
	  // Because `null` is a special error value in callbacks which means "no error
	  // occurred", we error-wrap so the callback consumer can distinguish between
	  // "the promise rejected with null" or "the promise fulfilled with undefined".
	  if (!reason) {
	    var newReason = new Error('Promise was rejected with a falsy value');
	    newReason.reason = reason;
	    reason = newReason;
	  }
	  return cb(reason);
	}

	function callbackify(original) {
	  if (typeof original !== 'function') {
	    throw new TypeError('The "original" argument must be of type Function');
	  }

	  // We DO NOT return the promise as it gives the user a false sense that
	  // the promise is actually somehow related to the callback's execution
	  // and that the callback throwing will reject the promise.
	  function callbackified() {
	    var args = [];
	    for (var i = 0; i < arguments.length; i++) {
	      args.push(arguments[i]);
	    }

	    var maybeCb = args.pop();
	    if (typeof maybeCb !== 'function') {
	      throw new TypeError('The last argument must be of type Function');
	    }
	    var self = this;
	    var cb = function() {
	      return maybeCb.apply(self, arguments);
	    };
	    // In true node style we process the callback on `nextTick` with all the
	    // implications (stack, `uncaughtException`, `async_hooks`)
	    original.apply(this, args)
	      .then(function(ret) { browser$1.nextTick(cb.bind(null, null, ret)); },
	        function(rej) { browser$1.nextTick(callbackifyOnRejected.bind(null, rej, cb)); });
	  }

	  Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));
	  Object.defineProperties(callbackified, getOwnPropertyDescriptors(original));
	  return callbackified;
	}

	var _polyfillNode_util = {
	  inherits: inherits$1,
	  _extend: _extend,
	  log: log,
	  isBuffer: isBuffer,
	  isPrimitive: isPrimitive,
	  isFunction: isFunction,
	  isError: isError,
	  isDate: isDate,
	  isObject: isObject$1,
	  isRegExp: isRegExp,
	  isUndefined: isUndefined,
	  isSymbol: isSymbol,
	  isString: isString,
	  isNumber: isNumber,
	  isNullOrUndefined: isNullOrUndefined,
	  isNull: isNull$1,
	  isBoolean: isBoolean$1,
	  isArray: isArray,
	  inspect: inspect$1,
	  deprecate: deprecate,
	  format: format$2,
	  debuglog: debuglog,
	  promisify: promisify,
	  callbackify: callbackify,
	};

	var _polyfillNode_util$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		_extend: _extend,
		callbackify: callbackify,
		debuglog: debuglog,
		default: _polyfillNode_util,
		deprecate: deprecate,
		format: format$2,
		inherits: inherits$1,
		inspect: inspect$1,
		isArray: isArray,
		isBoolean: isBoolean$1,
		isBuffer: isBuffer,
		isDate: isDate,
		isError: isError,
		isFunction: isFunction,
		isNull: isNull$1,
		isNullOrUndefined: isNullOrUndefined,
		isNumber: isNumber,
		isObject: isObject$1,
		isPrimitive: isPrimitive,
		isRegExp: isRegExp,
		isString: isString,
		isSymbol: isSymbol,
		isUndefined: isUndefined,
		log: log,
		promisify: promisify
	});

	var require$$11 = /*@__PURE__*/getAugmentedNamespace(_polyfillNode_util$1);

	var __spreadArray = (commonjsGlobal && commonjsGlobal.__spreadArray) || function (to, from, pack) {
	    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
	        if (ar || !(i in from)) {
	            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
	            ar[i] = from[i];
	        }
	    }
	    return to.concat(ar || Array.prototype.slice.call(from));
	};
	Object.defineProperty(normalizer, "__esModule", { value: true });
	normalizer.normalize = void 0;
	var JSONSchema_1$3 = JSONSchema;
	var utils_1$3 = utils;
	var util_1$1 = require$$11;
	var rules$1 = new Map();
	function hasType(schema, type) {
	    return schema.type === type || (Array.isArray(schema.type) && schema.type.includes(type));
	}
	function isObjectType(schema) {
	    return schema.properties !== undefined || hasType(schema, 'object') || hasType(schema, 'any');
	}
	function isArrayType(schema) {
	    return schema.items !== undefined || hasType(schema, 'array') || hasType(schema, 'any');
	}
	rules$1.set('Remove `type=["null"]` if `enum=[null]`', function (schema) {
	    if (Array.isArray(schema.enum) &&
	        schema.enum.some(function (e) { return e === null; }) &&
	        Array.isArray(schema.type) &&
	        schema.type.includes('null')) {
	        schema.type = schema.type.filter(function (type) { return type !== 'null'; });
	    }
	});
	rules$1.set('Destructure unary types', function (schema) {
	    if (schema.type && Array.isArray(schema.type) && schema.type.length === 1) {
	        schema.type = schema.type[0];
	    }
	});
	rules$1.set('Add empty `required` property if none is defined', function (schema) {
	    if (isObjectType(schema) && !('required' in schema)) {
	        schema.required = [];
	    }
	});
	rules$1.set('Transform `required`=false to `required`=[]', function (schema) {
	    if (schema.required === false) {
	        schema.required = [];
	    }
	});
	rules$1.set('Default additionalProperties', function (schema, _, options) {
	    if (isObjectType(schema) && !('additionalProperties' in schema) && schema.patternProperties === undefined) {
	        schema.additionalProperties = options.additionalProperties;
	    }
	});
	rules$1.set('Transform id to $id', function (schema, fileName) {
	    if (!(0, utils_1$3.isSchemaLike)(schema)) {
	        return;
	    }
	    if (schema.id && schema.$id && schema.id !== schema.$id) {
	        throw ReferenceError("Schema must define either id or $id, not both. Given id=".concat(schema.id, ", $id=").concat(schema.$id, " in ").concat(fileName));
	    }
	    if (schema.id) {
	        schema.$id = schema.id;
	        delete schema.id;
	    }
	});
	rules$1.set('Add an $id to anything that needs it', function (schema, fileName, _options, _key, dereferencedPaths) {
	    if (!(0, utils_1$3.isSchemaLike)(schema)) {
	        return;
	    }
	    // Top-level schema
	    if (!schema.$id && !schema[JSONSchema_1$3.Parent]) {
	        schema.$id = (0, utils_1$3.toSafeString)((0, utils_1$3.justName)(fileName));
	        return;
	    }
	    // Sub-schemas with references
	    if (!isArrayType(schema) && !isObjectType(schema)) {
	        return;
	    }
	    // We'll infer from $id and title downstream
	    // TODO: Normalize upstream
	    var dereferencedName = dereferencedPaths.get(schema);
	    if (!schema.$id && !schema.title && dereferencedName) {
	        schema.$id = (0, utils_1$3.toSafeString)((0, utils_1$3.justName)(dereferencedName));
	    }
	    if (dereferencedName) {
	        dereferencedPaths.delete(schema);
	    }
	});
	rules$1.set('Escape closing JSDoc comment', function (schema) {
	    (0, utils_1$3.escapeBlockComment)(schema);
	});
	rules$1.set('Add JSDoc comments for minItems and maxItems', function (schema) {
	    if (!isArrayType(schema)) {
	        return;
	    }
	    var commentsToAppend = [
	        'minItems' in schema ? "@minItems ".concat(schema.minItems) : '',
	        'maxItems' in schema ? "@maxItems ".concat(schema.maxItems) : '',
	    ].filter(Boolean);
	    if (commentsToAppend.length) {
	        schema.description = utils_1$3.appendToDescription.apply(void 0, __spreadArray([schema.description], commentsToAppend, false));
	    }
	});
	rules$1.set('Optionally remove maxItems and minItems', function (schema, _fileName, options) {
	    if (!isArrayType(schema)) {
	        return;
	    }
	    if ('minItems' in schema && options.ignoreMinAndMaxItems) {
	        delete schema.minItems;
	    }
	    if ('maxItems' in schema && (options.ignoreMinAndMaxItems || options.maxItems === -1)) {
	        delete schema.maxItems;
	    }
	});
	rules$1.set('Normalize schema.minItems', function (schema, _fileName, options) {
	    if (options.ignoreMinAndMaxItems) {
	        return;
	    }
	    // make sure we only add the props onto array types
	    if (!isArrayType(schema)) {
	        return;
	    }
	    var minItems = schema.minItems;
	    schema.minItems = typeof minItems === 'number' ? minItems : 0;
	    // cannot normalize maxItems because maxItems = 0 has an actual meaning
	});
	rules$1.set('Remove maxItems if it is big enough to likely cause OOMs', function (schema, _fileName, options) {
	    if (options.ignoreMinAndMaxItems || options.maxItems === -1) {
	        return;
	    }
	    if (!isArrayType(schema)) {
	        return;
	    }
	    var maxItems = schema.maxItems, minItems = schema.minItems;
	    // minItems is guaranteed to be a number after the previous rule runs
	    if (maxItems !== undefined && maxItems - minItems > options.maxItems) {
	        delete schema.maxItems;
	    }
	});
	rules$1.set('Normalize schema.items', function (schema, _fileName, options) {
	    if (options.ignoreMinAndMaxItems) {
	        return;
	    }
	    var maxItems = schema.maxItems, minItems = schema.minItems;
	    var hasMaxItems = typeof maxItems === 'number' && maxItems >= 0;
	    var hasMinItems = typeof minItems === 'number' && minItems > 0;
	    if (schema.items && !Array.isArray(schema.items) && (hasMaxItems || hasMinItems)) {
	        var items = schema.items;
	        // create a tuple of length N
	        var newItems = Array(maxItems || minItems || 0).fill(items);
	        if (!hasMaxItems) {
	            // if there is no maximum, then add a spread item to collect the rest
	            schema.additionalItems = items;
	        }
	        schema.items = newItems;
	    }
	    if (Array.isArray(schema.items) && hasMaxItems && maxItems < schema.items.length) {
	        // it's perfectly valid to provide 5 item defs but require maxItems 1
	        // obviously we shouldn't emit a type for items that aren't expected
	        schema.items = schema.items.slice(0, maxItems);
	    }
	    return schema;
	});
	rules$1.set('Remove extends, if it is empty', function (schema) {
	    if (!schema.hasOwnProperty('extends')) {
	        return;
	    }
	    if (schema.extends == null || (Array.isArray(schema.extends) && schema.extends.length === 0)) {
	        delete schema.extends;
	    }
	});
	rules$1.set('Make extends always an array, if it is defined', function (schema) {
	    if (schema.extends == null) {
	        return;
	    }
	    if (!Array.isArray(schema.extends)) {
	        schema.extends = [schema.extends];
	    }
	});
	rules$1.set('Transform definitions to $defs', function (schema, fileName) {
	    if (schema.definitions && schema.$defs && !(0, util_1$1.isDeepStrictEqual)(schema.definitions, schema.$defs)) {
	        throw ReferenceError("Schema must define either definitions or $defs, not both. Given id=".concat(schema.id, " in ").concat(fileName));
	    }
	    if (schema.definitions) {
	        schema.$defs = schema.definitions;
	        delete schema.definitions;
	    }
	});
	rules$1.set('Transform const to singleton enum', function (schema) {
	    if (schema.const !== undefined) {
	        schema.enum = [schema.const];
	        delete schema.const;
	    }
	});
	function normalize(rootSchema, dereferencedPaths, filename, options) {
	    rules$1.forEach(function (rule) { return (0, utils_1$3.traverse)(rootSchema, function (schema, key) { return rule(schema, filename, options, key, dereferencedPaths); }); });
	    return rootSchema;
	}
	normalizer.normalize = normalize;

	var optimizer = {};

	var hasRequiredOptimizer;

	function requireOptimizer () {
		if (hasRequiredOptimizer) return optimizer;
		hasRequiredOptimizer = 1;
		var __assign = (commonjsGlobal && commonjsGlobal.__assign) || function () {
		    __assign = Object.assign || function(t) {
		        for (var s, i = 1, n = arguments.length; i < n; i++) {
		            s = arguments[i];
		            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
		                t[p] = s[p];
		        }
		        return t;
		    };
		    return __assign.apply(this, arguments);
		};
		Object.defineProperty(optimizer, "__esModule", { value: true });
		optimizer.optimize = void 0;
		var lodash_1 = lodashExports;
		var generator_1 = requireGenerator();
		var AST_1 = AST;
		var utils_1 = utils;
		function optimize(ast, options, processed) {
		    if (processed === void 0) { processed = new Set(); }
		    if (processed.has(ast)) {
		        return ast;
		    }
		    processed.add(ast);
		    switch (ast.type) {
		        case 'INTERFACE':
		            return Object.assign(ast, {
		                params: ast.params.map(function (_) { return Object.assign(_, { ast: optimize(_.ast, options, processed) }); }),
		            });
		        case 'INTERSECTION':
		        case 'UNION':
		            // Start with the leaves...
		            var optimizedAST_1 = Object.assign(ast, {
		                params: ast.params.map(function (_) { return optimize(_, options, processed); }),
		            });
		            // [A, B, C, Any] -> Any
		            if (optimizedAST_1.params.some(function (_) { return _.type === 'ANY'; })) {
		                (0, utils_1.log)('cyan', 'optimizer', '[A, B, C, Any] -> Any', optimizedAST_1);
		                return AST_1.T_ANY;
		            }
		            // [A, B, C, Unknown] -> Unknown
		            if (optimizedAST_1.params.some(function (_) { return _.type === 'UNKNOWN'; })) {
		                (0, utils_1.log)('cyan', 'optimizer', '[A, B, C, Unknown] -> Unknown', optimizedAST_1);
		                return AST_1.T_UNKNOWN;
		            }
		            // [A (named), A] -> [A (named)]
		            if (optimizedAST_1.params.every(function (_) {
		                var a = (0, generator_1.generateType)(omitStandaloneName(_), options);
		                var b = (0, generator_1.generateType)(omitStandaloneName(optimizedAST_1.params[0]), options);
		                return a === b;
		            }) &&
		                optimizedAST_1.params.some(function (_) { return _.standaloneName !== undefined; })) {
		                (0, utils_1.log)('cyan', 'optimizer', '[A (named), A] -> [A (named)]', optimizedAST_1);
		                optimizedAST_1.params = optimizedAST_1.params.filter(function (_) { return _.standaloneName !== undefined; });
		            }
		            // [A, B, B] -> [A, B]
		            var params = (0, lodash_1.uniqBy)(optimizedAST_1.params, function (_) { return (0, generator_1.generateType)(_, options); });
		            if (params.length !== optimizedAST_1.params.length) {
		                (0, utils_1.log)('cyan', 'optimizer', '[A, B, B] -> [A, B]', optimizedAST_1);
		                optimizedAST_1.params = params;
		            }
		            return Object.assign(optimizedAST_1, {
		                params: optimizedAST_1.params.map(function (_) { return optimize(_, options, processed); }),
		            });
		        default:
		            return ast;
		    }
		}
		optimizer.optimize = optimize;
		// TODO: More clearly disambiguate standalone names vs. aliased names instead.
		function omitStandaloneName(ast) {
		    switch (ast.type) {
		        case 'ENUM':
		            return ast;
		        default:
		            return __assign(__assign({}, ast), { standaloneName: undefined });
		    }
		}
		
		return optimizer;
	}

	var parser = {};

	var typesOfSchema$1 = {};

	Object.defineProperty(typesOfSchema$1, "__esModule", { value: true });
	typesOfSchema$1.typesOfSchema = void 0;
	var lodash_1$2 = lodashExports;
	var JSONSchema_1$2 = JSONSchema;
	/**
	 * Duck types a JSONSchema schema or property to determine which kind of AST node to parse it into.
	 *
	 * Due to what some might say is an oversight in the JSON-Schema spec, a given schema may
	 * implicitly be an *intersection* of multiple JSON-Schema directives (ie. multiple TypeScript
	 * types). The spec leaves it up to implementations to decide what to do with this
	 * loosely-defined behavior.
	 */
	function typesOfSchema(schema) {
	    // tsType is an escape hatch that supercedes all other directives
	    if (schema.tsType) {
	        return ['CUSTOM_TYPE'];
	    }
	    // Collect matched types
	    var matchedTypes = [];
	    for (var _i = 0, _a = Object.entries(matchers); _i < _a.length; _i++) {
	        var _b = _a[_i], schemaType = _b[0], f = _b[1];
	        if (f(schema)) {
	            matchedTypes.push(schemaType);
	        }
	    }
	    // Default to an unnamed schema
	    if (!matchedTypes.length) {
	        return ['UNNAMED_SCHEMA'];
	    }
	    return matchedTypes;
	}
	typesOfSchema$1.typesOfSchema = typesOfSchema;
	var matchers = {
	    ALL_OF: function (schema) {
	        return 'allOf' in schema;
	    },
	    ANY: function (schema) {
	        if (Object.keys(schema).length === 0) {
	            // The empty schema {} validates any value
	            // @see https://json-schema.org/draft-07/json-schema-core.html#rfc.section.4.3.1
	            return true;
	        }
	        return schema.type === 'any';
	    },
	    ANY_OF: function (schema) {
	        return 'anyOf' in schema;
	    },
	    BOOLEAN: function (schema) {
	        if ('enum' in schema) {
	            return false;
	        }
	        if (schema.type === 'boolean') {
	            return true;
	        }
	        if (!(0, JSONSchema_1$2.isCompound)(schema) && typeof schema.default === 'boolean') {
	            return true;
	        }
	        return false;
	    },
	    CUSTOM_TYPE: function () {
	        return false; // Explicitly handled before we try to match
	    },
	    NAMED_ENUM: function (schema) {
	        return 'enum' in schema && 'tsEnumNames' in schema;
	    },
	    NAMED_SCHEMA: function (schema) {
	        // 8.2.1. The presence of "$id" in a subschema indicates that the subschema constitutes a distinct schema resource within a single schema document.
	        return '$id' in schema && ('patternProperties' in schema || 'properties' in schema);
	    },
	    NEVER: function (schema) {
	        return schema === false;
	    },
	    NULL: function (schema) {
	        return schema.type === 'null';
	    },
	    NUMBER: function (schema) {
	        if ('enum' in schema) {
	            return false;
	        }
	        if (schema.type === 'integer' || schema.type === 'number') {
	            return true;
	        }
	        if (!(0, JSONSchema_1$2.isCompound)(schema) && typeof schema.default === 'number') {
	            return true;
	        }
	        return false;
	    },
	    OBJECT: function (schema) {
	        return (schema.type === 'object' &&
	            !(0, lodash_1$2.isPlainObject)(schema.additionalProperties) &&
	            !schema.allOf &&
	            !schema.anyOf &&
	            !schema.oneOf &&
	            !schema.patternProperties &&
	            !schema.properties &&
	            !schema.required);
	    },
	    ONE_OF: function (schema) {
	        return 'oneOf' in schema;
	    },
	    REFERENCE: function (schema) {
	        return '$ref' in schema;
	    },
	    STRING: function (schema) {
	        if ('enum' in schema) {
	            return false;
	        }
	        if (schema.type === 'string') {
	            return true;
	        }
	        if (!(0, JSONSchema_1$2.isCompound)(schema) && typeof schema.default === 'string') {
	            return true;
	        }
	        return false;
	    },
	    TYPED_ARRAY: function (schema) {
	        if (schema.type && schema.type !== 'array') {
	            return false;
	        }
	        return 'items' in schema;
	    },
	    UNION: function (schema) {
	        return Array.isArray(schema.type);
	    },
	    UNNAMED_ENUM: function (schema) {
	        if ('tsEnumNames' in schema) {
	            return false;
	        }
	        if (schema.type &&
	            schema.type !== 'boolean' &&
	            schema.type !== 'integer' &&
	            schema.type !== 'number' &&
	            schema.type !== 'string') {
	            return false;
	        }
	        return 'enum' in schema;
	    },
	    UNNAMED_SCHEMA: function () {
	        return false; // Explicitly handled as the default case
	    },
	    UNTYPED_ARRAY: function (schema) {
	        return schema.type === 'array' && !('items' in schema);
	    },
	};

	var __assign$1 = (commonjsGlobal && commonjsGlobal.__assign) || function () {
	    __assign$1 = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$1.apply(this, arguments);
	};
	Object.defineProperty(parser, "__esModule", { value: true });
	parser.parse = void 0;
	var lodash_1$1 = lodashExports;
	var util_1 = require$$11;
	var typesOfSchema_1 = typesOfSchema$1;
	var AST_1 = AST;
	var JSONSchema_1$1 = JSONSchema;
	var utils_1$2 = utils;
	function parse$1(schema, options, keyName, processed, usedNames) {
	    if (processed === void 0) { processed = new Map(); }
	    if (usedNames === void 0) { usedNames = new Set(); }
	    if ((0, JSONSchema_1$1.isPrimitive)(schema)) {
	        if ((0, JSONSchema_1$1.isBoolean)(schema)) {
	            return parseBooleanSchema(schema, keyName, options);
	        }
	        return parseLiteral(schema, keyName);
	    }
	    var types = (0, typesOfSchema_1.typesOfSchema)(schema);
	    if (types.length === 1) {
	        var ast_1 = parseAsTypeWithCache(schema, types[0], options, keyName, processed, usedNames);
	        (0, utils_1$2.log)('blue', 'parser', 'Types:', types, 'Input:', schema, 'Output:', ast_1);
	        return ast_1;
	    }
	    // Be careful to first process the intersection before processing its params,
	    // so that it gets first pick for standalone name.
	    var ast = parseAsTypeWithCache({
	        $id: schema.$id,
	        allOf: [],
	        description: schema.description,
	        title: schema.title,
	    }, 'ALL_OF', options, keyName, processed, usedNames);
	    ast.params = types.map(function (type) {
	        // We hoist description (for comment) and id/title (for standaloneName)
	        // to the parent intersection type, so we remove it from the children.
	        return parseAsTypeWithCache((0, utils_1$2.maybeStripNameHints)(schema), type, options, keyName, processed, usedNames);
	    });
	    (0, utils_1$2.log)('blue', 'parser', 'Types:', types, 'Input:', schema, 'Output:', ast);
	    return ast;
	}
	parser.parse = parse$1;
	function parseAsTypeWithCache(schema, type, options, keyName, processed, usedNames) {
	    if (processed === void 0) { processed = new Map(); }
	    if (usedNames === void 0) { usedNames = new Set(); }
	    // If we've seen this node before, return it.
	    var cachedTypeMap = processed.get(schema);
	    if (!cachedTypeMap) {
	        cachedTypeMap = new Map();
	        processed.set(schema, cachedTypeMap);
	    }
	    var cachedAST = cachedTypeMap.get(type);
	    if (cachedAST) {
	        return cachedAST;
	    }
	    // Cache processed ASTs before they are actually computed, then update
	    // them in place using set(). This is to avoid cycles.
	    // TODO: Investigate alternative approaches (lazy-computing nodes, etc.)
	    var ast = {};
	    cachedTypeMap.set(type, ast);
	    // Update the AST in place. This updates the `processed` cache, as well
	    // as any nodes that directly reference the node.
	    return Object.assign(ast, parseNonLiteral(schema, type, options, keyName, processed, usedNames));
	}
	function parseBooleanSchema(schema, keyName, options) {
	    if (schema) {
	        return {
	            keyName: keyName,
	            type: options.unknownAny ? 'UNKNOWN' : 'ANY',
	        };
	    }
	    return {
	        keyName: keyName,
	        type: 'NEVER',
	    };
	}
	function parseLiteral(schema, keyName) {
	    return {
	        keyName: keyName,
	        params: schema,
	        type: 'LITERAL',
	    };
	}
	function parseNonLiteral(schema, type, options, keyName, processed, usedNames) {
	    var definitions = getDefinitionsMemoized((0, JSONSchema_1$1.getRootSchema)(schema)); // TODO
	    var keyNameFromDefinition = (0, lodash_1$1.findKey)(definitions, function (_) { return _ === schema; });
	    switch (type) {
	        case 'ALL_OF':
	            return {
	                comment: schema.description,
	                deprecated: schema.deprecated,
	                keyName: keyName,
	                standaloneName: standaloneName(schema, keyNameFromDefinition, usedNames),
	                params: schema.allOf.map(function (_) { return parse$1(_, options, undefined, processed, usedNames); }),
	                type: 'INTERSECTION',
	            };
	        case 'ANY':
	            return __assign$1(__assign$1({}, (options.unknownAny ? AST_1.T_UNKNOWN : AST_1.T_ANY)), { comment: schema.description, deprecated: schema.deprecated, keyName: keyName, standaloneName: standaloneName(schema, keyNameFromDefinition, usedNames) });
	        case 'ANY_OF':
	            return {
	                comment: schema.description,
	                deprecated: schema.deprecated,
	                keyName: keyName,
	                standaloneName: standaloneName(schema, keyNameFromDefinition, usedNames),
	                params: schema.anyOf.map(function (_) { return parse$1(_, options, undefined, processed, usedNames); }),
	                type: 'UNION',
	            };
	        case 'BOOLEAN':
	            return {
	                comment: schema.description,
	                deprecated: schema.deprecated,
	                keyName: keyName,
	                standaloneName: standaloneName(schema, keyNameFromDefinition, usedNames),
	                type: 'BOOLEAN',
	            };
	        case 'CUSTOM_TYPE':
	            return {
	                comment: schema.description,
	                deprecated: schema.deprecated,
	                keyName: keyName,
	                params: schema.tsType,
	                standaloneName: standaloneName(schema, keyNameFromDefinition, usedNames),
	                type: 'CUSTOM_TYPE',
	            };
	        case 'NAMED_ENUM':
	            return {
	                comment: schema.description,
	                deprecated: schema.deprecated,
	                keyName: keyName,
	                standaloneName: standaloneName(schema, keyNameFromDefinition !== null && keyNameFromDefinition !== void 0 ? keyNameFromDefinition : keyName, usedNames),
	                params: schema.enum.map(function (_, n) { return ({
	                    ast: parseLiteral(_, undefined),
	                    keyName: schema.tsEnumNames[n],
	                }); }),
	                type: 'ENUM',
	            };
	        case 'NAMED_SCHEMA':
	            return newInterface(schema, options, processed, usedNames, keyName);
	        case 'NEVER':
	            return {
	                comment: schema.description,
	                deprecated: schema.deprecated,
	                keyName: keyName,
	                standaloneName: standaloneName(schema, keyNameFromDefinition, usedNames),
	                type: 'NEVER',
	            };
	        case 'NULL':
	            return {
	                comment: schema.description,
	                deprecated: schema.deprecated,
	                keyName: keyName,
	                standaloneName: standaloneName(schema, keyNameFromDefinition, usedNames),
	                type: 'NULL',
	            };
	        case 'NUMBER':
	            return {
	                comment: schema.description,
	                deprecated: schema.deprecated,
	                keyName: keyName,
	                standaloneName: standaloneName(schema, keyNameFromDefinition, usedNames),
	                type: 'NUMBER',
	            };
	        case 'OBJECT':
	            return {
	                comment: schema.description,
	                keyName: keyName,
	                standaloneName: standaloneName(schema, keyNameFromDefinition, usedNames),
	                type: 'OBJECT',
	                deprecated: schema.deprecated,
	            };
	        case 'ONE_OF':
	            return {
	                comment: schema.description,
	                deprecated: schema.deprecated,
	                keyName: keyName,
	                standaloneName: standaloneName(schema, keyNameFromDefinition, usedNames),
	                params: schema.oneOf.map(function (_) { return parse$1(_, options, undefined, processed, usedNames); }),
	                type: 'UNION',
	            };
	        case 'REFERENCE':
	            throw Error((0, util_1.format)('Refs should have been resolved by the resolver!', schema));
	        case 'STRING':
	            return {
	                comment: schema.description,
	                deprecated: schema.deprecated,
	                keyName: keyName,
	                standaloneName: standaloneName(schema, keyNameFromDefinition, usedNames),
	                type: 'STRING',
	            };
	        case 'TYPED_ARRAY':
	            if (Array.isArray(schema.items)) {
	                // normalised to not be undefined
	                var minItems_1 = schema.minItems;
	                var maxItems_1 = schema.maxItems;
	                var arrayType = {
	                    comment: schema.description,
	                    deprecated: schema.deprecated,
	                    keyName: keyName,
	                    maxItems: maxItems_1,
	                    minItems: minItems_1,
	                    standaloneName: standaloneName(schema, keyNameFromDefinition, usedNames),
	                    params: schema.items.map(function (_) { return parse$1(_, options, undefined, processed, usedNames); }),
	                    type: 'TUPLE',
	                };
	                if (schema.additionalItems === true) {
	                    arrayType.spreadParam = options.unknownAny ? AST_1.T_UNKNOWN : AST_1.T_ANY;
	                }
	                else if (schema.additionalItems) {
	                    arrayType.spreadParam = parse$1(schema.additionalItems, options, undefined, processed, usedNames);
	                }
	                return arrayType;
	            }
	            else {
	                return {
	                    comment: schema.description,
	                    deprecated: schema.deprecated,
	                    keyName: keyName,
	                    standaloneName: standaloneName(schema, keyNameFromDefinition, usedNames),
	                    params: parse$1(schema.items, options, "{keyNameFromDefinition}Items", processed, usedNames),
	                    type: 'ARRAY',
	                };
	            }
	        case 'UNION':
	            return {
	                comment: schema.description,
	                deprecated: schema.deprecated,
	                keyName: keyName,
	                standaloneName: standaloneName(schema, keyNameFromDefinition, usedNames),
	                params: schema.type.map(function (type) {
	                    var member = __assign$1(__assign$1({}, (0, lodash_1$1.omit)(schema, '$id', 'description', 'title')), { type: type });
	                    return parse$1((0, utils_1$2.maybeStripDefault)(member), options, undefined, processed, usedNames);
	                }),
	                type: 'UNION',
	            };
	        case 'UNNAMED_ENUM':
	            return {
	                comment: schema.description,
	                deprecated: schema.deprecated,
	                keyName: keyName,
	                standaloneName: standaloneName(schema, keyNameFromDefinition, usedNames),
	                params: schema.enum.map(function (_) { return parseLiteral(_, undefined); }),
	                type: 'UNION',
	            };
	        case 'UNNAMED_SCHEMA':
	            return newInterface(schema, options, processed, usedNames, keyName, keyNameFromDefinition);
	        case 'UNTYPED_ARRAY':
	            // normalised to not be undefined
	            var minItems = schema.minItems;
	            var maxItems = typeof schema.maxItems === 'number' ? schema.maxItems : -1;
	            var params = options.unknownAny ? AST_1.T_UNKNOWN : AST_1.T_ANY;
	            if (minItems > 0 || maxItems >= 0) {
	                return {
	                    comment: schema.description,
	                    deprecated: schema.deprecated,
	                    keyName: keyName,
	                    maxItems: schema.maxItems,
	                    minItems: minItems,
	                    // create a tuple of length N
	                    params: Array(Math.max(maxItems, minItems) || 0).fill(params),
	                    // if there is no maximum, then add a spread item to collect the rest
	                    spreadParam: maxItems >= 0 ? undefined : params,
	                    standaloneName: standaloneName(schema, keyNameFromDefinition, usedNames),
	                    type: 'TUPLE',
	                };
	            }
	            return {
	                comment: schema.description,
	                deprecated: schema.deprecated,
	                keyName: keyName,
	                params: params,
	                standaloneName: standaloneName(schema, keyNameFromDefinition, usedNames),
	                type: 'ARRAY',
	            };
	    }
	}
	/**
	 * Compute a schema name using a series of fallbacks
	 */
	function standaloneName(schema, keyNameFromDefinition, usedNames) {
	    var name = schema.title || schema.$id || keyNameFromDefinition;
	    if (name) {
	        return (0, utils_1$2.generateName)(name, usedNames);
	    }
	}
	function newInterface(schema, options, processed, usedNames, keyName, keyNameFromDefinition) {
	    var name = standaloneName(schema, keyNameFromDefinition, usedNames);
	    return {
	        comment: schema.description,
	        deprecated: schema.deprecated,
	        keyName: keyName,
	        params: parseSchema(schema, options, processed, usedNames, name),
	        standaloneName: name,
	        superTypes: parseSuperTypes(schema, options, processed, usedNames),
	        type: 'INTERFACE',
	    };
	}
	function parseSuperTypes(schema, options, processed, usedNames) {
	    // Type assertion needed because of dereferencing step
	    // TODO: Type it upstream
	    var superTypes = schema.extends;
	    if (!superTypes) {
	        return [];
	    }
	    return superTypes.map(function (_) { return parse$1(_, options, undefined, processed, usedNames); });
	}
	/**
	 * Helper to parse schema properties into params on the parent schema's type
	 */
	function parseSchema(schema, options, processed, usedNames, parentSchemaName) {
	    var asts = (0, lodash_1$1.map)(schema.properties, function (value, key) { return ({
	        ast: parse$1(value, options, key, processed, usedNames),
	        isPatternProperty: false,
	        isRequired: (0, lodash_1$1.includes)(schema.required || [], key),
	        isUnreachableDefinition: false,
	        keyName: key,
	    }); });
	    var singlePatternProperty = false;
	    if (schema.patternProperties) {
	        // partially support patternProperties. in the case that
	        // additionalProperties is not set, and there is only a single
	        // value definition, we can validate against that.
	        singlePatternProperty = !schema.additionalProperties && Object.keys(schema.patternProperties).length === 1;
	        asts = asts.concat((0, lodash_1$1.map)(schema.patternProperties, function (value, key) {
	            var ast = parse$1(value, options, key, processed, usedNames);
	            var comment = "This interface was referenced by `".concat(parentSchemaName, "`'s JSON-Schema definition\nvia the `patternProperty` \"").concat(key.replace('*/', '*\\/'), "\".");
	            ast.comment = ast.comment ? "".concat(ast.comment, "\n\n").concat(comment) : comment;
	            return {
	                ast: ast,
	                isPatternProperty: !singlePatternProperty,
	                isRequired: singlePatternProperty || (0, lodash_1$1.includes)(schema.required || [], key),
	                isUnreachableDefinition: false,
	                keyName: singlePatternProperty ? '[k: string]' : key,
	            };
	        }));
	    }
	    if (options.unreachableDefinitions) {
	        asts = asts.concat((0, lodash_1$1.map)(schema.$defs, function (value, key) {
	            var ast = parse$1(value, options, key, processed, usedNames);
	            var comment = "This interface was referenced by `".concat(parentSchemaName, "`'s JSON-Schema\nvia the `definition` \"").concat(key, "\".");
	            ast.comment = ast.comment ? "".concat(ast.comment, "\n\n").concat(comment) : comment;
	            return {
	                ast: ast,
	                isPatternProperty: false,
	                isRequired: (0, lodash_1$1.includes)(schema.required || [], key),
	                isUnreachableDefinition: true,
	                keyName: key,
	            };
	        }));
	    }
	    // handle additionalProperties
	    switch (schema.additionalProperties) {
	        case undefined:
	        case true:
	            if (singlePatternProperty) {
	                return asts;
	            }
	            return asts.concat({
	                ast: options.unknownAny ? AST_1.T_UNKNOWN_ADDITIONAL_PROPERTIES : AST_1.T_ANY_ADDITIONAL_PROPERTIES,
	                isPatternProperty: false,
	                isRequired: true,
	                isUnreachableDefinition: false,
	                keyName: '[k: string]',
	            });
	        case false:
	            return asts;
	        // pass "true" as the last param because in TS, properties
	        // defined via index signatures are already optional
	        default:
	            return asts.concat({
	                ast: parse$1(schema.additionalProperties, options, '[k: string]', processed, usedNames),
	                isPatternProperty: false,
	                isRequired: true,
	                isUnreachableDefinition: false,
	                keyName: '[k: string]',
	            });
	    }
	}
	function getDefinitions(schema, isSchema, processed) {
	    if (isSchema === void 0) { isSchema = true; }
	    if (processed === void 0) { processed = new Set(); }
	    if (processed.has(schema)) {
	        return {};
	    }
	    processed.add(schema);
	    if (Array.isArray(schema)) {
	        return schema.reduce(function (prev, cur) { return (__assign$1(__assign$1({}, prev), getDefinitions(cur, false, processed))); }, {});
	    }
	    if ((0, lodash_1$1.isPlainObject)(schema)) {
	        return __assign$1(__assign$1({}, (isSchema && hasDefinitions(schema) ? schema.$defs : {})), Object.keys(schema).reduce(function (prev, cur) { return (__assign$1(__assign$1({}, prev), getDefinitions(schema[cur], false, processed))); }, {}));
	    }
	    return {};
	}
	var getDefinitionsMemoized = (0, lodash_1$1.memoize)(getDefinitions);
	/**
	 * TODO: Reduce rate of false positives
	 */
	function hasDefinitions(schema) {
	    return '$defs' in schema;
	}

	var resolver = {};

	var cjs = {exports: {}};

	var refs = {};

	const nonJsonTypes = ["function", "symbol", "undefined"];
	const protectedProps$1 = ["constructor", "prototype", "__proto__"];
	const objectPrototype = Object.getPrototypeOf({});
	/**
	 * Custom JSON serializer for Error objects.
	 * Returns all built-in error properties, as well as extended properties.
	 */
	function toJSON() {
	    // HACK: We have to cast the objects to `any` so we can use symbol indexers.
	    // see https://github.com/Microsoft/TypeScript/issues/1863
	    let pojo = {};
	    let error = this;
	    for (let key of getDeepKeys(error)) {
	        if (typeof key === "string") {
	            let value = error[key];
	            let type = typeof value;
	            if (!nonJsonTypes.includes(type)) {
	                pojo[key] = value;
	            }
	        }
	    }
	    return pojo;
	}
	/**
	 * Returns own, inherited, enumerable, non-enumerable, string, and symbol keys of `obj`.
	 * Does NOT return members of the base Object prototype, or the specified omitted keys.
	 */
	function getDeepKeys(obj, omit = []) {
	    let keys = [];
	    // Crawl the prototype chain, finding all the string and symbol keys
	    while (obj && obj !== objectPrototype) {
	        keys = keys.concat(Object.getOwnPropertyNames(obj), Object.getOwnPropertySymbols(obj));
	        obj = Object.getPrototypeOf(obj);
	    }
	    // De-duplicate the list of keys
	    let uniqueKeys = new Set(keys);
	    // Remove any omitted keys
	    for (let key of omit.concat(protectedProps$1)) {
	        uniqueKeys.delete(key);
	    }
	    return uniqueKeys;
	}

	// The `inspect()` method is actually a Symbol, not a string key.
	// https://nodejs.org/api/util.html#util_util_inspect_custom
	const inspectMethod = inspect$1.custom || Symbol.for("nodejs.util.inspect.custom");
	/**
	 * Ono supports Node's `util.format()` formatting for error messages.
	 *
	 * @see https://nodejs.org/api/util.html#util_util_format_format_args
	 */
	const format$1 = format$2;
	/**
	 * Adds an `inspect()` method to support Node's `util.inspect()` function.
	 *
	 * @see https://nodejs.org/api/util.html#util_util_inspect_custom
	 */
	function addInspectMethod(newError) {
	    // @ts-expect-error - TypeScript doesn't support symbol indexers
	    newError[inspectMethod] = inspect;
	}
	/**
	 * Returns a representation of the error for Node's `util.inspect()` method.
	 *
	 * @see https://nodejs.org/api/util.html#util_custom_inspection_functions_on_objects
	 */
	function inspect() {
	    // HACK: We have to cast the objects to `any` so we can use symbol indexers.
	    // see https://github.com/Microsoft/TypeScript/issues/1863
	    let pojo = {};
	    let error = this;
	    for (let key of getDeepKeys(error)) {
	        let value = error[key];
	        pojo[key] = value;
	    }
	    // Don't include the `inspect()` method on the output object,
	    // otherwise it will cause `util.inspect()` to go into an infinite loop
	    // eslint-disable-next-line @typescript-eslint/no-dynamic-delete
	    delete pojo[inspectMethod];
	    return pojo;
	}

	const newline = /\r?\n/;
	const onoCall = /\bono[ @]/;
	/**
	 * Is the property lazily computed?
	 */
	function isLazyStack(stackProp) {
	    return Boolean(stackProp &&
	        stackProp.configurable &&
	        typeof stackProp.get === "function");
	}
	/**
	 * Is the stack property writable?
	 */
	function isWritableStack(stackProp) {
	    return Boolean(
	    // If there is no stack property, then it's writable, since assigning it will create it
	    !stackProp ||
	        stackProp.writable ||
	        typeof stackProp.set === "function");
	}
	/**
	 * Appends the original `Error.stack` property to the new Error's stack.
	 */
	function joinStacks(newError, originalError) {
	    let newStack = popStack(newError.stack);
	    let originalStack = originalError ? originalError.stack : undefined;
	    if (newStack && originalStack) {
	        return newStack + "\n\n" + originalStack;
	    }
	    else {
	        return newStack || originalStack;
	    }
	}
	/**
	 * Calls `joinStacks` lazily, when the `Error.stack` property is accessed.
	 */
	function lazyJoinStacks(lazyStack, newError, originalError) {
	    if (originalError) {
	        Object.defineProperty(newError, "stack", {
	            get: () => {
	                let newStack = lazyStack.get.apply(newError);
	                return joinStacks({ stack: newStack }, originalError);
	            },
	            enumerable: false,
	            configurable: true
	        });
	    }
	    else {
	        lazyPopStack(newError, lazyStack);
	    }
	}
	/**
	 * Removes Ono from the stack, so that the stack starts at the original error location
	 */
	function popStack(stack) {
	    if (stack) {
	        let lines = stack.split(newline);
	        // Find the Ono call(s) in the stack, and remove them
	        let onoStart;
	        for (let i = 0; i < lines.length; i++) {
	            let line = lines[i];
	            if (onoCall.test(line)) {
	                if (onoStart === undefined) {
	                    // We found the first Ono call in the stack trace.
	                    // There may be other subsequent Ono calls as well.
	                    onoStart = i;
	                }
	            }
	            else if (onoStart !== undefined) {
	                // We found the first non-Ono call after one or more Ono calls.
	                // So remove the Ono call lines from the stack trace
	                lines.splice(onoStart, i - onoStart);
	                break;
	            }
	        }
	        if (lines.length > 0) {
	            return lines.join("\n");
	        }
	    }
	    // If we get here, then the stack doesn't contain a call to `ono`.
	    // This may be due to minification or some optimization of the JS engine.
	    // So just return the stack as-is.
	    return stack;
	}
	/**
	 * Calls `popStack` lazily, when the `Error.stack` property is accessed.
	 */
	function lazyPopStack(error, lazyStack) {
	    Object.defineProperty(error, "stack", {
	        get: () => popStack(lazyStack.get.apply(error)),
	        enumerable: false,
	        configurable: true
	    });
	}

	const protectedProps = ["name", "message", "stack"];
	/**
	 * Extends the new error with the properties of the original error and the `props` object.
	 *
	 * @param newError - The error object to extend
	 * @param originalError - The original error object, if any
	 * @param props - Additional properties to add, if any
	 */
	function extendError(error, originalError, props) {
	    let onoError = error;
	    extendStack(onoError, originalError);
	    // Copy properties from the original error
	    if (originalError && typeof originalError === "object") {
	        mergeErrors(onoError, originalError);
	    }
	    // The default `toJSON` method doesn't output props like `name`, `message`, `stack`, etc.
	    // So replace it with one that outputs every property of the error.
	    onoError.toJSON = toJSON;
	    // On Node.js, add support for the `util.inspect()` method
	    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
	    if (addInspectMethod) {
	        addInspectMethod(onoError);
	    }
	    // Finally, copy custom properties that were specified by the user.
	    // These props OVERWRITE any previous props
	    if (props && typeof props === "object") {
	        Object.assign(onoError, props);
	    }
	    return onoError;
	}
	/**
	 * Extend the error stack to include its cause
	 */
	function extendStack(newError, originalError) {
	    let stackProp = Object.getOwnPropertyDescriptor(newError, "stack");
	    if (isLazyStack(stackProp)) {
	        lazyJoinStacks(stackProp, newError, originalError);
	    }
	    else if (isWritableStack(stackProp)) {
	        newError.stack = joinStacks(newError, originalError);
	    }
	}
	/**
	 * Merges properties of the original error with the new error.
	 *
	 * @param newError - The error object to extend
	 * @param originalError - The original error object, if any
	 */
	function mergeErrors(newError, originalError) {
	    // Get the original error's keys
	    // NOTE: We specifically exclude properties that we have already set on the new error.
	    // This is _especially_ important for the `stack` property, because this property has
	    // a lazy getter in some environments
	    let keys = getDeepKeys(originalError, protectedProps);
	    // HACK: We have to cast the errors to `any` so we can use symbol indexers.
	    // see https://github.com/Microsoft/TypeScript/issues/1863
	    let _newError = newError;
	    let _originalError = originalError;
	    for (let key of keys) {
	        if (_newError[key] === undefined) {
	            try {
	                _newError[key] = _originalError[key];
	            }
	            catch (e) {
	                // This property is read-only, so it can't be copied
	            }
	        }
	    }
	}

	/**
	 * Normalizes Ono options, accounting for defaults and optional options.
	 */
	function normalizeOptions(options) {
	    options = options || {};
	    return {
	        concatMessages: options.concatMessages === undefined ? true : Boolean(options.concatMessages),
	        format: options.format === undefined ? format$1
	            : (typeof options.format === "function" ? options.format : false),
	    };
	}
	/**
	 * Normalizes the Ono arguments, accounting for defaults, options, and optional arguments.
	 */
	function normalizeArgs$1(args, options) {
	    let originalError;
	    let props;
	    let formatArgs;
	    let message = "";
	    // Determine which arguments were actually specified
	    if (typeof args[0] === "string") {
	        formatArgs = args;
	    }
	    else if (typeof args[1] === "string") {
	        if (args[0] instanceof Error) {
	            originalError = args[0];
	        }
	        else {
	            props = args[0];
	        }
	        formatArgs = args.slice(1);
	    }
	    else {
	        originalError = args[0];
	        props = args[1];
	        formatArgs = args.slice(2);
	    }
	    // If there are any format arguments, then format the error message
	    if (formatArgs.length > 0) {
	        if (options.format) {
	            message = options.format.apply(undefined, formatArgs);
	        }
	        else {
	            message = formatArgs.join(" ");
	        }
	    }
	    if (options.concatMessages && originalError && originalError.message) {
	        // The inner-error's message will be added to the new message
	        message += (message ? " \n" : "") + originalError.message;
	    }
	    return { originalError, props, message };
	}

	const constructor = Ono;
	/**
	 * Creates an `Ono` instance for a specifc error type.
	 */
	// eslint-disable-next-line @typescript-eslint/naming-convention
	function Ono(ErrorConstructor, options) {
	    options = normalizeOptions(options);
	    function ono(...args) {
	        let { originalError, props, message } = normalizeArgs$1(args, options);
	        // Create a new error of the specified type
	        let newError = new ErrorConstructor(message);
	        // Extend the error with the properties of the original error and the `props` object
	        return extendError(newError, originalError, props);
	    }
	    ono[Symbol.species] = ErrorConstructor;
	    return ono;
	}
	/**
	 * Returns an object containing all properties of the given Error object,
	 * which can be used with `JSON.stringify()`.
	 */
	Ono.toJSON = function toJSON$1(error) {
	    return toJSON.call(error);
	};
	/**
	 * Extends the given Error object with enhanced Ono functionality, such as nested stack traces,
	 * additional properties, and improved support for `JSON.stringify()`.
	 */
	Ono.extend = function extend(error, originalError, props) {
	    if (props || originalError instanceof Error) {
	        return extendError(error, originalError, props);
	    }
	    else if (originalError) {
	        return extendError(error, undefined, originalError);
	    }
	    else {
	        return extendError(error);
	    }
	};

	const singleton = ono;
	ono.error = new constructor(Error);
	ono.eval = new constructor(EvalError);
	ono.range = new constructor(RangeError);
	ono.reference = new constructor(ReferenceError);
	ono.syntax = new constructor(SyntaxError);
	ono.type = new constructor(TypeError);
	ono.uri = new constructor(URIError);
	const onoMap = ono;
	/**
	 * Creates a new error with the specified message, properties, and/or inner error.
	 * If an inner error is provided, then the new error will match its type, if possible.
	 */
	function ono(...args) {
	    let originalError = args[0];
	    // Is the first argument an Error-like object?
	    if (typeof originalError === "object" && typeof originalError.name === "string") {
	        // Try to find an Ono singleton method that matches this error type
	        for (let typedOno of Object.values(onoMap)) {
	            if (typeof typedOno === "function" && typedOno.name === "ono") {
	                let species = typedOno[Symbol.species];
	                if (species && species !== Error && (originalError instanceof species || originalError.name === species.name)) {
	                    // Create an error of the same type
	                    return typedOno.apply(undefined, args);
	                }
	            }
	        }
	    }
	    // By default, create a base Error object
	    return ono.error.apply(undefined, args);
	}

	/* eslint-env commonjs */
	// CommonJS default export hack
	if (typeof module === "object" && typeof module.exports === "object") {
	    module.exports = Object.assign(module.exports.default, module.exports);
	}

	var esm = /*#__PURE__*/Object.freeze({
		__proto__: null,
		Ono: constructor,
		default: singleton,
		ono: singleton
	});

	var require$$9 = /*@__PURE__*/getAugmentedNamespace(esm);

	var ref = {};

	var pointer = {};

	var url = {};

	const nodePath = require$$2;

	// Webpack 4 (used by browser tests) can't transpile import.meta.url
	// So export the project directory using __dirname from a .cjs module
	const projectDir = nodePath.resolve(__dirname, "..", "..");
	var projectDir_1 = projectDir;

	(function (exports) {
		Object.defineProperty(exports, "__esModule", {
		    value: true
		});
		function _export(target, all) {
		    for(var name in all)Object.defineProperty(target, name, {
		        enumerable: true,
		        get: all[name]
		    });
		}
		_export(exports, {
		    parse: function() {
		        return parse;
		    },
		    resolve: function() {
		        return resolve;
		    },
		    cwd: function() {
		        return cwd;
		    },
		    getProtocol: function() {
		        return getProtocol;
		    },
		    getExtension: function() {
		        return getExtension;
		    },
		    stripQuery: function() {
		        return stripQuery;
		    },
		    getHash: function() {
		        return getHash;
		    },
		    stripHash: function() {
		        return stripHash;
		    },
		    isHttp: function() {
		        return isHttp;
		    },
		    isFileSystemPath: function() {
		        return isFileSystemPath;
		    },
		    fromFileSystemPath: function() {
		        return fromFileSystemPath;
		    },
		    toFileSystemPath: function() {
		        return toFileSystemPath;
		    },
		    safePointerToPath: function() {
		        return safePointerToPath;
		    }
		});
		var _projectDirCjs = /*#__PURE__*/ _interopRequireDefault(projectDir_1);
		function _interopRequireDefault(obj) {
		    return obj && obj.__esModule ? obj : {
		        default: obj
		    };
		}
		var isWindows = /^win/.test(globalThis.process ? globalThis.process.platform : undefined), forwardSlashPattern = /\//g, protocolPattern = /^(\w{2,}):\/\//i, jsonPointerSlash = /~1/g, jsonPointerTilde = /~0/g;
		// RegExp patterns to URL-encode special characters in local filesystem paths
		var urlEncodePatterns = [
		    /\?/g,
		    "%3F",
		    /\#/g,
		    "%23"
		];
		// RegExp patterns to URL-decode special characters for local filesystem paths
		var urlDecodePatterns = [
		    /\%23/g,
		    "#",
		    /\%24/g,
		    "$",
		    /\%26/g,
		    "&",
		    /\%2C/g,
		    ",",
		    /\%40/g,
		    "@"
		];
		var parse = function(u) {
		    return new URL(u);
		};
		function resolve(from, to) {
		    var resolvedUrl = new URL(to, new URL(from, "resolve://"));
		    if (resolvedUrl.protocol === "resolve:") {
		        // `from` is a relative URL.
		        var pathname = resolvedUrl.pathname, search = resolvedUrl.search, hash = resolvedUrl.hash;
		        return pathname + search + hash;
		    }
		    return resolvedUrl.toString();
		}
		function cwd() {
		    if (typeof window !== "undefined") {
		        return location.href;
		    }
		    var path = browser$1.cwd();
		    var lastChar = path.slice(-1);
		    if (lastChar === "/" || lastChar === "\\") {
		        return path;
		    } else {
		        return path + "/";
		    }
		}
		function getProtocol(path) {
		    var match = protocolPattern.exec(path);
		    if (match) {
		        return match[1].toLowerCase();
		    }
		}
		function getExtension(path) {
		    var lastDot = path.lastIndexOf(".");
		    if (lastDot >= 0) {
		        return stripQuery(path.substr(lastDot).toLowerCase());
		    }
		    return "";
		}
		function stripQuery(path) {
		    var queryIndex = path.indexOf("?");
		    if (queryIndex >= 0) {
		        path = path.substr(0, queryIndex);
		    }
		    return path;
		}
		function getHash(path) {
		    var hashIndex = path.indexOf("#");
		    if (hashIndex >= 0) {
		        return path.substr(hashIndex);
		    }
		    return "#";
		}
		function stripHash(path) {
		    var hashIndex = path.indexOf("#");
		    if (hashIndex >= 0) {
		        path = path.substr(0, hashIndex);
		    }
		    return path;
		}
		function isHttp(path) {
		    var protocol = getProtocol(path);
		    if (protocol === "http" || protocol === "https") {
		        return true;
		    } else if (protocol === undefined) {
		        // There is no protocol.  If we're running in a browser, then assume it's HTTP.
		        return typeof window !== "undefined";
		    } else {
		        // It's some other protocol, such as "ftp://", "mongodb://", etc.
		        return false;
		    }
		}
		function isFileSystemPath(path) {
		    if (browser$1.browser) {
		        // We're running in a browser, so assume that all paths are URLs.
		        // This way, even relative paths will be treated as URLs rather than as filesystem paths
		        return false;
		    }
		    var protocol = getProtocol(path);
		    return protocol === undefined || protocol === "file";
		}
		function fromFileSystemPath(path) {
		    // Step 1: On Windows, replace backslashes with forward slashes,
		    // rather than encoding them as "%5C"
		    if (isWindows) {
		        var hasProjectDir = path.toUpperCase().includes(_projectDirCjs.default.replace(/\\/g, "\\").toUpperCase());
		        var hasProjectUri = path.toUpperCase().includes(_projectDirCjs.default.replace(/\\/g, "/").toUpperCase());
		        if (hasProjectDir || hasProjectUri) {
		            path = path.replace(/\\/g, "/");
		        } else {
		            path = "".concat(_projectDirCjs.default, "/").concat(path).replace(/\\/g, "/");
		        }
		    }
		    // Step 2: `encodeURI` will take care of MOST characters
		    path = encodeURI(path);
		    // Step 3: Manually encode characters that are not encoded by `encodeURI`.
		    // This includes characters such as "#" and "?", which have special meaning in URLs,
		    // but are just normal characters in a filesystem path.
		    for(var i = 0; i < urlEncodePatterns.length; i += 2){
		        path = path.replace(urlEncodePatterns[i], urlEncodePatterns[i + 1]);
		    }
		    return path;
		}
		function toFileSystemPath(path, keepFileProtocol) {
		    // Step 1: `decodeURI` will decode characters such as Cyrillic characters, spaces, etc.
		    path = decodeURI(path);
		    // Step 2: Manually decode characters that are not decoded by `decodeURI`.
		    // This includes characters such as "#" and "?", which have special meaning in URLs,
		    // but are just normal characters in a filesystem path.
		    for(var i = 0; i < urlDecodePatterns.length; i += 2){
		        path = path.replace(urlDecodePatterns[i], urlDecodePatterns[i + 1]);
		    }
		    // Step 3: If it's a "file://" URL, then format it consistently
		    // or convert it to a local filesystem path
		    var isFileUrl = path.substr(0, 7).toLowerCase() === "file://";
		    if (isFileUrl) {
		        // Strip-off the protocol, and the initial "/", if there is one
		        path = path[7] === "/" ? path.substr(8) : path.substr(7);
		        // insert a colon (":") after the drive letter on Windows
		        if (isWindows && path[1] === "/") {
		            path = path[0] + ":" + path.substr(1);
		        }
		        if (keepFileProtocol) {
		            // Return the consistently-formatted "file://" URL
		            path = "file:///" + path;
		        } else {
		            // Convert the "file://" URL to a local filesystem path.
		            // On Windows, it will start with something like "C:/".
		            // On Posix, it will start with "/"
		            isFileUrl = false;
		            path = isWindows ? path : "/" + path;
		        }
		    }
		    // Step 4: Normalize Windows paths (unless it's a "file://" URL)
		    if (isWindows && !isFileUrl) {
		        // Replace forward slashes with backslashes
		        path = path.replace(forwardSlashPattern, "\\");
		        // Capitalize the drive letter
		        if (path.substr(1, 2) === ":\\") {
		            path = path[0].toUpperCase() + path.substr(1);
		        }
		    }
		    return path;
		}
		function safePointerToPath(pointer) {
		    if (pointer.length <= 1 || pointer[0] !== "#" || pointer[1] !== "/") {
		        return [];
		    }
		    return pointer.slice(2).split("/").map(function(value) {
		        return decodeURIComponent(value).replace(jsonPointerSlash, "/").replace(jsonPointerTilde, "~");
		    });
		} 
	} (url));

	var errors = {};

	(function (exports) {
		Object.defineProperty(exports, "__esModule", {
		    value: true
		});
		function _export(target, all) {
		    for(var name in all)Object.defineProperty(target, name, {
		        enumerable: true,
		        get: all[name]
		    });
		}
		_export(exports, {
		    JSONParserError: function() {
		        return JSONParserError;
		    },
		    JSONParserErrorGroup: function() {
		        return JSONParserErrorGroup;
		    },
		    ParserError: function() {
		        return ParserError;
		    },
		    UnmatchedParserError: function() {
		        return UnmatchedParserError;
		    },
		    ResolverError: function() {
		        return ResolverError;
		    },
		    UnmatchedResolverError: function() {
		        return UnmatchedResolverError;
		    },
		    MissingPointerError: function() {
		        return MissingPointerError;
		    },
		    InvalidPointerError: function() {
		        return InvalidPointerError;
		    },
		    isHandledError: function() {
		        return isHandledError;
		    },
		    normalizeError: function() {
		        return normalizeError;
		    }
		});
		var _ono = require$$9;
		var _urlJs = url;
		function _arrayLikeToArray(arr, len) {
		    if (len == null || len > arr.length) len = arr.length;
		    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
		    return arr2;
		}
		function _arrayWithoutHoles(arr) {
		    if (Array.isArray(arr)) return _arrayLikeToArray(arr);
		}
		function _assertThisInitialized(self) {
		    if (self === void 0) {
		        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
		    }
		    return self;
		}
		function _classCallCheck(instance, Constructor) {
		    if (!(instance instanceof Constructor)) {
		        throw new TypeError("Cannot call a class as a function");
		    }
		}
		function isNativeReflectConstruct() {
		    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
		    if (Reflect.construct.sham) return false;
		    if (typeof Proxy === "function") return true;
		    try {
		        Date.prototype.toString.call(Reflect.construct(Date, [], function() {}));
		        return true;
		    } catch (e) {
		        return false;
		    }
		}
		function _construct(Parent, args, Class) {
		    if (isNativeReflectConstruct()) {
		        _construct = Reflect.construct;
		    } else {
		        _construct = function _construct(Parent, args, Class) {
		            var a = [
		                null
		            ];
		            a.push.apply(a, args);
		            var Constructor = Function.bind.apply(Parent, a);
		            var instance = new Constructor();
		            if (Class) _setPrototypeOf(instance, Class.prototype);
		            return instance;
		        };
		    }
		    return _construct.apply(null, arguments);
		}
		function _defineProperties(target, props) {
		    for(var i = 0; i < props.length; i++){
		        var descriptor = props[i];
		        descriptor.enumerable = descriptor.enumerable || false;
		        descriptor.configurable = true;
		        if ("value" in descriptor) descriptor.writable = true;
		        Object.defineProperty(target, descriptor.key, descriptor);
		    }
		}
		function _createClass(Constructor, protoProps, staticProps) {
		    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
		    if (staticProps) _defineProperties(Constructor, staticProps);
		    return Constructor;
		}
		function _getPrototypeOf(o) {
		    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
		        return o.__proto__ || Object.getPrototypeOf(o);
		    };
		    return _getPrototypeOf(o);
		}
		function _inherits(subClass, superClass) {
		    if (typeof superClass !== "function" && superClass !== null) {
		        throw new TypeError("Super expression must either be null or a function");
		    }
		    subClass.prototype = Object.create(superClass && superClass.prototype, {
		        constructor: {
		            value: subClass,
		            writable: true,
		            configurable: true
		        }
		    });
		    if (superClass) _setPrototypeOf(subClass, superClass);
		}
		function _instanceof(left, right) {
		    if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) {
		        return !!right[Symbol.hasInstance](left);
		    } else {
		        return left instanceof right;
		    }
		}
		function _isNativeFunction(fn) {
		    return Function.toString.call(fn).indexOf("[native code]") !== -1;
		}
		function _iterableToArray(iter) {
		    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
		}
		function _nonIterableSpread() {
		    throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
		}
		function _possibleConstructorReturn(self, call) {
		    if (call && (_typeof(call) === "object" || typeof call === "function")) {
		        return call;
		    }
		    return _assertThisInitialized(self);
		}
		function _setPrototypeOf(o, p) {
		    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
		        o.__proto__ = p;
		        return o;
		    };
		    return _setPrototypeOf(o, p);
		}
		function _toConsumableArray(arr) {
		    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
		}
		var _typeof = function(obj) {
		    "@swc/helpers - typeof";
		    return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
		};
		function _unsupportedIterableToArray(o, minLen) {
		    if (!o) return;
		    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
		    var n = Object.prototype.toString.call(o).slice(8, -1);
		    if (n === "Object" && o.constructor) n = o.constructor.name;
		    if (n === "Map" || n === "Set") return Array.from(n);
		    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
		}
		function _wrapNativeSuper(Class) {
		    var _cache = typeof Map === "function" ? new Map() : undefined;
		    _wrapNativeSuper = function _wrapNativeSuper(Class) {
		        if (Class === null || !_isNativeFunction(Class)) return Class;
		        if (typeof Class !== "function") {
		            throw new TypeError("Super expression must either be null or a function");
		        }
		        if (typeof _cache !== "undefined") {
		            if (_cache.has(Class)) return _cache.get(Class);
		            _cache.set(Class, Wrapper);
		        }
		        function Wrapper() {
		            return _construct(Class, arguments, _getPrototypeOf(this).constructor);
		        }
		        Wrapper.prototype = Object.create(Class.prototype, {
		            constructor: {
		                value: Wrapper,
		                enumerable: false,
		                writable: true,
		                configurable: true
		            }
		        });
		        return _setPrototypeOf(Wrapper, Class);
		    };
		    return _wrapNativeSuper(Class);
		}
		function _isNativeReflectConstruct() {
		    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
		    if (Reflect.construct.sham) return false;
		    if (typeof Proxy === "function") return true;
		    try {
		        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
		        return true;
		    } catch (e) {
		        return false;
		    }
		}
		function _createSuper(Derived) {
		    var hasNativeReflectConstruct = _isNativeReflectConstruct();
		    return function _createSuperInternal() {
		        var Super = _getPrototypeOf(Derived), result;
		        if (hasNativeReflectConstruct) {
		            var NewTarget = _getPrototypeOf(this).constructor;
		            result = Reflect.construct(Super, arguments, NewTarget);
		        } else {
		            result = Super.apply(this, arguments);
		        }
		        return _possibleConstructorReturn(this, result);
		    };
		}
		var JSONParserError = /*#__PURE__*/ function(Error1) {
		    _inherits(JSONParserError, Error1);
		    var _super = _createSuper(JSONParserError);
		    function JSONParserError(message, source) {
		        _classCallCheck(this, JSONParserError);
		        var _this;
		        _this = _super.call(this);
		        _this.code = "EUNKNOWN";
		        _this.message = message;
		        _this.source = source;
		        _this.path = null;
		        _ono.Ono.extend(_assertThisInitialized(_this));
		        return _this;
		    }
		    _createClass(JSONParserError, [
		        {
		            key: "footprint",
		            get: function get() {
		                return "".concat(this.path, "+").concat(this.source, "+").concat(this.code, "+").concat(this.message);
		            }
		        }
		    ]);
		    return JSONParserError;
		}(_wrapNativeSuper(Error));
		setErrorName(JSONParserError);
		var JSONParserErrorGroup = /*#__PURE__*/ function(Error1) {
		    _inherits(JSONParserErrorGroup, Error1);
		    var _super = _createSuper(JSONParserErrorGroup);
		    function JSONParserErrorGroup(parser) {
		        _classCallCheck(this, JSONParserErrorGroup);
		        var _this;
		        _this = _super.call(this);
		        _this.files = parser;
		        _this.message = "".concat(_this.errors.length, " error").concat(_this.errors.length > 1 ? "s" : "", " occurred while reading '").concat((0, _urlJs.toFileSystemPath)(parser.$refs._root$Ref.path), "'");
		        _ono.Ono.extend(_assertThisInitialized(_this));
		        return _this;
		    }
		    _createClass(JSONParserErrorGroup, [
		        {
		            key: "errors",
		            get: function get() {
		                return JSONParserErrorGroup.getParserErrors(this.files);
		            }
		        }
		    ], [
		        {
		            key: "getParserErrors",
		            value: function getParserErrors(parser) {
		                var errors = [];
		                var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
		                try {
		                    for(var _iterator = Object.values(parser.$refs._$refs)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
		                        var $ref = _step.value;
		                        if ($ref.errors) {
		                            var _errors;
		                            (_errors = errors).push.apply(_errors, _toConsumableArray($ref.errors));
		                        }
		                    }
		                } catch (err) {
		                    _didIteratorError = true;
		                    _iteratorError = err;
		                } finally{
		                    try {
		                        if (!_iteratorNormalCompletion && _iterator.return != null) {
		                            _iterator.return();
		                        }
		                    } finally{
		                        if (_didIteratorError) {
		                            throw _iteratorError;
		                        }
		                    }
		                }
		                return errors;
		            }
		        }
		    ]);
		    return JSONParserErrorGroup;
		}(_wrapNativeSuper(Error));
		setErrorName(JSONParserErrorGroup);
		var ParserError = /*#__PURE__*/ function(JSONParserError) {
		    _inherits(ParserError, JSONParserError);
		    var _super = _createSuper(ParserError);
		    function ParserError(message, source) {
		        _classCallCheck(this, ParserError);
		        var _this;
		        _this = _super.call(this, "Error parsing ".concat(source, ": ").concat(message), source);
		        _this.code = "EPARSER";
		        return _this;
		    }
		    return ParserError;
		}(JSONParserError);
		setErrorName(ParserError);
		var UnmatchedParserError = /*#__PURE__*/ function(JSONParserError) {
		    _inherits(UnmatchedParserError, JSONParserError);
		    var _super = _createSuper(UnmatchedParserError);
		    function UnmatchedParserError(source) {
		        _classCallCheck(this, UnmatchedParserError);
		        var _this;
		        _this = _super.call(this, 'Could not find parser for "'.concat(source, '"'), source);
		        _this.code = "EUNMATCHEDPARSER";
		        return _this;
		    }
		    return UnmatchedParserError;
		}(JSONParserError);
		setErrorName(UnmatchedParserError);
		var ResolverError = /*#__PURE__*/ function(JSONParserError) {
		    _inherits(ResolverError, JSONParserError);
		    var _super = _createSuper(ResolverError);
		    function ResolverError(ex, source) {
		        _classCallCheck(this, ResolverError);
		        var _this;
		        _this = _super.call(this, ex.message || 'Error reading file "'.concat(source, '"'), source);
		        _this.code = "ERESOLVER";
		        if ("code" in ex) {
		            _this.ioErrorCode = String(ex.code);
		        }
		        return _this;
		    }
		    return ResolverError;
		}(JSONParserError);
		setErrorName(ResolverError);
		var UnmatchedResolverError = /*#__PURE__*/ function(JSONParserError) {
		    _inherits(UnmatchedResolverError, JSONParserError);
		    var _super = _createSuper(UnmatchedResolverError);
		    function UnmatchedResolverError(source) {
		        _classCallCheck(this, UnmatchedResolverError);
		        var _this;
		        _this = _super.call(this, 'Could not find resolver for "'.concat(source, '"'), source);
		        _this.code = "EUNMATCHEDRESOLVER";
		        return _this;
		    }
		    return UnmatchedResolverError;
		}(JSONParserError);
		setErrorName(UnmatchedResolverError);
		var MissingPointerError = /*#__PURE__*/ function(JSONParserError) {
		    _inherits(MissingPointerError, JSONParserError);
		    var _super = _createSuper(MissingPointerError);
		    function MissingPointerError(token, path) {
		        _classCallCheck(this, MissingPointerError);
		        var _this;
		        _this = _super.call(this, 'Token "'.concat(token, '" does not exist.'), (0, _urlJs.stripHash)(path));
		        _this.code = "EMISSINGPOINTER";
		        return _this;
		    }
		    return MissingPointerError;
		}(JSONParserError);
		setErrorName(MissingPointerError);
		var InvalidPointerError = /*#__PURE__*/ function(JSONParserError) {
		    _inherits(InvalidPointerError, JSONParserError);
		    var _super = _createSuper(InvalidPointerError);
		    function InvalidPointerError(pointer, path) {
		        _classCallCheck(this, InvalidPointerError);
		        var _this;
		        _this = _super.call(this, 'Invalid $ref pointer "'.concat(pointer, '". Pointers must begin with "#/"'), (0, _urlJs.stripHash)(path));
		        _this.code = "EINVALIDPOINTER";
		        return _this;
		    }
		    return InvalidPointerError;
		}(JSONParserError);
		setErrorName(InvalidPointerError);
		function setErrorName(err) {
		    Object.defineProperty(err.prototype, "name", {
		        value: err.name,
		        enumerable: true
		    });
		}
		function isHandledError(err) {
		    return _instanceof(err, JSONParserError) || _instanceof(err, JSONParserErrorGroup);
		}
		function normalizeError(err) {
		    if (err.path === null) {
		        err.path = [];
		    }
		    return err;
		} 
	} (errors));

	var hasRequiredPointer;

	function requirePointer () {
		if (hasRequiredPointer) return pointer;
		hasRequiredPointer = 1;
		(function (exports) {
			Object.defineProperty(exports, "__esModule", {
			    value: true
			});
			Object.defineProperty(exports, "default", {
			    enumerable: true,
			    get: function() {
			        return _default;
			    }
			});
			var _refJs = /*#__PURE__*/ _interopRequireDefault(requireRef());
			var _urlJs = /*#__PURE__*/ _interopRequireWildcard(url);
			var _errorsJs = errors;
			function _interopRequireDefault(obj) {
			    return obj && obj.__esModule ? obj : {
			        default: obj
			    };
			}
			function _getRequireWildcardCache(nodeInterop) {
			    if (typeof WeakMap !== "function") return null;
			    var cacheBabelInterop = new WeakMap();
			    var cacheNodeInterop = new WeakMap();
			    return (_getRequireWildcardCache = function(nodeInterop) {
			        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
			    })(nodeInterop);
			}
			function _interopRequireWildcard(obj, nodeInterop) {
			    if (obj && obj.__esModule) {
			        return obj;
			    }
			    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
			        return {
			            default: obj
			        };
			    }
			    var cache = _getRequireWildcardCache(nodeInterop);
			    if (cache && cache.has(obj)) {
			        return cache.get(obj);
			    }
			    var newObj = {};
			    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
			    for(var key in obj){
			        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
			            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
			            if (desc && (desc.get || desc.set)) {
			                Object.defineProperty(newObj, key, desc);
			            } else {
			                newObj[key] = obj[key];
			            }
			        }
			    }
			    newObj.default = obj;
			    if (cache) {
			        cache.set(obj, newObj);
			    }
			    return newObj;
			}
			var _default = Pointer;
			var slashes = /\//g;
			var tildes = /~/g;
			var escapedSlash = /~1/g;
			var escapedTilde = /~0/g;
			/**
			 * This class represents a single JSON pointer and its resolved value.
			 *
			 * @param {$Ref} $ref
			 * @param {string} path
			 * @param {string} [friendlyPath] - The original user-specified path (used for error messages)
			 * @constructor
			 */ function Pointer($ref, path, friendlyPath) {
			    /**
			   * The {@link $Ref} object that contains this {@link Pointer} object.
			   * @type {$Ref}
			   */ this.$ref = $ref;
			    /**
			   * The file path or URL, containing the JSON pointer in the hash.
			   * This path is relative to the path of the main JSON schema file.
			   * @type {string}
			   */ this.path = path;
			    /**
			   * The original path or URL, used for error messages.
			   * @type {string}
			   */ this.originalPath = friendlyPath || path;
			    /**
			   * The value of the JSON pointer.
			   * Can be any JSON type, not just objects. Unknown file types are represented as Buffers (byte arrays).
			   * @type {?*}
			   */ this.value = undefined;
			    /**
			   * Indicates whether the pointer references itself.
			   * @type {boolean}
			   */ this.circular = false;
			    /**
			   * The number of indirect references that were traversed to resolve the value.
			   * Resolving a single pointer may require resolving multiple $Refs.
			   * @type {number}
			   */ this.indirections = 0;
			}
			/**
			 * Resolves the value of a nested property within the given object.
			 *
			 * @param {*} obj - The object that will be crawled
			 * @param {$RefParserOptions} options
			 * @param {string} pathFromRoot - the path of place that initiated resolving
			 *
			 * @returns {Pointer}
			 * Returns a JSON pointer whose {@link Pointer#value} is the resolved value.
			 * If resolving this value required resolving other JSON references, then
			 * the {@link Pointer#$ref} and {@link Pointer#path} will reflect the resolution path
			 * of the resolved value.
			 */ Pointer.prototype.resolve = function(obj, options, pathFromRoot) {
			    var tokens = Pointer.parse(this.path, this.originalPath);
			    // Crawl the object, one token at a time
			    this.value = unwrapOrThrow(obj);
			    for(var i = 0; i < tokens.length; i++){
			        if (resolveIf$Ref(this, options)) {
			            // The $ref path has changed, so append the remaining tokens to the path
			            this.path = Pointer.join(this.path, tokens.slice(i));
			        }
			        if (typeof this.value === "object" && this.value !== null && "$ref" in this.value) {
			            return this;
			        }
			        var token = tokens[i];
			        if (this.value[token] === undefined || this.value[token] === null) {
			            this.value = null;
			            throw new _errorsJs.MissingPointerError(token, decodeURI(this.originalPath));
			        } else {
			            this.value = this.value[token];
			        }
			    }
			    // Resolve the final value
			    if (!this.value || this.value.$ref && _urlJs.resolve(this.path, this.value.$ref) !== pathFromRoot) {
			        resolveIf$Ref(this, options);
			    }
			    return this;
			};
			/**
			 * Sets the value of a nested property within the given object.
			 *
			 * @param {*} obj - The object that will be crawled
			 * @param {*} value - the value to assign
			 * @param {$RefParserOptions} options
			 *
			 * @returns {*}
			 * Returns the modified object, or an entirely new object if the entire object is overwritten.
			 */ Pointer.prototype.set = function(obj, value, options) {
			    var tokens = Pointer.parse(this.path);
			    var token;
			    if (tokens.length === 0) {
			        // There are no tokens, replace the entire object with the new value
			        this.value = value;
			        return value;
			    }
			    // Crawl the object, one token at a time
			    this.value = unwrapOrThrow(obj);
			    for(var i = 0; i < tokens.length - 1; i++){
			        resolveIf$Ref(this, options);
			        token = tokens[i];
			        if (this.value && this.value[token] !== undefined) {
			            // The token exists
			            this.value = this.value[token];
			        } else {
			            // The token doesn't exist, so create it
			            this.value = setValue(this, token, {});
			        }
			    }
			    // Set the value of the final token
			    resolveIf$Ref(this, options);
			    token = tokens[tokens.length - 1];
			    setValue(this, token, value);
			    // Return the updated object
			    return obj;
			};
			/**
			 * Parses a JSON pointer (or a path containing a JSON pointer in the hash)
			 * and returns an array of the pointer's tokens.
			 * (e.g. "schema.json#/definitions/person/name" => ["definitions", "person", "name"])
			 *
			 * The pointer is parsed according to RFC 6901
			 * {@link https://tools.ietf.org/html/rfc6901#section-3}
			 *
			 * @param {string} path
			 * @param {string} [originalPath]
			 * @returns {string[]}
			 */ Pointer.parse = function(path, originalPath) {
			    // Get the JSON pointer from the path's hash
			    var pointer = _urlJs.getHash(path).substr(1);
			    // If there's no pointer, then there are no tokens,
			    // so return an empty array
			    if (!pointer) {
			        return [];
			    }
			    // Split into an array
			    pointer = pointer.split("/");
			    // Decode each part, according to RFC 6901
			    for(var i = 0; i < pointer.length; i++){
			        pointer[i] = decodeURIComponent(pointer[i].replace(escapedSlash, "/").replace(escapedTilde, "~"));
			    }
			    if (pointer[0] !== "") {
			        throw new _errorsJs.InvalidPointerError(pointer, originalPath === undefined ? path : originalPath);
			    }
			    return pointer.slice(1);
			};
			/**
			 * Creates a JSON pointer path, by joining one or more tokens to a base path.
			 *
			 * @param {string} base - The base path (e.g. "schema.json#/definitions/person")
			 * @param {string|string[]} tokens - The token(s) to append (e.g. ["name", "first"])
			 * @returns {string}
			 */ Pointer.join = function(base, tokens) {
			    // Ensure that the base path contains a hash
			    if (base.indexOf("#") === -1) {
			        base += "#";
			    }
			    // Append each token to the base path
			    tokens = Array.isArray(tokens) ? tokens : [
			        tokens
			    ];
			    for(var i = 0; i < tokens.length; i++){
			        var token = tokens[i];
			        // Encode the token, according to RFC 6901
			        base += "/" + encodeURIComponent(token.replace(tildes, "~0").replace(slashes, "~1"));
			    }
			    return base;
			};
			/**
			 * If the given pointer's {@link Pointer#value} is a JSON reference,
			 * then the reference is resolved and {@link Pointer#value} is replaced with the resolved value.
			 * In addition, {@link Pointer#path} and {@link Pointer#$ref} are updated to reflect the
			 * resolution path of the new value.
			 *
			 * @param {Pointer} pointer
			 * @param {$RefParserOptions} options
			 * @returns {boolean} - Returns `true` if the resolution path changed
			 */ function resolveIf$Ref(pointer, options) {
			    // Is the value a JSON reference? (and allowed?)
			    if (_refJs.default.isAllowed$Ref(pointer.value, options)) {
			        var $refPath = _urlJs.resolve(pointer.path, pointer.value.$ref);
			        if ($refPath === pointer.path) {
			            // The value is a reference to itself, so there's nothing to do.
			            pointer.circular = true;
			        } else {
			            var resolved = pointer.$ref.$refs._resolve($refPath, pointer.path, options);
			            if (resolved === null) {
			                return false;
			            }
			            pointer.indirections += resolved.indirections + 1;
			            if (_refJs.default.isExtended$Ref(pointer.value)) {
			                // This JSON reference "extends" the resolved value, rather than simply pointing to it.
			                // So the resolved path does NOT change.  Just the value does.
			                pointer.value = _refJs.default.dereference(pointer.value, resolved.value);
			                return false;
			            } else {
			                // Resolve the reference
			                pointer.$ref = resolved.$ref;
			                pointer.path = resolved.path;
			                pointer.value = resolved.value;
			            }
			            return true;
			        }
			    }
			}
			/**
			 * Sets the specified token value of the {@link Pointer#value}.
			 *
			 * The token is evaluated according to RFC 6901.
			 * {@link https://tools.ietf.org/html/rfc6901#section-4}
			 *
			 * @param {Pointer} pointer - The JSON Pointer whose value will be modified
			 * @param {string} token - A JSON Pointer token that indicates how to modify `obj`
			 * @param {*} value - The value to assign
			 * @returns {*} - Returns the assigned value
			 */ function setValue(pointer, token, value) {
			    if (pointer.value && typeof pointer.value === "object") {
			        if (token === "-" && Array.isArray(pointer.value)) {
			            pointer.value.push(value);
			        } else {
			            pointer.value[token] = value;
			        }
			    } else {
			        throw new _errorsJs.JSONParserError('Error assigning $ref pointer "'.concat(pointer.path, '". \nCannot set "').concat(token, '" of a non-object.'));
			    }
			    return value;
			}
			function unwrapOrThrow(value) {
			    if ((0, _errorsJs.isHandledError)(value)) {
			        throw value;
			    }
			    return value;
			} 
		} (pointer));
		return pointer;
	}

	var hasRequiredRef;

	function requireRef () {
		if (hasRequiredRef) return ref;
		hasRequiredRef = 1;
		(function (exports) {
			Object.defineProperty(exports, "__esModule", {
			    value: true
			});
			Object.defineProperty(exports, "default", {
			    enumerable: true,
			    get: function() {
			        return _default;
			    }
			});
			var _pointerJs = /*#__PURE__*/ _interopRequireDefault(requirePointer());
			var _errorsJs = errors;
			var _urlJs = url;
			function _arrayLikeToArray(arr, len) {
			    if (len == null || len > arr.length) len = arr.length;
			    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
			    return arr2;
			}
			function _arrayWithoutHoles(arr) {
			    if (Array.isArray(arr)) return _arrayLikeToArray(arr);
			}
			function _instanceof(left, right) {
			    if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) {
			        return !!right[Symbol.hasInstance](left);
			    } else {
			        return left instanceof right;
			    }
			}
			function _interopRequireDefault(obj) {
			    return obj && obj.__esModule ? obj : {
			        default: obj
			    };
			}
			function _iterableToArray(iter) {
			    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
			}
			function _nonIterableSpread() {
			    throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
			}
			function _toConsumableArray(arr) {
			    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
			}
			function _unsupportedIterableToArray(o, minLen) {
			    if (!o) return;
			    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
			    var n = Object.prototype.toString.call(o).slice(8, -1);
			    if (n === "Object" && o.constructor) n = o.constructor.name;
			    if (n === "Map" || n === "Set") return Array.from(n);
			    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
			}
			var _default = $Ref;
			/**
			 * This class represents a single JSON reference and its resolved value.
			 *
			 * @class
			 */ function $Ref() {
			    /**
			   * The file path or URL of the referenced file.
			   * This path is relative to the path of the main JSON schema file.
			   *
			   * This path does NOT contain document fragments (JSON pointers). It always references an ENTIRE file.
			   * Use methods such as {@link $Ref#get}, {@link $Ref#resolve}, and {@link $Ref#exists} to get
			   * specific JSON pointers within the file.
			   *
			   * @type {string}
			   */ this.path = undefined;
			    /**
			   * The resolved value of the JSON reference.
			   * Can be any JSON type, not just objects. Unknown file types are represented as Buffers (byte arrays).
			   *
			   * @type {?*}
			   */ this.value = undefined;
			    /**
			   * The {@link $Refs} object that contains this {@link $Ref} object.
			   *
			   * @type {$Refs}
			   */ this.$refs = undefined;
			    /**
			   * Indicates the type of {@link $Ref#path} (e.g. "file", "http", etc.)
			   *
			   * @type {?string}
			   */ this.pathType = undefined;
			    /**
			   * List of all errors. Undefined if no errors.
			   *
			   * @type {Array<JSONParserError | ResolverError | ParserError | MissingPointerError>}
			   */ this.errors = undefined;
			}
			/**
			 * Pushes an error to errors array.
			 *
			 * @param {Array<JSONParserError | JSONParserErrorGroup>} err - The error to be pushed
			 * @returns {void}
			 */ $Ref.prototype.addError = function(err) {
			    if (this.errors === undefined) {
			        this.errors = [];
			    }
			    var existingErrors = this.errors.map(function(param) {
			        var footprint = param.footprint;
			        return footprint;
			    });
			    // the path has been almost certainly set at this point,
			    // but just in case something went wrong, normalizeError injects path if necessary
			    // moreover, certain errors might point at the same spot, so filter them out to reduce noise
			    if (Array.isArray(err.errors)) {
			        var _this_errors;
			        (_this_errors = this.errors).push.apply(_this_errors, _toConsumableArray(err.errors.map(_errorsJs.normalizeError).filter(function(param) {
			            var footprint = param.footprint;
			            return !existingErrors.includes(footprint);
			        })));
			    } else if (!existingErrors.includes(err.footprint)) {
			        this.errors.push((0, _errorsJs.normalizeError)(err));
			    }
			};
			/**
			 * Determines whether the given JSON reference exists within this {@link $Ref#value}.
			 *
			 * @param {string} path - The full path being resolved, optionally with a JSON pointer in the hash
			 * @param {$RefParserOptions} options
			 * @returns {boolean}
			 */ $Ref.prototype.exists = function(path, options) {
			    try {
			        this.resolve(path, options);
			        return true;
			    } catch (e) {
			        return false;
			    }
			};
			/**
			 * Resolves the given JSON reference within this {@link $Ref#value} and returns the resolved value.
			 *
			 * @param {string} path - The full path being resolved, optionally with a JSON pointer in the hash
			 * @param {$RefParserOptions} options
			 * @returns {*} - Returns the resolved value
			 */ $Ref.prototype.get = function(path, options) {
			    return this.resolve(path, options).value;
			};
			/**
			 * Resolves the given JSON reference within this {@link $Ref#value}.
			 *
			 * @param {string} path - The full path being resolved, optionally with a JSON pointer in the hash
			 * @param {$RefParserOptions} options
			 * @param {string} friendlyPath - The original user-specified path (used for error messages)
			 *  @param {string} pathFromRoot - The path of `obj` from the schema root
			 * @returns {Pointer | null}
			 */ $Ref.prototype.resolve = function(path, options, friendlyPath, pathFromRoot) {
			    var pointer = new _pointerJs.default(this, path, friendlyPath);
			    try {
			        return pointer.resolve(this.value, options, pathFromRoot);
			    } catch (err) {
			        if (!options || !options.continueOnError || !(0, _errorsJs.isHandledError)(err)) {
			            throw err;
			        }
			        if (err.path === null) {
			            err.path = (0, _urlJs.safePointerToPath)((0, _urlJs.getHash)(pathFromRoot));
			        }
			        if (_instanceof(err, _errorsJs.InvalidPointerError)) {
			            // this is a special case - InvalidPointerError is thrown when dereferencing external file,
			            // but the issue is caused by the source file that referenced the file that undergoes dereferencing
			            err.source = decodeURI((0, _urlJs.stripHash)(pathFromRoot));
			        }
			        this.addError(err);
			        return null;
			    }
			};
			/**
			 * Sets the value of a nested property within this {@link $Ref#value}.
			 * If the property, or any of its parents don't exist, they will be created.
			 *
			 * @param {string} path - The full path of the property to set, optionally with a JSON pointer in the hash
			 * @param {*} value - The value to assign
			 */ $Ref.prototype.set = function(path, value) {
			    var pointer = new _pointerJs.default(this, path);
			    this.value = pointer.set(this.value, value);
			};
			/**
			 * Determines whether the given value is a JSON reference.
			 *
			 * @param {*} value - The value to inspect
			 * @returns {boolean}
			 */ $Ref.is$Ref = function(value) {
			    return value && typeof value === "object" && typeof value.$ref === "string" && value.$ref.length > 0;
			};
			/**
			 * Determines whether the given value is an external JSON reference.
			 *
			 * @param {*} value - The value to inspect
			 * @returns {boolean}
			 */ $Ref.isExternal$Ref = function(value) {
			    return $Ref.is$Ref(value) && value.$ref[0] !== "#";
			};
			/**
			 * Determines whether the given value is a JSON reference, and whether it is allowed by the options.
			 * For example, if it references an external file, then options.resolve.external must be true.
			 *
			 * @param {*} value - The value to inspect
			 * @param {$RefParserOptions} options
			 * @returns {boolean}
			 */ $Ref.isAllowed$Ref = function(value, options) {
			    if ($Ref.is$Ref(value)) {
			        if (value.$ref.substr(0, 2) === "#/" || value.$ref === "#") {
			            // It's a JSON Pointer reference, which is always allowed
			            return true;
			        } else if (value.$ref[0] !== "#" && (!options || options.resolve.external)) {
			            // It's an external reference, which is allowed by the options
			            return true;
			        }
			    }
			};
			/**
			 * Determines whether the given value is a JSON reference that "extends" its resolved value.
			 * That is, it has extra properties (in addition to "$ref"), so rather than simply pointing to
			 * an existing value, this $ref actually creates a NEW value that is a shallow copy of the resolved
			 * value, plus the extra properties.
			 *
			 * @example:
			 *  {
			 *    person: {
			 *      properties: {
			 *        firstName: { type: string }
			 *        lastName: { type: string }
			 *      }
			 *    }
			 *    employee: {
			 *      properties: {
			 *        $ref: #/person/properties
			 *        salary: { type: number }
			 *      }
			 *    }
			 *  }
			 *
			 *  In this example, "employee" is an extended $ref, since it extends "person" with an additional
			 *  property (salary).  The result is a NEW value that looks like this:
			 *
			 *  {
			 *    properties: {
			 *      firstName: { type: string }
			 *      lastName: { type: string }
			 *      salary: { type: number }
			 *    }
			 *  }
			 *
			 * @param {*} value - The value to inspect
			 * @returns {boolean}
			 */ $Ref.isExtended$Ref = function(value) {
			    return $Ref.is$Ref(value) && Object.keys(value).length > 1;
			};
			/**
			 * Returns the resolved value of a JSON Reference.
			 * If necessary, the resolved value is merged with the JSON Reference to create a new object
			 *
			 * @example:
			 *  {
			 *    person: {
			 *      properties: {
			 *        firstName: { type: string }
			 *        lastName: { type: string }
			 *      }
			 *    }
			 *    employee: {
			 *      properties: {
			 *        $ref: #/person/properties
			 *        salary: { type: number }
			 *      }
			 *    }
			 *  }
			 *
			 *  When "person" and "employee" are merged, you end up with the following object:
			 *
			 *  {
			 *    properties: {
			 *      firstName: { type: string }
			 *      lastName: { type: string }
			 *      salary: { type: number }
			 *    }
			 *  }
			 *
			 * @param {object} $ref - The JSON reference object (the one with the "$ref" property)
			 * @param {*} resolvedValue - The resolved value, which can be any type
			 * @returns {*} - Returns the dereferenced value
			 */ $Ref.dereference = function($ref, resolvedValue) {
			    if (resolvedValue && typeof resolvedValue === "object" && $Ref.isExtended$Ref($ref)) {
			        var merged = {};
			        var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
			        try {
			            for(var _iterator = Object.keys($ref)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
			                var key = _step.value;
			                if (key !== "$ref") {
			                    merged[key] = $ref[key];
			                }
			            }
			        } catch (err) {
			            _didIteratorError = true;
			            _iteratorError = err;
			        } finally{
			            try {
			                if (!_iteratorNormalCompletion && _iterator.return != null) {
			                    _iterator.return();
			                }
			            } finally{
			                if (_didIteratorError) {
			                    throw _iteratorError;
			                }
			            }
			        }
			        var _iteratorNormalCompletion1 = true, _didIteratorError1 = false, _iteratorError1 = undefined;
			        try {
			            for(var _iterator1 = Object.keys(resolvedValue)[Symbol.iterator](), _step1; !(_iteratorNormalCompletion1 = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion1 = true){
			                var key1 = _step1.value;
			                if (!(key1 in merged)) {
			                    merged[key1] = resolvedValue[key1];
			                }
			            }
			        } catch (err) {
			            _didIteratorError1 = true;
			            _iteratorError1 = err;
			        } finally{
			            try {
			                if (!_iteratorNormalCompletion1 && _iterator1.return != null) {
			                    _iterator1.return();
			                }
			            } finally{
			                if (_didIteratorError1) {
			                    throw _iteratorError1;
			                }
			            }
			        }
			        return merged;
			    } else {
			        // Completely replace the original reference with the resolved value
			        return resolvedValue;
			    }
			}; 
		} (ref));
		return ref;
	}

	(function (exports) {
		Object.defineProperty(exports, "__esModule", {
		    value: true
		});
		Object.defineProperty(exports, /**
		 * This class is a map of JSON references and their resolved values.
		 */ "default", {
		    enumerable: true,
		    get: function() {
		        return $Refs;
		    }
		});
		var _ono = require$$9;
		var _refJs = /*#__PURE__*/ _interopRequireDefault(requireRef());
		var _urlJs = /*#__PURE__*/ _interopRequireWildcard(url);
		function _interopRequireDefault(obj) {
		    return obj && obj.__esModule ? obj : {
		        default: obj
		    };
		}
		function _getRequireWildcardCache(nodeInterop) {
		    if (typeof WeakMap !== "function") return null;
		    var cacheBabelInterop = new WeakMap();
		    var cacheNodeInterop = new WeakMap();
		    return (_getRequireWildcardCache = function(nodeInterop) {
		        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
		    })(nodeInterop);
		}
		function _interopRequireWildcard(obj, nodeInterop) {
		    if (obj && obj.__esModule) {
		        return obj;
		    }
		    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
		        return {
		            default: obj
		        };
		    }
		    var cache = _getRequireWildcardCache(nodeInterop);
		    if (cache && cache.has(obj)) {
		        return cache.get(obj);
		    }
		    var newObj = {};
		    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
		    for(var key in obj){
		        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
		            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
		            if (desc && (desc.get || desc.set)) {
		                Object.defineProperty(newObj, key, desc);
		            } else {
		                newObj[key] = obj[key];
		            }
		        }
		    }
		    newObj.default = obj;
		    if (cache) {
		        cache.set(obj, newObj);
		    }
		    return newObj;
		}
		var isWindows = /^win/.test(globalThis.process ? globalThis.process.platform : undefined);
		var getPathFromOs = function(filePath) {
		    return isWindows ? filePath.replace(/\\/g, "/") : filePath;
		};
		function $Refs() {
		    /**
		   * Indicates whether the schema contains any circular references.
		   *
		   * @type {boolean}
		   */ this.circular = false;
		    /**
		   * A map of paths/urls to {@link $Ref} objects
		   *
		   * @type {object}
		   * @protected
		   */ this._$refs = {};
		    /**
		   * The {@link $Ref} object that is the root of the JSON schema.
		   *
		   * @type {$Ref}
		   * @protected
		   */ this._root$Ref = null;
		}
		/**
		 * Returns the paths of all the files/URLs that are referenced by the JSON schema,
		 * including the schema itself.
		 *
		 * @param {...string|string[]} [types] - Only return paths of the given types ("file", "http", etc.)
		 * @returns {string[]}
		 */ $Refs.prototype.paths = function(types) {
		    var paths = getPaths(this._$refs, arguments);
		    return paths.map(function(path) {
		        return getPathFromOs(path.decoded);
		    });
		};
		/**
		 * Returns the map of JSON references and their resolved values.
		 *
		 * @param {...string|string[]} [types] - Only return references of the given types ("file", "http", etc.)
		 * @returns {object}
		 */ $Refs.prototype.values = function(types) {
		    var $refs = this._$refs;
		    var paths = getPaths($refs, arguments);
		    return paths.reduce(function(obj, path) {
		        obj[getPathFromOs(path.decoded)] = $refs[path.encoded].value;
		        return obj;
		    }, {});
		};
		/**
		 * Returns a POJO (plain old JavaScript object) for serialization as JSON.
		 *
		 * @returns {object}
		 */ $Refs.prototype.toJSON = $Refs.prototype.values;
		/**
		 * Determines whether the given JSON reference exists.
		 *
		 * @param {string} path - The path being resolved, optionally with a JSON pointer in the hash
		 * @param {$RefParserOptions} [options]
		 * @returns {boolean}
		 */ $Refs.prototype.exists = function(path, options) {
		    try {
		        this._resolve(path, "", options);
		        return true;
		    } catch (e) {
		        return false;
		    }
		};
		/**
		 * Resolves the given JSON reference and returns the resolved value.
		 *
		 * @param {string} path - The path being resolved, with a JSON pointer in the hash
		 * @param {$RefParserOptions} [options]
		 * @returns {*} - Returns the resolved value
		 */ $Refs.prototype.get = function(path, options) {
		    return this._resolve(path, "", options).value;
		};
		/**
		 * Sets the value of a nested property within this {@link $Ref#value}.
		 * If the property, or any of its parents don't exist, they will be created.
		 *
		 * @param {string} path - The path of the property to set, optionally with a JSON pointer in the hash
		 * @param {*} value - The value to assign
		 */ $Refs.prototype.set = function(path, value) {
		    var absPath = _urlJs.resolve(this._root$Ref.path, path);
		    var withoutHash = _urlJs.stripHash(absPath);
		    var $ref = this._$refs[withoutHash];
		    if (!$ref) {
		        throw (0, _ono.ono)('Error resolving $ref pointer "'.concat(path, '". \n"').concat(withoutHash, '" not found.'));
		    }
		    $ref.set(absPath, value);
		};
		/**
		 * Creates a new {@link $Ref} object and adds it to this {@link $Refs} object.
		 *
		 * @param {string} path  - The file path or URL of the referenced file
		 */ $Refs.prototype._add = function(path) {
		    var withoutHash = _urlJs.stripHash(path);
		    var $ref = new _refJs.default();
		    $ref.path = withoutHash;
		    $ref.$refs = this;
		    this._$refs[withoutHash] = $ref;
		    this._root$Ref = this._root$Ref || $ref;
		    return $ref;
		};
		/**
		 * Resolves the given JSON reference.
		 *
		 * @param {string} path - The path being resolved, optionally with a JSON pointer in the hash
		 * @param {string} pathFromRoot - The path of `obj` from the schema root
		 * @param {$RefParserOptions} [options]
		 * @returns {Pointer}
		 * @protected
		 */ $Refs.prototype._resolve = function(path, pathFromRoot, options) {
		    var absPath = _urlJs.resolve(this._root$Ref.path, path);
		    var withoutHash = _urlJs.stripHash(absPath);
		    var $ref = this._$refs[withoutHash];
		    if (!$ref) {
		        throw (0, _ono.ono)('Error resolving $ref pointer "'.concat(path, '". \n"').concat(withoutHash, '" not found.'));
		    }
		    return $ref.resolve(absPath, options, path, pathFromRoot);
		};
		/**
		 * Returns the specified {@link $Ref} object, or undefined.
		 *
		 * @param {string} path - The path being resolved, optionally with a JSON pointer in the hash
		 * @returns {$Ref|undefined}
		 * @protected
		 */ $Refs.prototype._get$Ref = function(path) {
		    path = _urlJs.resolve(this._root$Ref.path, path);
		    var withoutHash = _urlJs.stripHash(path);
		    return this._$refs[withoutHash];
		};
		/**
		 * Returns the encoded and decoded paths keys of the given object.
		 *
		 * @param {object} $refs - The object whose keys are URL-encoded paths
		 * @param {...string|string[]} [types] - Only return paths of the given types ("file", "http", etc.)
		 * @returns {object[]}
		 */ function getPaths($refs, types) {
		    var paths = Object.keys($refs);
		    // Filter the paths by type
		    types = Array.isArray(types[0]) ? types[0] : Array.prototype.slice.call(types);
		    if (types.length > 0 && types[0]) {
		        paths = paths.filter(function(key) {
		            return types.indexOf($refs[key].pathType) !== -1;
		        });
		    }
		    // Decode local filesystem paths
		    return paths.map(function(path) {
		        return {
		            encoded: path,
		            decoded: $refs[path].pathType === "file" ? _urlJs.toFileSystemPath(path, true) : path
		        };
		    });
		} 
	} (refs));

	var parse = {};

	var plugins = {};

	/**
	 * Returns the given plugins as an array, rather than an object map.
	 * All other methods in this module expect an array of plugins rather than an object map.
	 *
	 * @param  {object} plugins - A map of plugin objects
	 * @return {object[]}
	 */

	(function (exports) {
		Object.defineProperty(exports, "__esModule", {
		    value: true
		});
		function _export(target, all) {
		    for(var name in all)Object.defineProperty(target, name, {
		        enumerable: true,
		        get: all[name]
		    });
		}
		_export(exports, {
		    all: function() {
		        return all;
		    },
		    filter: function() {
		        return filter;
		    },
		    sort: function() {
		        return sort;
		    },
		    run: function() {
		        return run;
		    }
		});
		function _instanceof(left, right) {
		    if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) {
		        return !!right[Symbol.hasInstance](left);
		    } else {
		        return left instanceof right;
		    }
		}
		function all(plugins) {
		    return Object.keys(plugins).filter(function(key) {
		        return typeof plugins[key] === "object";
		    }).map(function(key) {
		        plugins[key].name = key;
		        return plugins[key];
		    });
		}
		function filter(plugins, method, file) {
		    return plugins.filter(function(plugin) {
		        return !!getResult(plugin, method, file);
		    });
		}
		function sort(plugins) {
		    var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
		    try {
		        for(var _iterator = plugins[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
		            var plugin = _step.value;
		            plugin.order = plugin.order || Number.MAX_SAFE_INTEGER;
		        }
		    } catch (err) {
		        _didIteratorError = true;
		        _iteratorError = err;
		    } finally{
		        try {
		            if (!_iteratorNormalCompletion && _iterator.return != null) {
		                _iterator.return();
		            }
		        } finally{
		            if (_didIteratorError) {
		                throw _iteratorError;
		            }
		        }
		    }
		    return plugins.sort(function(a, b) {
		        return a.order - b.order;
		    });
		}
		function run(plugins, method, file, $refs) {
		    var plugin, lastError, index = 0;
		    return new Promise(function(resolve, reject) {
		        var runNextPlugin = function runNextPlugin() {
		            plugin = plugins[index++];
		            if (!plugin) {
		                // There are no more functions, so re-throw the last error
		                return reject(lastError);
		            }
		            try {
		                // console.log('  %s', plugin.name);
		                var result = getResult(plugin, method, file, callback, $refs);
		                if (result && typeof result.then === "function") {
		                    // A promise was returned
		                    result.then(onSuccess, onError);
		                } else if (result !== undefined) {
		                    // A synchronous result was returned
		                    onSuccess(result);
		                } else if (index === plugins.length) {
		                    throw new Error("No promise has been returned or callback has been called.");
		                }
		            } catch (e) {
		                onError(e);
		            }
		        };
		        var callback = function callback(err, result) {
		            if (err) {
		                onError(err);
		            } else {
		                onSuccess(result);
		            }
		        };
		        var onSuccess = function onSuccess(result) {
		            // console.log('    success');
		            resolve({
		                plugin: plugin,
		                result: result
		            });
		        };
		        var onError = function onError(error) {
		            // console.log('    %s', err.message || err);
		            lastError = {
		                plugin: plugin,
		                error: error
		            };
		            runNextPlugin();
		        };
		        runNextPlugin();
		    });
		}
		/**
		 * Returns the value of the given property.
		 * If the property is a function, then the result of the function is returned.
		 * If the value is a RegExp, then it will be tested against the file URL.
		 * If the value is an aray, then it will be compared against the file extension.
		 *
		 * @param   {object}   obj        - The object whose property/method is called
		 * @param   {string}   prop       - The name of the property/method to invoke
		 * @param   {object}   file       - A file info object, which will be passed to the method
		 * @param   {function} [callback] - A callback function, which will be passed to the method
		 * @returns {*}
		 */ function getResult(obj, prop, file, callback, $refs) {
		    var value = obj[prop];
		    if (typeof value === "function") {
		        return value.apply(obj, [
		            file,
		            callback,
		            $refs
		        ]);
		    }
		    if (!callback) {
		        // The synchronous plugin functions (canParse and canRead)
		        // allow a "shorthand" syntax, where the user can match
		        // files by RegExp or by file extension.
		        if (_instanceof(value, RegExp)) {
		            return value.test(file.url);
		        } else if (typeof value === "string") {
		            return value === file.extension;
		        } else if (Array.isArray(value)) {
		            return value.indexOf(file.extension) !== -1;
		        }
		    }
		    return value;
		} 
	} (plugins));

	(function (exports) {
		Object.defineProperty(exports, "__esModule", {
		    value: true
		});
		Object.defineProperty(exports, "default", {
		    enumerable: true,
		    get: function() {
		        return _default;
		    }
		});
		var _ono = require$$9;
		var _urlJs = /*#__PURE__*/ _interopRequireWildcard(url);
		var _pluginsJs = /*#__PURE__*/ _interopRequireWildcard(plugins);
		var _errorsJs = errors;
		function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
		    try {
		        var info = gen[key](arg);
		        var value = info.value;
		    } catch (error) {
		        reject(error);
		        return;
		    }
		    if (info.done) {
		        resolve(value);
		    } else {
		        Promise.resolve(value).then(_next, _throw);
		    }
		}
		function _asyncToGenerator(fn) {
		    return function() {
		        var self = this, args = arguments;
		        return new Promise(function(resolve, reject) {
		            var gen = fn.apply(self, args);
		            function _next(value) {
		                asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
		            }
		            function _throw(err) {
		                asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
		            }
		            _next(undefined);
		        });
		    };
		}
		function _instanceof(left, right) {
		    if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) {
		        return !!right[Symbol.hasInstance](left);
		    } else {
		        return left instanceof right;
		    }
		}
		function _getRequireWildcardCache(nodeInterop) {
		    if (typeof WeakMap !== "function") return null;
		    var cacheBabelInterop = new WeakMap();
		    var cacheNodeInterop = new WeakMap();
		    return (_getRequireWildcardCache = function(nodeInterop) {
		        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
		    })(nodeInterop);
		}
		function _interopRequireWildcard(obj, nodeInterop) {
		    if (obj && obj.__esModule) {
		        return obj;
		    }
		    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
		        return {
		            default: obj
		        };
		    }
		    var cache = _getRequireWildcardCache(nodeInterop);
		    if (cache && cache.has(obj)) {
		        return cache.get(obj);
		    }
		    var newObj = {};
		    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
		    for(var key in obj){
		        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
		            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
		            if (desc && (desc.get || desc.set)) {
		                Object.defineProperty(newObj, key, desc);
		            } else {
		                newObj[key] = obj[key];
		            }
		        }
		    }
		    newObj.default = obj;
		    if (cache) {
		        cache.set(obj, newObj);
		    }
		    return newObj;
		}
		var __generator = function(thisArg, body) {
		    var f, y, t, g, _ = {
		        label: 0,
		        sent: function() {
		            if (t[0] & 1) throw t[1];
		            return t[1];
		        },
		        trys: [],
		        ops: []
		    };
		    return g = {
		        next: verb(0),
		        "throw": verb(1),
		        "return": verb(2)
		    }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
		        return this;
		    }), g;
		    function verb(n) {
		        return function(v) {
		            return step([
		                n,
		                v
		            ]);
		        };
		    }
		    function step(op) {
		        if (f) throw new TypeError("Generator is already executing.");
		        while(_)try {
		            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
		            if (y = 0, t) op = [
		                op[0] & 2,
		                t.value
		            ];
		            switch(op[0]){
		                case 0:
		                case 1:
		                    t = op;
		                    break;
		                case 4:
		                    _.label++;
		                    return {
		                        value: op[1],
		                        done: false
		                    };
		                case 5:
		                    _.label++;
		                    y = op[1];
		                    op = [
		                        0
		                    ];
		                    continue;
		                case 7:
		                    op = _.ops.pop();
		                    _.trys.pop();
		                    continue;
		                default:
		                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
		                        _ = 0;
		                        continue;
		                    }
		                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
		                        _.label = op[1];
		                        break;
		                    }
		                    if (op[0] === 6 && _.label < t[1]) {
		                        _.label = t[1];
		                        t = op;
		                        break;
		                    }
		                    if (t && _.label < t[2]) {
		                        _.label = t[2];
		                        _.ops.push(op);
		                        break;
		                    }
		                    if (t[2]) _.ops.pop();
		                    _.trys.pop();
		                    continue;
		            }
		            op = body.call(thisArg, _);
		        } catch (e) {
		            op = [
		                6,
		                e
		            ];
		            y = 0;
		        } finally{
		            f = t = 0;
		        }
		        if (op[0] & 5) throw op[1];
		        return {
		            value: op[0] ? op[1] : void 0,
		            done: true
		        };
		    }
		};
		var _default = parse;
		function parse(path, $refs, options) {
		    return _parse.apply(this, arguments);
		}
		function _parse() {
		    _parse = /**
		 * Reads and parses the specified file path or URL.
		 *
		 * @param {string} path - This path MUST already be resolved, since `read` doesn't know the resolution context
		 * @param {$Refs} $refs
		 * @param {$RefParserOptions} options
		 *
		 * @returns {Promise}
		 * The promise resolves with the parsed file contents, NOT the raw (Buffer) contents.
		 */ _asyncToGenerator(function(path, $refs, options) {
		        var $ref, file, resolver, parser, err;
		        return __generator(this, function(_state) {
		            switch(_state.label){
		                case 0:
		                    // Remove the URL fragment, if any
		                    path = _urlJs.stripHash(path);
		                    $ref = $refs._add(path);
		                    file = {
		                        url: path,
		                        extension: _urlJs.getExtension(path)
		                    };
		                    _state.label = 1;
		                case 1:
		                    _state.trys.push([
		                        1,
		                        4,
		                        ,
		                        5
		                    ]);
		                    return [
		                        4,
		                        readFile(file, options, $refs)
		                    ];
		                case 2:
		                    resolver = _state.sent();
		                    $ref.pathType = resolver.plugin.name;
		                    file.data = resolver.result;
		                    return [
		                        4,
		                        parseFile(file, options, $refs)
		                    ];
		                case 3:
		                    parser = _state.sent();
		                    $ref.value = parser.result;
		                    return [
		                        2,
		                        parser.result
		                    ];
		                case 4:
		                    err = _state.sent();
		                    if ((0, _errorsJs.isHandledError)(err)) {
		                        $ref.value = err;
		                    }
		                    throw err;
		                case 5:
		                    return [
		                        2
		                    ];
		            }
		        });
		    });
		    return _parse.apply(this, arguments);
		}
		/**
		 * Reads the given file, using the configured resolver plugins
		 *
		 * @param {object} file           - An object containing information about the referenced file
		 * @param {string} file.url       - The full URL of the referenced file
		 * @param {string} file.extension - The lowercased file extension (e.g. ".txt", ".html", etc.)
		 * @param {$RefParserOptions} options
		 *
		 * @returns {Promise}
		 * The promise resolves with the raw file contents and the resolver that was used.
		 */ function readFile(file, options, $refs) {
		    return new Promise(function(resolve, reject) {
		        var onError = function onError(err) {
		            if (!err && options.continueOnError) {
		                // No resolver could be matched
		                reject(new _errorsJs.UnmatchedResolverError(file.url));
		            } else if (!err || !("error" in err)) {
		                // Throw a generic, friendly error.
		                reject(_ono.ono.syntax('Unable to resolve $ref pointer "'.concat(file.url, '"')));
		            } else if (_instanceof(err.error, _errorsJs.ResolverError)) {
		                reject(err.error);
		            } else {
		                reject(new _errorsJs.ResolverError(err, file.url));
		            }
		        };
		        // console.log('Reading %s', file.url);
		        // Find the resolvers that can read this file
		        var resolvers = _pluginsJs.all(options.resolve);
		        resolvers = _pluginsJs.filter(resolvers, "canRead", file);
		        // Run the resolvers, in order, until one of them succeeds
		        _pluginsJs.sort(resolvers);
		        _pluginsJs.run(resolvers, "read", file, $refs).then(resolve, onError);
		    });
		}
		/**
		 * Parses the given file's contents, using the configured parser plugins.
		 *
		 * @param {object} file           - An object containing information about the referenced file
		 * @param {string} file.url       - The full URL of the referenced file
		 * @param {string} file.extension - The lowercased file extension (e.g. ".txt", ".html", etc.)
		 * @param {*}      file.data      - The file contents. This will be whatever data type was returned by the resolver
		 * @param {$RefParserOptions} options
		 *
		 * @returns {Promise}
		 * The promise resolves with the parsed file contents and the parser that was used.
		 */ function parseFile(file, options, $refs) {
		    return new Promise(function(resolve, reject) {
		        var onParsed = function onParsed(parser) {
		            if (!parser.plugin.allowEmpty && isEmpty(parser.result)) {
		                reject(_ono.ono.syntax('Error parsing "'.concat(file.url, '" as ').concat(parser.plugin.name, ". \nParsed value is empty")));
		            } else {
		                resolve(parser);
		            }
		        };
		        var onError = function onError(err) {
		            if (!err && options.continueOnError) {
		                // No resolver could be matched
		                reject(new _errorsJs.UnmatchedParserError(file.url));
		            } else if (!err || !("error" in err)) {
		                reject(_ono.ono.syntax("Unable to parse ".concat(file.url)));
		            } else if (_instanceof(err.error, _errorsJs.ParserError)) {
		                reject(err.error);
		            } else {
		                reject(new _errorsJs.ParserError(err.error.message, file.url));
		            }
		        };
		        // console.log('Parsing %s', file.url);
		        // Find the parsers that can read this file type.
		        // If none of the parsers are an exact match for this file, then we'll try ALL of them.
		        // This handles situations where the file IS a supported type, just with an unknown extension.
		        var allParsers = _pluginsJs.all(options.parse);
		        var filteredParsers = _pluginsJs.filter(allParsers, "canParse", file);
		        var parsers = filteredParsers.length > 0 ? filteredParsers : allParsers;
		        // Run the parsers, in order, until one of them succeeds
		        _pluginsJs.sort(parsers);
		        _pluginsJs.run(parsers, "parse", file, $refs).then(onParsed, onError);
		    });
		}
		/**
		 * Determines whether the parsed value is "empty".
		 *
		 * @param {*} value
		 * @returns {boolean}
		 */ function isEmpty(value) {
		    return value === undefined || typeof value === "object" && Object.keys(value).length === 0 || typeof value === "string" && value.trim().length === 0 || Buffer.isBuffer(value) && value.length === 0;
		} 
	} (parse));

	var normalizeArgs = {};

	var options$1 = {};

	var json$1 = {};

	(function (exports) {
		Object.defineProperty(exports, "__esModule", {
		    value: true
		});
		Object.defineProperty(exports, "default", {
		    enumerable: true,
		    get: function() {
		        return _default;
		    }
		});
		var _errorsJs = errors;
		function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
		    try {
		        var info = gen[key](arg);
		        var value = info.value;
		    } catch (error) {
		        reject(error);
		        return;
		    }
		    if (info.done) {
		        resolve(value);
		    } else {
		        Promise.resolve(value).then(_next, _throw);
		    }
		}
		function _asyncToGenerator(fn) {
		    return function() {
		        var self = this, args = arguments;
		        return new Promise(function(resolve, reject) {
		            var gen = fn.apply(self, args);
		            function _next(value) {
		                asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
		            }
		            function _throw(err) {
		                asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
		            }
		            _next(undefined);
		        });
		    };
		}
		var __generator = function(thisArg, body) {
		    var f, y, t, g, _ = {
		        label: 0,
		        sent: function() {
		            if (t[0] & 1) throw t[1];
		            return t[1];
		        },
		        trys: [],
		        ops: []
		    };
		    return g = {
		        next: verb(0),
		        "throw": verb(1),
		        "return": verb(2)
		    }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
		        return this;
		    }), g;
		    function verb(n) {
		        return function(v) {
		            return step([
		                n,
		                v
		            ]);
		        };
		    }
		    function step(op) {
		        if (f) throw new TypeError("Generator is already executing.");
		        while(_)try {
		            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
		            if (y = 0, t) op = [
		                op[0] & 2,
		                t.value
		            ];
		            switch(op[0]){
		                case 0:
		                case 1:
		                    t = op;
		                    break;
		                case 4:
		                    _.label++;
		                    return {
		                        value: op[1],
		                        done: false
		                    };
		                case 5:
		                    _.label++;
		                    y = op[1];
		                    op = [
		                        0
		                    ];
		                    continue;
		                case 7:
		                    op = _.ops.pop();
		                    _.trys.pop();
		                    continue;
		                default:
		                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
		                        _ = 0;
		                        continue;
		                    }
		                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
		                        _.label = op[1];
		                        break;
		                    }
		                    if (op[0] === 6 && _.label < t[1]) {
		                        _.label = t[1];
		                        t = op;
		                        break;
		                    }
		                    if (t && _.label < t[2]) {
		                        _.label = t[2];
		                        _.ops.push(op);
		                        break;
		                    }
		                    if (t[2]) _.ops.pop();
		                    _.trys.pop();
		                    continue;
		            }
		            op = body.call(thisArg, _);
		        } catch (e) {
		            op = [
		                6,
		                e
		            ];
		            y = 0;
		        } finally{
		            f = t = 0;
		        }
		        if (op[0] & 5) throw op[1];
		        return {
		            value: op[0] ? op[1] : void 0,
		            done: true
		        };
		    }
		};
		var _default = {
		    /**
		   * The order that this parser will run, in relation to other parsers.
		   *
		   * @type {number}
		   */ order: 100,
		    /**
		   * Whether to allow "empty" files. This includes zero-byte files, as well as empty JSON objects.
		   *
		   * @type {boolean}
		   */ allowEmpty: true,
		    /**
		   * Determines whether this parser can parse a given file reference.
		   * Parsers that match will be tried, in order, until one successfully parses the file.
		   * Parsers that don't match will be skipped, UNLESS none of the parsers match, in which case
		   * every parser will be tried.
		   *
		   * @type {RegExp|string|string[]|function}
		   */ canParse: ".json",
		    parse: /**
		   * Parses the given file as JSON
		   *
		   * @param {object} file           - An object containing information about the referenced file
		   * @param {string} file.url       - The full URL of the referenced file
		   * @param {string} file.extension - The lowercased file extension (e.g. ".txt", ".html", etc.)
		   * @param {*}      file.data      - The file contents. This will be whatever data type was returned by the resolver
		   * @returns {Promise}
		   */ function parse(file) {
		        return _asyncToGenerator(function() {
		            var data;
		            return __generator(this, function(_state) {
		                data = file.data;
		                if (Buffer.isBuffer(data)) {
		                    data = data.toString();
		                }
		                if (typeof data === "string") {
		                    if (data.trim().length === 0) {
		                        return [
		                            2
		                        ]; // This mirrors the YAML behavior
		                    } else {
		                        try {
		                            return [
		                                2,
		                                JSON.parse(data)
		                            ];
		                        } catch (e) {
		                            throw new _errorsJs.ParserError(e.message, file.url);
		                        }
		                    }
		                } else {
		                    // data is already a JavaScript value (object, array, number, null, NaN, etc.)
		                    return [
		                        2,
		                        data
		                    ];
		                }
		                return [
		                    2
		                ];
		            });
		        })();
		    }
		}; 
	} (json$1));

	var yaml = {};

	var jsYaml = {};

	var loader$1 = {};

	var common$5 = {};

	function isNothing(subject) {
	  return (typeof subject === 'undefined') || (subject === null);
	}


	function isObject(subject) {
	  return (typeof subject === 'object') && (subject !== null);
	}


	function toArray(sequence) {
	  if (Array.isArray(sequence)) return sequence;
	  else if (isNothing(sequence)) return [];

	  return [ sequence ];
	}


	function extend(target, source) {
	  var index, length, key, sourceKeys;

	  if (source) {
	    sourceKeys = Object.keys(source);

	    for (index = 0, length = sourceKeys.length; index < length; index += 1) {
	      key = sourceKeys[index];
	      target[key] = source[key];
	    }
	  }

	  return target;
	}


	function repeat(string, count) {
	  var result = '', cycle;

	  for (cycle = 0; cycle < count; cycle += 1) {
	    result += string;
	  }

	  return result;
	}


	function isNegativeZero(number) {
	  return (number === 0) && (Number.NEGATIVE_INFINITY === 1 / number);
	}


	common$5.isNothing      = isNothing;
	common$5.isObject       = isObject;
	common$5.toArray        = toArray;
	common$5.repeat         = repeat;
	common$5.isNegativeZero = isNegativeZero;
	common$5.extend         = extend;

	function formatError(exception, compact) {
	  var where = '', message = exception.reason || '(unknown reason)';

	  if (!exception.mark) return message;

	  if (exception.mark.name) {
	    where += 'in "' + exception.mark.name + '" ';
	  }

	  where += '(' + (exception.mark.line + 1) + ':' + (exception.mark.column + 1) + ')';

	  if (!compact && exception.mark.snippet) {
	    where += '\n\n' + exception.mark.snippet;
	  }

	  return message + ' ' + where;
	}


	function YAMLException$4(reason, mark) {
	  // Super constructor
	  Error.call(this);

	  this.name = 'YAMLException';
	  this.reason = reason;
	  this.mark = mark;
	  this.message = formatError(this, false);

	  // Include stack trace in error object
	  if (Error.captureStackTrace) {
	    // Chrome and NodeJS
	    Error.captureStackTrace(this, this.constructor);
	  } else {
	    // FF, IE 10+ and Safari 6+. Fallback for others
	    this.stack = (new Error()).stack || '';
	  }
	}


	// Inherit from Error
	YAMLException$4.prototype = Object.create(Error.prototype);
	YAMLException$4.prototype.constructor = YAMLException$4;


	YAMLException$4.prototype.toString = function toString(compact) {
	  return this.name + ': ' + formatError(this, compact);
	};


	var exception = YAMLException$4;

	var common$4 = common$5;


	// get snippet for a single line, respecting maxLength
	function getLine(buffer, lineStart, lineEnd, position, maxLineLength) {
	  var head = '';
	  var tail = '';
	  var maxHalfLength = Math.floor(maxLineLength / 2) - 1;

	  if (position - lineStart > maxHalfLength) {
	    head = ' ... ';
	    lineStart = position - maxHalfLength + head.length;
	  }

	  if (lineEnd - position > maxHalfLength) {
	    tail = ' ...';
	    lineEnd = position + maxHalfLength - tail.length;
	  }

	  return {
	    str: head + buffer.slice(lineStart, lineEnd).replace(/\t/g, '') + tail,
	    pos: position - lineStart + head.length // relative position
	  };
	}


	function padStart(string, max) {
	  return common$4.repeat(' ', max - string.length) + string;
	}


	function makeSnippet$1(mark, options) {
	  options = Object.create(options || null);

	  if (!mark.buffer) return null;

	  if (!options.maxLength) options.maxLength = 79;
	  if (typeof options.indent      !== 'number') options.indent      = 1;
	  if (typeof options.linesBefore !== 'number') options.linesBefore = 3;
	  if (typeof options.linesAfter  !== 'number') options.linesAfter  = 2;

	  var re = /\r?\n|\r|\0/g;
	  var lineStarts = [ 0 ];
	  var lineEnds = [];
	  var match;
	  var foundLineNo = -1;

	  while ((match = re.exec(mark.buffer))) {
	    lineEnds.push(match.index);
	    lineStarts.push(match.index + match[0].length);

	    if (mark.position <= match.index && foundLineNo < 0) {
	      foundLineNo = lineStarts.length - 2;
	    }
	  }

	  if (foundLineNo < 0) foundLineNo = lineStarts.length - 1;

	  var result = '', i, line;
	  var lineNoLength = Math.min(mark.line + options.linesAfter, lineEnds.length).toString().length;
	  var maxLineLength = options.maxLength - (options.indent + lineNoLength + 3);

	  for (i = 1; i <= options.linesBefore; i++) {
	    if (foundLineNo - i < 0) break;
	    line = getLine(
	      mark.buffer,
	      lineStarts[foundLineNo - i],
	      lineEnds[foundLineNo - i],
	      mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo - i]),
	      maxLineLength
	    );
	    result = common$4.repeat(' ', options.indent) + padStart((mark.line - i + 1).toString(), lineNoLength) +
	      ' | ' + line.str + '\n' + result;
	  }

	  line = getLine(mark.buffer, lineStarts[foundLineNo], lineEnds[foundLineNo], mark.position, maxLineLength);
	  result += common$4.repeat(' ', options.indent) + padStart((mark.line + 1).toString(), lineNoLength) +
	    ' | ' + line.str + '\n';
	  result += common$4.repeat('-', options.indent + lineNoLength + 3 + line.pos) + '^' + '\n';

	  for (i = 1; i <= options.linesAfter; i++) {
	    if (foundLineNo + i >= lineEnds.length) break;
	    line = getLine(
	      mark.buffer,
	      lineStarts[foundLineNo + i],
	      lineEnds[foundLineNo + i],
	      mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo + i]),
	      maxLineLength
	    );
	    result += common$4.repeat(' ', options.indent) + padStart((mark.line + i + 1).toString(), lineNoLength) +
	      ' | ' + line.str + '\n';
	  }

	  return result.replace(/\n$/, '');
	}


	var snippet = makeSnippet$1;

	var YAMLException$3 = exception;

	var TYPE_CONSTRUCTOR_OPTIONS = [
	  'kind',
	  'multi',
	  'resolve',
	  'construct',
	  'instanceOf',
	  'predicate',
	  'represent',
	  'representName',
	  'defaultStyle',
	  'styleAliases'
	];

	var YAML_NODE_KINDS = [
	  'scalar',
	  'sequence',
	  'mapping'
	];

	function compileStyleAliases(map) {
	  var result = {};

	  if (map !== null) {
	    Object.keys(map).forEach(function (style) {
	      map[style].forEach(function (alias) {
	        result[String(alias)] = style;
	      });
	    });
	  }

	  return result;
	}

	function Type$e(tag, options) {
	  options = options || {};

	  Object.keys(options).forEach(function (name) {
	    if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1) {
	      throw new YAMLException$3('Unknown option "' + name + '" is met in definition of "' + tag + '" YAML type.');
	    }
	  });

	  // TODO: Add tag format check.
	  this.options       = options; // keep original options in case user wants to extend this type later
	  this.tag           = tag;
	  this.kind          = options['kind']          || null;
	  this.resolve       = options['resolve']       || function () { return true; };
	  this.construct     = options['construct']     || function (data) { return data; };
	  this.instanceOf    = options['instanceOf']    || null;
	  this.predicate     = options['predicate']     || null;
	  this.represent     = options['represent']     || null;
	  this.representName = options['representName'] || null;
	  this.defaultStyle  = options['defaultStyle']  || null;
	  this.multi         = options['multi']         || false;
	  this.styleAliases  = compileStyleAliases(options['styleAliases'] || null);

	  if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {
	    throw new YAMLException$3('Unknown kind "' + this.kind + '" is specified for "' + tag + '" YAML type.');
	  }
	}

	var type = Type$e;

	/*eslint-disable max-len*/

	var YAMLException$2 = exception;
	var Type$d          = type;


	function compileList(schema, name) {
	  var result = [];

	  schema[name].forEach(function (currentType) {
	    var newIndex = result.length;

	    result.forEach(function (previousType, previousIndex) {
	      if (previousType.tag === currentType.tag &&
	          previousType.kind === currentType.kind &&
	          previousType.multi === currentType.multi) {

	        newIndex = previousIndex;
	      }
	    });

	    result[newIndex] = currentType;
	  });

	  return result;
	}


	function compileMap(/* lists... */) {
	  var result = {
	        scalar: {},
	        sequence: {},
	        mapping: {},
	        fallback: {},
	        multi: {
	          scalar: [],
	          sequence: [],
	          mapping: [],
	          fallback: []
	        }
	      }, index, length;

	  function collectType(type) {
	    if (type.multi) {
	      result.multi[type.kind].push(type);
	      result.multi['fallback'].push(type);
	    } else {
	      result[type.kind][type.tag] = result['fallback'][type.tag] = type;
	    }
	  }

	  for (index = 0, length = arguments.length; index < length; index += 1) {
	    arguments[index].forEach(collectType);
	  }
	  return result;
	}


	function Schema$1(definition) {
	  return this.extend(definition);
	}


	Schema$1.prototype.extend = function extend(definition) {
	  var implicit = [];
	  var explicit = [];

	  if (definition instanceof Type$d) {
	    // Schema.extend(type)
	    explicit.push(definition);

	  } else if (Array.isArray(definition)) {
	    // Schema.extend([ type1, type2, ... ])
	    explicit = explicit.concat(definition);

	  } else if (definition && (Array.isArray(definition.implicit) || Array.isArray(definition.explicit))) {
	    // Schema.extend({ explicit: [ type1, type2, ... ], implicit: [ type1, type2, ... ] })
	    if (definition.implicit) implicit = implicit.concat(definition.implicit);
	    if (definition.explicit) explicit = explicit.concat(definition.explicit);

	  } else {
	    throw new YAMLException$2('Schema.extend argument should be a Type, [ Type ], ' +
	      'or a schema definition ({ implicit: [...], explicit: [...] })');
	  }

	  implicit.forEach(function (type) {
	    if (!(type instanceof Type$d)) {
	      throw new YAMLException$2('Specified list of YAML types (or a single Type object) contains a non-Type object.');
	    }

	    if (type.loadKind && type.loadKind !== 'scalar') {
	      throw new YAMLException$2('There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.');
	    }

	    if (type.multi) {
	      throw new YAMLException$2('There is a multi type in the implicit list of a schema. Multi tags can only be listed as explicit.');
	    }
	  });

	  explicit.forEach(function (type) {
	    if (!(type instanceof Type$d)) {
	      throw new YAMLException$2('Specified list of YAML types (or a single Type object) contains a non-Type object.');
	    }
	  });

	  var result = Object.create(Schema$1.prototype);

	  result.implicit = (this.implicit || []).concat(implicit);
	  result.explicit = (this.explicit || []).concat(explicit);

	  result.compiledImplicit = compileList(result, 'implicit');
	  result.compiledExplicit = compileList(result, 'explicit');
	  result.compiledTypeMap  = compileMap(result.compiledImplicit, result.compiledExplicit);

	  return result;
	};


	var schema = Schema$1;

	var Type$c = type;

	var str = new Type$c('tag:yaml.org,2002:str', {
	  kind: 'scalar',
	  construct: function (data) { return data !== null ? data : ''; }
	});

	var Type$b = type;

	var seq = new Type$b('tag:yaml.org,2002:seq', {
	  kind: 'sequence',
	  construct: function (data) { return data !== null ? data : []; }
	});

	var Type$a = type;

	var map = new Type$a('tag:yaml.org,2002:map', {
	  kind: 'mapping',
	  construct: function (data) { return data !== null ? data : {}; }
	});

	var Schema = schema;


	var failsafe = new Schema({
	  explicit: [
	    str,
	    seq,
	    map
	  ]
	});

	var Type$9 = type;

	function resolveYamlNull(data) {
	  if (data === null) return true;

	  var max = data.length;

	  return (max === 1 && data === '~') ||
	         (max === 4 && (data === 'null' || data === 'Null' || data === 'NULL'));
	}

	function constructYamlNull() {
	  return null;
	}

	function isNull(object) {
	  return object === null;
	}

	var _null = new Type$9('tag:yaml.org,2002:null', {
	  kind: 'scalar',
	  resolve: resolveYamlNull,
	  construct: constructYamlNull,
	  predicate: isNull,
	  represent: {
	    canonical: function () { return '~';    },
	    lowercase: function () { return 'null'; },
	    uppercase: function () { return 'NULL'; },
	    camelcase: function () { return 'Null'; },
	    empty:     function () { return '';     }
	  },
	  defaultStyle: 'lowercase'
	});

	var Type$8 = type;

	function resolveYamlBoolean(data) {
	  if (data === null) return false;

	  var max = data.length;

	  return (max === 4 && (data === 'true' || data === 'True' || data === 'TRUE')) ||
	         (max === 5 && (data === 'false' || data === 'False' || data === 'FALSE'));
	}

	function constructYamlBoolean(data) {
	  return data === 'true' ||
	         data === 'True' ||
	         data === 'TRUE';
	}

	function isBoolean(object) {
	  return Object.prototype.toString.call(object) === '[object Boolean]';
	}

	var bool = new Type$8('tag:yaml.org,2002:bool', {
	  kind: 'scalar',
	  resolve: resolveYamlBoolean,
	  construct: constructYamlBoolean,
	  predicate: isBoolean,
	  represent: {
	    lowercase: function (object) { return object ? 'true' : 'false'; },
	    uppercase: function (object) { return object ? 'TRUE' : 'FALSE'; },
	    camelcase: function (object) { return object ? 'True' : 'False'; }
	  },
	  defaultStyle: 'lowercase'
	});

	var common$3 = common$5;
	var Type$7   = type;

	function isHexCode(c) {
	  return ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) ||
	         ((0x41/* A */ <= c) && (c <= 0x46/* F */)) ||
	         ((0x61/* a */ <= c) && (c <= 0x66/* f */));
	}

	function isOctCode(c) {
	  return ((0x30/* 0 */ <= c) && (c <= 0x37/* 7 */));
	}

	function isDecCode(c) {
	  return ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */));
	}

	function resolveYamlInteger(data) {
	  if (data === null) return false;

	  var max = data.length,
	      index = 0,
	      hasDigits = false,
	      ch;

	  if (!max) return false;

	  ch = data[index];

	  // sign
	  if (ch === '-' || ch === '+') {
	    ch = data[++index];
	  }

	  if (ch === '0') {
	    // 0
	    if (index + 1 === max) return true;
	    ch = data[++index];

	    // base 2, base 8, base 16

	    if (ch === 'b') {
	      // base 2
	      index++;

	      for (; index < max; index++) {
	        ch = data[index];
	        if (ch === '_') continue;
	        if (ch !== '0' && ch !== '1') return false;
	        hasDigits = true;
	      }
	      return hasDigits && ch !== '_';
	    }


	    if (ch === 'x') {
	      // base 16
	      index++;

	      for (; index < max; index++) {
	        ch = data[index];
	        if (ch === '_') continue;
	        if (!isHexCode(data.charCodeAt(index))) return false;
	        hasDigits = true;
	      }
	      return hasDigits && ch !== '_';
	    }


	    if (ch === 'o') {
	      // base 8
	      index++;

	      for (; index < max; index++) {
	        ch = data[index];
	        if (ch === '_') continue;
	        if (!isOctCode(data.charCodeAt(index))) return false;
	        hasDigits = true;
	      }
	      return hasDigits && ch !== '_';
	    }
	  }

	  // base 10 (except 0)

	  // value should not start with `_`;
	  if (ch === '_') return false;

	  for (; index < max; index++) {
	    ch = data[index];
	    if (ch === '_') continue;
	    if (!isDecCode(data.charCodeAt(index))) {
	      return false;
	    }
	    hasDigits = true;
	  }

	  // Should have digits and should not end with `_`
	  if (!hasDigits || ch === '_') return false;

	  return true;
	}

	function constructYamlInteger(data) {
	  var value = data, sign = 1, ch;

	  if (value.indexOf('_') !== -1) {
	    value = value.replace(/_/g, '');
	  }

	  ch = value[0];

	  if (ch === '-' || ch === '+') {
	    if (ch === '-') sign = -1;
	    value = value.slice(1);
	    ch = value[0];
	  }

	  if (value === '0') return 0;

	  if (ch === '0') {
	    if (value[1] === 'b') return sign * parseInt(value.slice(2), 2);
	    if (value[1] === 'x') return sign * parseInt(value.slice(2), 16);
	    if (value[1] === 'o') return sign * parseInt(value.slice(2), 8);
	  }

	  return sign * parseInt(value, 10);
	}

	function isInteger(object) {
	  return (Object.prototype.toString.call(object)) === '[object Number]' &&
	         (object % 1 === 0 && !common$3.isNegativeZero(object));
	}

	var int = new Type$7('tag:yaml.org,2002:int', {
	  kind: 'scalar',
	  resolve: resolveYamlInteger,
	  construct: constructYamlInteger,
	  predicate: isInteger,
	  represent: {
	    binary:      function (obj) { return obj >= 0 ? '0b' + obj.toString(2) : '-0b' + obj.toString(2).slice(1); },
	    octal:       function (obj) { return obj >= 0 ? '0o'  + obj.toString(8) : '-0o'  + obj.toString(8).slice(1); },
	    decimal:     function (obj) { return obj.toString(10); },
	    /* eslint-disable max-len */
	    hexadecimal: function (obj) { return obj >= 0 ? '0x' + obj.toString(16).toUpperCase() :  '-0x' + obj.toString(16).toUpperCase().slice(1); }
	  },
	  defaultStyle: 'decimal',
	  styleAliases: {
	    binary:      [ 2,  'bin' ],
	    octal:       [ 8,  'oct' ],
	    decimal:     [ 10, 'dec' ],
	    hexadecimal: [ 16, 'hex' ]
	  }
	});

	var common$2 = common$5;
	var Type$6   = type;

	var YAML_FLOAT_PATTERN = new RegExp(
	  // 2.5e4, 2.5 and integers
	  '^(?:[-+]?(?:[0-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?' +
	  // .2e4, .2
	  // special case, seems not from spec
	  '|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?' +
	  // .inf
	  '|[-+]?\\.(?:inf|Inf|INF)' +
	  // .nan
	  '|\\.(?:nan|NaN|NAN))$');

	function resolveYamlFloat(data) {
	  if (data === null) return false;

	  if (!YAML_FLOAT_PATTERN.test(data) ||
	      // Quick hack to not allow integers end with `_`
	      // Probably should update regexp & check speed
	      data[data.length - 1] === '_') {
	    return false;
	  }

	  return true;
	}

	function constructYamlFloat(data) {
	  var value, sign;

	  value  = data.replace(/_/g, '').toLowerCase();
	  sign   = value[0] === '-' ? -1 : 1;

	  if ('+-'.indexOf(value[0]) >= 0) {
	    value = value.slice(1);
	  }

	  if (value === '.inf') {
	    return (sign === 1) ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;

	  } else if (value === '.nan') {
	    return NaN;
	  }
	  return sign * parseFloat(value, 10);
	}


	var SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;

	function representYamlFloat(object, style) {
	  var res;

	  if (isNaN(object)) {
	    switch (style) {
	      case 'lowercase': return '.nan';
	      case 'uppercase': return '.NAN';
	      case 'camelcase': return '.NaN';
	    }
	  } else if (Number.POSITIVE_INFINITY === object) {
	    switch (style) {
	      case 'lowercase': return '.inf';
	      case 'uppercase': return '.INF';
	      case 'camelcase': return '.Inf';
	    }
	  } else if (Number.NEGATIVE_INFINITY === object) {
	    switch (style) {
	      case 'lowercase': return '-.inf';
	      case 'uppercase': return '-.INF';
	      case 'camelcase': return '-.Inf';
	    }
	  } else if (common$2.isNegativeZero(object)) {
	    return '-0.0';
	  }

	  res = object.toString(10);

	  // JS stringifier can build scientific format without dots: 5e-100,
	  // while YAML requres dot: 5.e-100. Fix it with simple hack

	  return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace('e', '.e') : res;
	}

	function isFloat(object) {
	  return (Object.prototype.toString.call(object) === '[object Number]') &&
	         (object % 1 !== 0 || common$2.isNegativeZero(object));
	}

	var float = new Type$6('tag:yaml.org,2002:float', {
	  kind: 'scalar',
	  resolve: resolveYamlFloat,
	  construct: constructYamlFloat,
	  predicate: isFloat,
	  represent: representYamlFloat,
	  defaultStyle: 'lowercase'
	});

	var json = failsafe.extend({
	  implicit: [
	    _null,
	    bool,
	    int,
	    float
	  ]
	});

	var core = json;

	var Type$5 = type;

	var YAML_DATE_REGEXP = new RegExp(
	  '^([0-9][0-9][0-9][0-9])'          + // [1] year
	  '-([0-9][0-9])'                    + // [2] month
	  '-([0-9][0-9])$');                   // [3] day

	var YAML_TIMESTAMP_REGEXP = new RegExp(
	  '^([0-9][0-9][0-9][0-9])'          + // [1] year
	  '-([0-9][0-9]?)'                   + // [2] month
	  '-([0-9][0-9]?)'                   + // [3] day
	  '(?:[Tt]|[ \\t]+)'                 + // ...
	  '([0-9][0-9]?)'                    + // [4] hour
	  ':([0-9][0-9])'                    + // [5] minute
	  ':([0-9][0-9])'                    + // [6] second
	  '(?:\\.([0-9]*))?'                 + // [7] fraction
	  '(?:[ \\t]*(Z|([-+])([0-9][0-9]?)' + // [8] tz [9] tz_sign [10] tz_hour
	  '(?::([0-9][0-9]))?))?$');           // [11] tz_minute

	function resolveYamlTimestamp(data) {
	  if (data === null) return false;
	  if (YAML_DATE_REGEXP.exec(data) !== null) return true;
	  if (YAML_TIMESTAMP_REGEXP.exec(data) !== null) return true;
	  return false;
	}

	function constructYamlTimestamp(data) {
	  var match, year, month, day, hour, minute, second, fraction = 0,
	      delta = null, tz_hour, tz_minute, date;

	  match = YAML_DATE_REGEXP.exec(data);
	  if (match === null) match = YAML_TIMESTAMP_REGEXP.exec(data);

	  if (match === null) throw new Error('Date resolve error');

	  // match: [1] year [2] month [3] day

	  year = +(match[1]);
	  month = +(match[2]) - 1; // JS month starts with 0
	  day = +(match[3]);

	  if (!match[4]) { // no hour
	    return new Date(Date.UTC(year, month, day));
	  }

	  // match: [4] hour [5] minute [6] second [7] fraction

	  hour = +(match[4]);
	  minute = +(match[5]);
	  second = +(match[6]);

	  if (match[7]) {
	    fraction = match[7].slice(0, 3);
	    while (fraction.length < 3) { // milli-seconds
	      fraction += '0';
	    }
	    fraction = +fraction;
	  }

	  // match: [8] tz [9] tz_sign [10] tz_hour [11] tz_minute

	  if (match[9]) {
	    tz_hour = +(match[10]);
	    tz_minute = +(match[11] || 0);
	    delta = (tz_hour * 60 + tz_minute) * 60000; // delta in mili-seconds
	    if (match[9] === '-') delta = -delta;
	  }

	  date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));

	  if (delta) date.setTime(date.getTime() - delta);

	  return date;
	}

	function representYamlTimestamp(object /*, style*/) {
	  return object.toISOString();
	}

	var timestamp = new Type$5('tag:yaml.org,2002:timestamp', {
	  kind: 'scalar',
	  resolve: resolveYamlTimestamp,
	  construct: constructYamlTimestamp,
	  instanceOf: Date,
	  represent: representYamlTimestamp
	});

	var Type$4 = type;

	function resolveYamlMerge(data) {
	  return data === '<<' || data === null;
	}

	var merge = new Type$4('tag:yaml.org,2002:merge', {
	  kind: 'scalar',
	  resolve: resolveYamlMerge
	});

	/*eslint-disable no-bitwise*/


	var Type$3 = type;


	// [ 64, 65, 66 ] -> [ padding, CR, LF ]
	var BASE64_MAP = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r';


	function resolveYamlBinary(data) {
	  if (data === null) return false;

	  var code, idx, bitlen = 0, max = data.length, map = BASE64_MAP;

	  // Convert one by one.
	  for (idx = 0; idx < max; idx++) {
	    code = map.indexOf(data.charAt(idx));

	    // Skip CR/LF
	    if (code > 64) continue;

	    // Fail on illegal characters
	    if (code < 0) return false;

	    bitlen += 6;
	  }

	  // If there are any bits left, source was corrupted
	  return (bitlen % 8) === 0;
	}

	function constructYamlBinary(data) {
	  var idx, tailbits,
	      input = data.replace(/[\r\n=]/g, ''), // remove CR/LF & padding to simplify scan
	      max = input.length,
	      map = BASE64_MAP,
	      bits = 0,
	      result = [];

	  // Collect by 6*4 bits (3 bytes)

	  for (idx = 0; idx < max; idx++) {
	    if ((idx % 4 === 0) && idx) {
	      result.push((bits >> 16) & 0xFF);
	      result.push((bits >> 8) & 0xFF);
	      result.push(bits & 0xFF);
	    }

	    bits = (bits << 6) | map.indexOf(input.charAt(idx));
	  }

	  // Dump tail

	  tailbits = (max % 4) * 6;

	  if (tailbits === 0) {
	    result.push((bits >> 16) & 0xFF);
	    result.push((bits >> 8) & 0xFF);
	    result.push(bits & 0xFF);
	  } else if (tailbits === 18) {
	    result.push((bits >> 10) & 0xFF);
	    result.push((bits >> 2) & 0xFF);
	  } else if (tailbits === 12) {
	    result.push((bits >> 4) & 0xFF);
	  }

	  return new Uint8Array(result);
	}

	function representYamlBinary(object /*, style*/) {
	  var result = '', bits = 0, idx, tail,
	      max = object.length,
	      map = BASE64_MAP;

	  // Convert every three bytes to 4 ASCII characters.

	  for (idx = 0; idx < max; idx++) {
	    if ((idx % 3 === 0) && idx) {
	      result += map[(bits >> 18) & 0x3F];
	      result += map[(bits >> 12) & 0x3F];
	      result += map[(bits >> 6) & 0x3F];
	      result += map[bits & 0x3F];
	    }

	    bits = (bits << 8) + object[idx];
	  }

	  // Dump tail

	  tail = max % 3;

	  if (tail === 0) {
	    result += map[(bits >> 18) & 0x3F];
	    result += map[(bits >> 12) & 0x3F];
	    result += map[(bits >> 6) & 0x3F];
	    result += map[bits & 0x3F];
	  } else if (tail === 2) {
	    result += map[(bits >> 10) & 0x3F];
	    result += map[(bits >> 4) & 0x3F];
	    result += map[(bits << 2) & 0x3F];
	    result += map[64];
	  } else if (tail === 1) {
	    result += map[(bits >> 2) & 0x3F];
	    result += map[(bits << 4) & 0x3F];
	    result += map[64];
	    result += map[64];
	  }

	  return result;
	}

	function isBinary(obj) {
	  return Object.prototype.toString.call(obj) ===  '[object Uint8Array]';
	}

	var binary$1 = new Type$3('tag:yaml.org,2002:binary', {
	  kind: 'scalar',
	  resolve: resolveYamlBinary,
	  construct: constructYamlBinary,
	  predicate: isBinary,
	  represent: representYamlBinary
	});

	var Type$2 = type;

	var _hasOwnProperty$3 = Object.prototype.hasOwnProperty;
	var _toString$2       = Object.prototype.toString;

	function resolveYamlOmap(data) {
	  if (data === null) return true;

	  var objectKeys = [], index, length, pair, pairKey, pairHasKey,
	      object = data;

	  for (index = 0, length = object.length; index < length; index += 1) {
	    pair = object[index];
	    pairHasKey = false;

	    if (_toString$2.call(pair) !== '[object Object]') return false;

	    for (pairKey in pair) {
	      if (_hasOwnProperty$3.call(pair, pairKey)) {
	        if (!pairHasKey) pairHasKey = true;
	        else return false;
	      }
	    }

	    if (!pairHasKey) return false;

	    if (objectKeys.indexOf(pairKey) === -1) objectKeys.push(pairKey);
	    else return false;
	  }

	  return true;
	}

	function constructYamlOmap(data) {
	  return data !== null ? data : [];
	}

	var omap = new Type$2('tag:yaml.org,2002:omap', {
	  kind: 'sequence',
	  resolve: resolveYamlOmap,
	  construct: constructYamlOmap
	});

	var Type$1 = type;

	var _toString$1 = Object.prototype.toString;

	function resolveYamlPairs(data) {
	  if (data === null) return true;

	  var index, length, pair, keys, result,
	      object = data;

	  result = new Array(object.length);

	  for (index = 0, length = object.length; index < length; index += 1) {
	    pair = object[index];

	    if (_toString$1.call(pair) !== '[object Object]') return false;

	    keys = Object.keys(pair);

	    if (keys.length !== 1) return false;

	    result[index] = [ keys[0], pair[keys[0]] ];
	  }

	  return true;
	}

	function constructYamlPairs(data) {
	  if (data === null) return [];

	  var index, length, pair, keys, result,
	      object = data;

	  result = new Array(object.length);

	  for (index = 0, length = object.length; index < length; index += 1) {
	    pair = object[index];

	    keys = Object.keys(pair);

	    result[index] = [ keys[0], pair[keys[0]] ];
	  }

	  return result;
	}

	var pairs = new Type$1('tag:yaml.org,2002:pairs', {
	  kind: 'sequence',
	  resolve: resolveYamlPairs,
	  construct: constructYamlPairs
	});

	var Type = type;

	var _hasOwnProperty$2 = Object.prototype.hasOwnProperty;

	function resolveYamlSet(data) {
	  if (data === null) return true;

	  var key, object = data;

	  for (key in object) {
	    if (_hasOwnProperty$2.call(object, key)) {
	      if (object[key] !== null) return false;
	    }
	  }

	  return true;
	}

	function constructYamlSet(data) {
	  return data !== null ? data : {};
	}

	var set = new Type('tag:yaml.org,2002:set', {
	  kind: 'mapping',
	  resolve: resolveYamlSet,
	  construct: constructYamlSet
	});

	var _default = core.extend({
	  implicit: [
	    timestamp,
	    merge
	  ],
	  explicit: [
	    binary$1,
	    omap,
	    pairs,
	    set
	  ]
	});

	/*eslint-disable max-len,no-use-before-define*/

	var common$1              = common$5;
	var YAMLException$1       = exception;
	var makeSnippet         = snippet;
	var DEFAULT_SCHEMA$1      = _default;


	var _hasOwnProperty$1 = Object.prototype.hasOwnProperty;


	var CONTEXT_FLOW_IN   = 1;
	var CONTEXT_FLOW_OUT  = 2;
	var CONTEXT_BLOCK_IN  = 3;
	var CONTEXT_BLOCK_OUT = 4;


	var CHOMPING_CLIP  = 1;
	var CHOMPING_STRIP = 2;
	var CHOMPING_KEEP  = 3;


	var PATTERN_NON_PRINTABLE         = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
	var PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/;
	var PATTERN_FLOW_INDICATORS       = /[,\[\]\{\}]/;
	var PATTERN_TAG_HANDLE            = /^(?:!|!!|![a-z\-]+!)$/i;
	var PATTERN_TAG_URI               = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;


	function _class(obj) { return Object.prototype.toString.call(obj); }

	function is_EOL(c) {
	  return (c === 0x0A/* LF */) || (c === 0x0D/* CR */);
	}

	function is_WHITE_SPACE(c) {
	  return (c === 0x09/* Tab */) || (c === 0x20/* Space */);
	}

	function is_WS_OR_EOL(c) {
	  return (c === 0x09/* Tab */) ||
	         (c === 0x20/* Space */) ||
	         (c === 0x0A/* LF */) ||
	         (c === 0x0D/* CR */);
	}

	function is_FLOW_INDICATOR(c) {
	  return c === 0x2C/* , */ ||
	         c === 0x5B/* [ */ ||
	         c === 0x5D/* ] */ ||
	         c === 0x7B/* { */ ||
	         c === 0x7D/* } */;
	}

	function fromHexCode(c) {
	  var lc;

	  if ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) {
	    return c - 0x30;
	  }

	  /*eslint-disable no-bitwise*/
	  lc = c | 0x20;

	  if ((0x61/* a */ <= lc) && (lc <= 0x66/* f */)) {
	    return lc - 0x61 + 10;
	  }

	  return -1;
	}

	function escapedHexLen(c) {
	  if (c === 0x78/* x */) { return 2; }
	  if (c === 0x75/* u */) { return 4; }
	  if (c === 0x55/* U */) { return 8; }
	  return 0;
	}

	function fromDecimalCode(c) {
	  if ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) {
	    return c - 0x30;
	  }

	  return -1;
	}

	function simpleEscapeSequence(c) {
	  /* eslint-disable indent */
	  return (c === 0x30/* 0 */) ? '\x00' :
	        (c === 0x61/* a */) ? '\x07' :
	        (c === 0x62/* b */) ? '\x08' :
	        (c === 0x74/* t */) ? '\x09' :
	        (c === 0x09/* Tab */) ? '\x09' :
	        (c === 0x6E/* n */) ? '\x0A' :
	        (c === 0x76/* v */) ? '\x0B' :
	        (c === 0x66/* f */) ? '\x0C' :
	        (c === 0x72/* r */) ? '\x0D' :
	        (c === 0x65/* e */) ? '\x1B' :
	        (c === 0x20/* Space */) ? ' ' :
	        (c === 0x22/* " */) ? '\x22' :
	        (c === 0x2F/* / */) ? '/' :
	        (c === 0x5C/* \ */) ? '\x5C' :
	        (c === 0x4E/* N */) ? '\x85' :
	        (c === 0x5F/* _ */) ? '\xA0' :
	        (c === 0x4C/* L */) ? '\u2028' :
	        (c === 0x50/* P */) ? '\u2029' : '';
	}

	function charFromCodepoint(c) {
	  if (c <= 0xFFFF) {
	    return String.fromCharCode(c);
	  }
	  // Encode UTF-16 surrogate pair
	  // https://en.wikipedia.org/wiki/UTF-16#Code_points_U.2B010000_to_U.2B10FFFF
	  return String.fromCharCode(
	    ((c - 0x010000) >> 10) + 0xD800,
	    ((c - 0x010000) & 0x03FF) + 0xDC00
	  );
	}

	var simpleEscapeCheck = new Array(256); // integer, for fast access
	var simpleEscapeMap = new Array(256);
	for (var i = 0; i < 256; i++) {
	  simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0;
	  simpleEscapeMap[i] = simpleEscapeSequence(i);
	}


	function State$1(input, options) {
	  this.input = input;

	  this.filename  = options['filename']  || null;
	  this.schema    = options['schema']    || DEFAULT_SCHEMA$1;
	  this.onWarning = options['onWarning'] || null;
	  // (Hidden) Remove? makes the loader to expect YAML 1.1 documents
	  // if such documents have no explicit %YAML directive
	  this.legacy    = options['legacy']    || false;

	  this.json      = options['json']      || false;
	  this.listener  = options['listener']  || null;

	  this.implicitTypes = this.schema.compiledImplicit;
	  this.typeMap       = this.schema.compiledTypeMap;

	  this.length     = input.length;
	  this.position   = 0;
	  this.line       = 0;
	  this.lineStart  = 0;
	  this.lineIndent = 0;

	  // position of first leading tab in the current line,
	  // used to make sure there are no tabs in the indentation
	  this.firstTabInLine = -1;

	  this.documents = [];

	  /*
	  this.version;
	  this.checkLineBreaks;
	  this.tagMap;
	  this.anchorMap;
	  this.tag;
	  this.anchor;
	  this.kind;
	  this.result;*/

	}


	function generateError(state, message) {
	  var mark = {
	    name:     state.filename,
	    buffer:   state.input.slice(0, -1), // omit trailing \0
	    position: state.position,
	    line:     state.line,
	    column:   state.position - state.lineStart
	  };

	  mark.snippet = makeSnippet(mark);

	  return new YAMLException$1(message, mark);
	}

	function throwError(state, message) {
	  throw generateError(state, message);
	}

	function throwWarning(state, message) {
	  if (state.onWarning) {
	    state.onWarning.call(null, generateError(state, message));
	  }
	}


	var directiveHandlers = {

	  YAML: function handleYamlDirective(state, name, args) {

	    var match, major, minor;

	    if (state.version !== null) {
	      throwError(state, 'duplication of %YAML directive');
	    }

	    if (args.length !== 1) {
	      throwError(state, 'YAML directive accepts exactly one argument');
	    }

	    match = /^([0-9]+)\.([0-9]+)$/.exec(args[0]);

	    if (match === null) {
	      throwError(state, 'ill-formed argument of the YAML directive');
	    }

	    major = parseInt(match[1], 10);
	    minor = parseInt(match[2], 10);

	    if (major !== 1) {
	      throwError(state, 'unacceptable YAML version of the document');
	    }

	    state.version = args[0];
	    state.checkLineBreaks = (minor < 2);

	    if (minor !== 1 && minor !== 2) {
	      throwWarning(state, 'unsupported YAML version of the document');
	    }
	  },

	  TAG: function handleTagDirective(state, name, args) {

	    var handle, prefix;

	    if (args.length !== 2) {
	      throwError(state, 'TAG directive accepts exactly two arguments');
	    }

	    handle = args[0];
	    prefix = args[1];

	    if (!PATTERN_TAG_HANDLE.test(handle)) {
	      throwError(state, 'ill-formed tag handle (first argument) of the TAG directive');
	    }

	    if (_hasOwnProperty$1.call(state.tagMap, handle)) {
	      throwError(state, 'there is a previously declared suffix for "' + handle + '" tag handle');
	    }

	    if (!PATTERN_TAG_URI.test(prefix)) {
	      throwError(state, 'ill-formed tag prefix (second argument) of the TAG directive');
	    }

	    try {
	      prefix = decodeURIComponent(prefix);
	    } catch (err) {
	      throwError(state, 'tag prefix is malformed: ' + prefix);
	    }

	    state.tagMap[handle] = prefix;
	  }
	};


	function captureSegment(state, start, end, checkJson) {
	  var _position, _length, _character, _result;

	  if (start < end) {
	    _result = state.input.slice(start, end);

	    if (checkJson) {
	      for (_position = 0, _length = _result.length; _position < _length; _position += 1) {
	        _character = _result.charCodeAt(_position);
	        if (!(_character === 0x09 ||
	              (0x20 <= _character && _character <= 0x10FFFF))) {
	          throwError(state, 'expected valid JSON character');
	        }
	      }
	    } else if (PATTERN_NON_PRINTABLE.test(_result)) {
	      throwError(state, 'the stream contains non-printable characters');
	    }

	    state.result += _result;
	  }
	}

	function mergeMappings(state, destination, source, overridableKeys) {
	  var sourceKeys, key, index, quantity;

	  if (!common$1.isObject(source)) {
	    throwError(state, 'cannot merge mappings; the provided source object is unacceptable');
	  }

	  sourceKeys = Object.keys(source);

	  for (index = 0, quantity = sourceKeys.length; index < quantity; index += 1) {
	    key = sourceKeys[index];

	    if (!_hasOwnProperty$1.call(destination, key)) {
	      destination[key] = source[key];
	      overridableKeys[key] = true;
	    }
	  }
	}

	function storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode,
	  startLine, startLineStart, startPos) {

	  var index, quantity;

	  // The output is a plain object here, so keys can only be strings.
	  // We need to convert keyNode to a string, but doing so can hang the process
	  // (deeply nested arrays that explode exponentially using aliases).
	  if (Array.isArray(keyNode)) {
	    keyNode = Array.prototype.slice.call(keyNode);

	    for (index = 0, quantity = keyNode.length; index < quantity; index += 1) {
	      if (Array.isArray(keyNode[index])) {
	        throwError(state, 'nested arrays are not supported inside keys');
	      }

	      if (typeof keyNode === 'object' && _class(keyNode[index]) === '[object Object]') {
	        keyNode[index] = '[object Object]';
	      }
	    }
	  }

	  // Avoid code execution in load() via toString property
	  // (still use its own toString for arrays, timestamps,
	  // and whatever user schema extensions happen to have @@toStringTag)
	  if (typeof keyNode === 'object' && _class(keyNode) === '[object Object]') {
	    keyNode = '[object Object]';
	  }


	  keyNode = String(keyNode);

	  if (_result === null) {
	    _result = {};
	  }

	  if (keyTag === 'tag:yaml.org,2002:merge') {
	    if (Array.isArray(valueNode)) {
	      for (index = 0, quantity = valueNode.length; index < quantity; index += 1) {
	        mergeMappings(state, _result, valueNode[index], overridableKeys);
	      }
	    } else {
	      mergeMappings(state, _result, valueNode, overridableKeys);
	    }
	  } else {
	    if (!state.json &&
	        !_hasOwnProperty$1.call(overridableKeys, keyNode) &&
	        _hasOwnProperty$1.call(_result, keyNode)) {
	      state.line = startLine || state.line;
	      state.lineStart = startLineStart || state.lineStart;
	      state.position = startPos || state.position;
	      throwError(state, 'duplicated mapping key');
	    }

	    // used for this specific key only because Object.defineProperty is slow
	    if (keyNode === '__proto__') {
	      Object.defineProperty(_result, keyNode, {
	        configurable: true,
	        enumerable: true,
	        writable: true,
	        value: valueNode
	      });
	    } else {
	      _result[keyNode] = valueNode;
	    }
	    delete overridableKeys[keyNode];
	  }

	  return _result;
	}

	function readLineBreak(state) {
	  var ch;

	  ch = state.input.charCodeAt(state.position);

	  if (ch === 0x0A/* LF */) {
	    state.position++;
	  } else if (ch === 0x0D/* CR */) {
	    state.position++;
	    if (state.input.charCodeAt(state.position) === 0x0A/* LF */) {
	      state.position++;
	    }
	  } else {
	    throwError(state, 'a line break is expected');
	  }

	  state.line += 1;
	  state.lineStart = state.position;
	  state.firstTabInLine = -1;
	}

	function skipSeparationSpace(state, allowComments, checkIndent) {
	  var lineBreaks = 0,
	      ch = state.input.charCodeAt(state.position);

	  while (ch !== 0) {
	    while (is_WHITE_SPACE(ch)) {
	      if (ch === 0x09/* Tab */ && state.firstTabInLine === -1) {
	        state.firstTabInLine = state.position;
	      }
	      ch = state.input.charCodeAt(++state.position);
	    }

	    if (allowComments && ch === 0x23/* # */) {
	      do {
	        ch = state.input.charCodeAt(++state.position);
	      } while (ch !== 0x0A/* LF */ && ch !== 0x0D/* CR */ && ch !== 0);
	    }

	    if (is_EOL(ch)) {
	      readLineBreak(state);

	      ch = state.input.charCodeAt(state.position);
	      lineBreaks++;
	      state.lineIndent = 0;

	      while (ch === 0x20/* Space */) {
	        state.lineIndent++;
	        ch = state.input.charCodeAt(++state.position);
	      }
	    } else {
	      break;
	    }
	  }

	  if (checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent) {
	    throwWarning(state, 'deficient indentation');
	  }

	  return lineBreaks;
	}

	function testDocumentSeparator(state) {
	  var _position = state.position,
	      ch;

	  ch = state.input.charCodeAt(_position);

	  // Condition state.position === state.lineStart is tested
	  // in parent on each call, for efficiency. No needs to test here again.
	  if ((ch === 0x2D/* - */ || ch === 0x2E/* . */) &&
	      ch === state.input.charCodeAt(_position + 1) &&
	      ch === state.input.charCodeAt(_position + 2)) {

	    _position += 3;

	    ch = state.input.charCodeAt(_position);

	    if (ch === 0 || is_WS_OR_EOL(ch)) {
	      return true;
	    }
	  }

	  return false;
	}

	function writeFoldedLines(state, count) {
	  if (count === 1) {
	    state.result += ' ';
	  } else if (count > 1) {
	    state.result += common$1.repeat('\n', count - 1);
	  }
	}


	function readPlainScalar(state, nodeIndent, withinFlowCollection) {
	  var preceding,
	      following,
	      captureStart,
	      captureEnd,
	      hasPendingContent,
	      _line,
	      _lineStart,
	      _lineIndent,
	      _kind = state.kind,
	      _result = state.result,
	      ch;

	  ch = state.input.charCodeAt(state.position);

	  if (is_WS_OR_EOL(ch)      ||
	      is_FLOW_INDICATOR(ch) ||
	      ch === 0x23/* # */    ||
	      ch === 0x26/* & */    ||
	      ch === 0x2A/* * */    ||
	      ch === 0x21/* ! */    ||
	      ch === 0x7C/* | */    ||
	      ch === 0x3E/* > */    ||
	      ch === 0x27/* ' */    ||
	      ch === 0x22/* " */    ||
	      ch === 0x25/* % */    ||
	      ch === 0x40/* @ */    ||
	      ch === 0x60/* ` */) {
	    return false;
	  }

	  if (ch === 0x3F/* ? */ || ch === 0x2D/* - */) {
	    following = state.input.charCodeAt(state.position + 1);

	    if (is_WS_OR_EOL(following) ||
	        withinFlowCollection && is_FLOW_INDICATOR(following)) {
	      return false;
	    }
	  }

	  state.kind = 'scalar';
	  state.result = '';
	  captureStart = captureEnd = state.position;
	  hasPendingContent = false;

	  while (ch !== 0) {
	    if (ch === 0x3A/* : */) {
	      following = state.input.charCodeAt(state.position + 1);

	      if (is_WS_OR_EOL(following) ||
	          withinFlowCollection && is_FLOW_INDICATOR(following)) {
	        break;
	      }

	    } else if (ch === 0x23/* # */) {
	      preceding = state.input.charCodeAt(state.position - 1);

	      if (is_WS_OR_EOL(preceding)) {
	        break;
	      }

	    } else if ((state.position === state.lineStart && testDocumentSeparator(state)) ||
	               withinFlowCollection && is_FLOW_INDICATOR(ch)) {
	      break;

	    } else if (is_EOL(ch)) {
	      _line = state.line;
	      _lineStart = state.lineStart;
	      _lineIndent = state.lineIndent;
	      skipSeparationSpace(state, false, -1);

	      if (state.lineIndent >= nodeIndent) {
	        hasPendingContent = true;
	        ch = state.input.charCodeAt(state.position);
	        continue;
	      } else {
	        state.position = captureEnd;
	        state.line = _line;
	        state.lineStart = _lineStart;
	        state.lineIndent = _lineIndent;
	        break;
	      }
	    }

	    if (hasPendingContent) {
	      captureSegment(state, captureStart, captureEnd, false);
	      writeFoldedLines(state, state.line - _line);
	      captureStart = captureEnd = state.position;
	      hasPendingContent = false;
	    }

	    if (!is_WHITE_SPACE(ch)) {
	      captureEnd = state.position + 1;
	    }

	    ch = state.input.charCodeAt(++state.position);
	  }

	  captureSegment(state, captureStart, captureEnd, false);

	  if (state.result) {
	    return true;
	  }

	  state.kind = _kind;
	  state.result = _result;
	  return false;
	}

	function readSingleQuotedScalar(state, nodeIndent) {
	  var ch,
	      captureStart, captureEnd;

	  ch = state.input.charCodeAt(state.position);

	  if (ch !== 0x27/* ' */) {
	    return false;
	  }

	  state.kind = 'scalar';
	  state.result = '';
	  state.position++;
	  captureStart = captureEnd = state.position;

	  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
	    if (ch === 0x27/* ' */) {
	      captureSegment(state, captureStart, state.position, true);
	      ch = state.input.charCodeAt(++state.position);

	      if (ch === 0x27/* ' */) {
	        captureStart = state.position;
	        state.position++;
	        captureEnd = state.position;
	      } else {
	        return true;
	      }

	    } else if (is_EOL(ch)) {
	      captureSegment(state, captureStart, captureEnd, true);
	      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
	      captureStart = captureEnd = state.position;

	    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
	      throwError(state, 'unexpected end of the document within a single quoted scalar');

	    } else {
	      state.position++;
	      captureEnd = state.position;
	    }
	  }

	  throwError(state, 'unexpected end of the stream within a single quoted scalar');
	}

	function readDoubleQuotedScalar(state, nodeIndent) {
	  var captureStart,
	      captureEnd,
	      hexLength,
	      hexResult,
	      tmp,
	      ch;

	  ch = state.input.charCodeAt(state.position);

	  if (ch !== 0x22/* " */) {
	    return false;
	  }

	  state.kind = 'scalar';
	  state.result = '';
	  state.position++;
	  captureStart = captureEnd = state.position;

	  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
	    if (ch === 0x22/* " */) {
	      captureSegment(state, captureStart, state.position, true);
	      state.position++;
	      return true;

	    } else if (ch === 0x5C/* \ */) {
	      captureSegment(state, captureStart, state.position, true);
	      ch = state.input.charCodeAt(++state.position);

	      if (is_EOL(ch)) {
	        skipSeparationSpace(state, false, nodeIndent);

	        // TODO: rework to inline fn with no type cast?
	      } else if (ch < 256 && simpleEscapeCheck[ch]) {
	        state.result += simpleEscapeMap[ch];
	        state.position++;

	      } else if ((tmp = escapedHexLen(ch)) > 0) {
	        hexLength = tmp;
	        hexResult = 0;

	        for (; hexLength > 0; hexLength--) {
	          ch = state.input.charCodeAt(++state.position);

	          if ((tmp = fromHexCode(ch)) >= 0) {
	            hexResult = (hexResult << 4) + tmp;

	          } else {
	            throwError(state, 'expected hexadecimal character');
	          }
	        }

	        state.result += charFromCodepoint(hexResult);

	        state.position++;

	      } else {
	        throwError(state, 'unknown escape sequence');
	      }

	      captureStart = captureEnd = state.position;

	    } else if (is_EOL(ch)) {
	      captureSegment(state, captureStart, captureEnd, true);
	      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
	      captureStart = captureEnd = state.position;

	    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
	      throwError(state, 'unexpected end of the document within a double quoted scalar');

	    } else {
	      state.position++;
	      captureEnd = state.position;
	    }
	  }

	  throwError(state, 'unexpected end of the stream within a double quoted scalar');
	}

	function readFlowCollection(state, nodeIndent) {
	  var readNext = true,
	      _line,
	      _lineStart,
	      _pos,
	      _tag     = state.tag,
	      _result,
	      _anchor  = state.anchor,
	      following,
	      terminator,
	      isPair,
	      isExplicitPair,
	      isMapping,
	      overridableKeys = Object.create(null),
	      keyNode,
	      keyTag,
	      valueNode,
	      ch;

	  ch = state.input.charCodeAt(state.position);

	  if (ch === 0x5B/* [ */) {
	    terminator = 0x5D;/* ] */
	    isMapping = false;
	    _result = [];
	  } else if (ch === 0x7B/* { */) {
	    terminator = 0x7D;/* } */
	    isMapping = true;
	    _result = {};
	  } else {
	    return false;
	  }

	  if (state.anchor !== null) {
	    state.anchorMap[state.anchor] = _result;
	  }

	  ch = state.input.charCodeAt(++state.position);

	  while (ch !== 0) {
	    skipSeparationSpace(state, true, nodeIndent);

	    ch = state.input.charCodeAt(state.position);

	    if (ch === terminator) {
	      state.position++;
	      state.tag = _tag;
	      state.anchor = _anchor;
	      state.kind = isMapping ? 'mapping' : 'sequence';
	      state.result = _result;
	      return true;
	    } else if (!readNext) {
	      throwError(state, 'missed comma between flow collection entries');
	    } else if (ch === 0x2C/* , */) {
	      // "flow collection entries can never be completely empty", as per YAML 1.2, section 7.4
	      throwError(state, "expected the node content, but found ','");
	    }

	    keyTag = keyNode = valueNode = null;
	    isPair = isExplicitPair = false;

	    if (ch === 0x3F/* ? */) {
	      following = state.input.charCodeAt(state.position + 1);

	      if (is_WS_OR_EOL(following)) {
	        isPair = isExplicitPair = true;
	        state.position++;
	        skipSeparationSpace(state, true, nodeIndent);
	      }
	    }

	    _line = state.line; // Save the current line.
	    _lineStart = state.lineStart;
	    _pos = state.position;
	    composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
	    keyTag = state.tag;
	    keyNode = state.result;
	    skipSeparationSpace(state, true, nodeIndent);

	    ch = state.input.charCodeAt(state.position);

	    if ((isExplicitPair || state.line === _line) && ch === 0x3A/* : */) {
	      isPair = true;
	      ch = state.input.charCodeAt(++state.position);
	      skipSeparationSpace(state, true, nodeIndent);
	      composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
	      valueNode = state.result;
	    }

	    if (isMapping) {
	      storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos);
	    } else if (isPair) {
	      _result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos));
	    } else {
	      _result.push(keyNode);
	    }

	    skipSeparationSpace(state, true, nodeIndent);

	    ch = state.input.charCodeAt(state.position);

	    if (ch === 0x2C/* , */) {
	      readNext = true;
	      ch = state.input.charCodeAt(++state.position);
	    } else {
	      readNext = false;
	    }
	  }

	  throwError(state, 'unexpected end of the stream within a flow collection');
	}

	function readBlockScalar(state, nodeIndent) {
	  var captureStart,
	      folding,
	      chomping       = CHOMPING_CLIP,
	      didReadContent = false,
	      detectedIndent = false,
	      textIndent     = nodeIndent,
	      emptyLines     = 0,
	      atMoreIndented = false,
	      tmp,
	      ch;

	  ch = state.input.charCodeAt(state.position);

	  if (ch === 0x7C/* | */) {
	    folding = false;
	  } else if (ch === 0x3E/* > */) {
	    folding = true;
	  } else {
	    return false;
	  }

	  state.kind = 'scalar';
	  state.result = '';

	  while (ch !== 0) {
	    ch = state.input.charCodeAt(++state.position);

	    if (ch === 0x2B/* + */ || ch === 0x2D/* - */) {
	      if (CHOMPING_CLIP === chomping) {
	        chomping = (ch === 0x2B/* + */) ? CHOMPING_KEEP : CHOMPING_STRIP;
	      } else {
	        throwError(state, 'repeat of a chomping mode identifier');
	      }

	    } else if ((tmp = fromDecimalCode(ch)) >= 0) {
	      if (tmp === 0) {
	        throwError(state, 'bad explicit indentation width of a block scalar; it cannot be less than one');
	      } else if (!detectedIndent) {
	        textIndent = nodeIndent + tmp - 1;
	        detectedIndent = true;
	      } else {
	        throwError(state, 'repeat of an indentation width identifier');
	      }

	    } else {
	      break;
	    }
	  }

	  if (is_WHITE_SPACE(ch)) {
	    do { ch = state.input.charCodeAt(++state.position); }
	    while (is_WHITE_SPACE(ch));

	    if (ch === 0x23/* # */) {
	      do { ch = state.input.charCodeAt(++state.position); }
	      while (!is_EOL(ch) && (ch !== 0));
	    }
	  }

	  while (ch !== 0) {
	    readLineBreak(state);
	    state.lineIndent = 0;

	    ch = state.input.charCodeAt(state.position);

	    while ((!detectedIndent || state.lineIndent < textIndent) &&
	           (ch === 0x20/* Space */)) {
	      state.lineIndent++;
	      ch = state.input.charCodeAt(++state.position);
	    }

	    if (!detectedIndent && state.lineIndent > textIndent) {
	      textIndent = state.lineIndent;
	    }

	    if (is_EOL(ch)) {
	      emptyLines++;
	      continue;
	    }

	    // End of the scalar.
	    if (state.lineIndent < textIndent) {

	      // Perform the chomping.
	      if (chomping === CHOMPING_KEEP) {
	        state.result += common$1.repeat('\n', didReadContent ? 1 + emptyLines : emptyLines);
	      } else if (chomping === CHOMPING_CLIP) {
	        if (didReadContent) { // i.e. only if the scalar is not empty.
	          state.result += '\n';
	        }
	      }

	      // Break this `while` cycle and go to the funciton's epilogue.
	      break;
	    }

	    // Folded style: use fancy rules to handle line breaks.
	    if (folding) {

	      // Lines starting with white space characters (more-indented lines) are not folded.
	      if (is_WHITE_SPACE(ch)) {
	        atMoreIndented = true;
	        // except for the first content line (cf. Example 8.1)
	        state.result += common$1.repeat('\n', didReadContent ? 1 + emptyLines : emptyLines);

	      // End of more-indented block.
	      } else if (atMoreIndented) {
	        atMoreIndented = false;
	        state.result += common$1.repeat('\n', emptyLines + 1);

	      // Just one line break - perceive as the same line.
	      } else if (emptyLines === 0) {
	        if (didReadContent) { // i.e. only if we have already read some scalar content.
	          state.result += ' ';
	        }

	      // Several line breaks - perceive as different lines.
	      } else {
	        state.result += common$1.repeat('\n', emptyLines);
	      }

	    // Literal style: just add exact number of line breaks between content lines.
	    } else {
	      // Keep all line breaks except the header line break.
	      state.result += common$1.repeat('\n', didReadContent ? 1 + emptyLines : emptyLines);
	    }

	    didReadContent = true;
	    detectedIndent = true;
	    emptyLines = 0;
	    captureStart = state.position;

	    while (!is_EOL(ch) && (ch !== 0)) {
	      ch = state.input.charCodeAt(++state.position);
	    }

	    captureSegment(state, captureStart, state.position, false);
	  }

	  return true;
	}

	function readBlockSequence(state, nodeIndent) {
	  var _line,
	      _tag      = state.tag,
	      _anchor   = state.anchor,
	      _result   = [],
	      following,
	      detected  = false,
	      ch;

	  // there is a leading tab before this token, so it can't be a block sequence/mapping;
	  // it can still be flow sequence/mapping or a scalar
	  if (state.firstTabInLine !== -1) return false;

	  if (state.anchor !== null) {
	    state.anchorMap[state.anchor] = _result;
	  }

	  ch = state.input.charCodeAt(state.position);

	  while (ch !== 0) {
	    if (state.firstTabInLine !== -1) {
	      state.position = state.firstTabInLine;
	      throwError(state, 'tab characters must not be used in indentation');
	    }

	    if (ch !== 0x2D/* - */) {
	      break;
	    }

	    following = state.input.charCodeAt(state.position + 1);

	    if (!is_WS_OR_EOL(following)) {
	      break;
	    }

	    detected = true;
	    state.position++;

	    if (skipSeparationSpace(state, true, -1)) {
	      if (state.lineIndent <= nodeIndent) {
	        _result.push(null);
	        ch = state.input.charCodeAt(state.position);
	        continue;
	      }
	    }

	    _line = state.line;
	    composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);
	    _result.push(state.result);
	    skipSeparationSpace(state, true, -1);

	    ch = state.input.charCodeAt(state.position);

	    if ((state.line === _line || state.lineIndent > nodeIndent) && (ch !== 0)) {
	      throwError(state, 'bad indentation of a sequence entry');
	    } else if (state.lineIndent < nodeIndent) {
	      break;
	    }
	  }

	  if (detected) {
	    state.tag = _tag;
	    state.anchor = _anchor;
	    state.kind = 'sequence';
	    state.result = _result;
	    return true;
	  }
	  return false;
	}

	function readBlockMapping(state, nodeIndent, flowIndent) {
	  var following,
	      allowCompact,
	      _line,
	      _keyLine,
	      _keyLineStart,
	      _keyPos,
	      _tag          = state.tag,
	      _anchor       = state.anchor,
	      _result       = {},
	      overridableKeys = Object.create(null),
	      keyTag        = null,
	      keyNode       = null,
	      valueNode     = null,
	      atExplicitKey = false,
	      detected      = false,
	      ch;

	  // there is a leading tab before this token, so it can't be a block sequence/mapping;
	  // it can still be flow sequence/mapping or a scalar
	  if (state.firstTabInLine !== -1) return false;

	  if (state.anchor !== null) {
	    state.anchorMap[state.anchor] = _result;
	  }

	  ch = state.input.charCodeAt(state.position);

	  while (ch !== 0) {
	    if (!atExplicitKey && state.firstTabInLine !== -1) {
	      state.position = state.firstTabInLine;
	      throwError(state, 'tab characters must not be used in indentation');
	    }

	    following = state.input.charCodeAt(state.position + 1);
	    _line = state.line; // Save the current line.

	    //
	    // Explicit notation case. There are two separate blocks:
	    // first for the key (denoted by "?") and second for the value (denoted by ":")
	    //
	    if ((ch === 0x3F/* ? */ || ch === 0x3A/* : */) && is_WS_OR_EOL(following)) {

	      if (ch === 0x3F/* ? */) {
	        if (atExplicitKey) {
	          storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
	          keyTag = keyNode = valueNode = null;
	        }

	        detected = true;
	        atExplicitKey = true;
	        allowCompact = true;

	      } else if (atExplicitKey) {
	        // i.e. 0x3A/* : */ === character after the explicit key.
	        atExplicitKey = false;
	        allowCompact = true;

	      } else {
	        throwError(state, 'incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line');
	      }

	      state.position += 1;
	      ch = following;

	    //
	    // Implicit notation case. Flow-style node as the key first, then ":", and the value.
	    //
	    } else {
	      _keyLine = state.line;
	      _keyLineStart = state.lineStart;
	      _keyPos = state.position;

	      if (!composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {
	        // Neither implicit nor explicit notation.
	        // Reading is done. Go to the epilogue.
	        break;
	      }

	      if (state.line === _line) {
	        ch = state.input.charCodeAt(state.position);

	        while (is_WHITE_SPACE(ch)) {
	          ch = state.input.charCodeAt(++state.position);
	        }

	        if (ch === 0x3A/* : */) {
	          ch = state.input.charCodeAt(++state.position);

	          if (!is_WS_OR_EOL(ch)) {
	            throwError(state, 'a whitespace character is expected after the key-value separator within a block mapping');
	          }

	          if (atExplicitKey) {
	            storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
	            keyTag = keyNode = valueNode = null;
	          }

	          detected = true;
	          atExplicitKey = false;
	          allowCompact = false;
	          keyTag = state.tag;
	          keyNode = state.result;

	        } else if (detected) {
	          throwError(state, 'can not read an implicit mapping pair; a colon is missed');

	        } else {
	          state.tag = _tag;
	          state.anchor = _anchor;
	          return true; // Keep the result of `composeNode`.
	        }

	      } else if (detected) {
	        throwError(state, 'can not read a block mapping entry; a multiline key may not be an implicit key');

	      } else {
	        state.tag = _tag;
	        state.anchor = _anchor;
	        return true; // Keep the result of `composeNode`.
	      }
	    }

	    //
	    // Common reading code for both explicit and implicit notations.
	    //
	    if (state.line === _line || state.lineIndent > nodeIndent) {
	      if (atExplicitKey) {
	        _keyLine = state.line;
	        _keyLineStart = state.lineStart;
	        _keyPos = state.position;
	      }

	      if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {
	        if (atExplicitKey) {
	          keyNode = state.result;
	        } else {
	          valueNode = state.result;
	        }
	      }

	      if (!atExplicitKey) {
	        storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _keyLine, _keyLineStart, _keyPos);
	        keyTag = keyNode = valueNode = null;
	      }

	      skipSeparationSpace(state, true, -1);
	      ch = state.input.charCodeAt(state.position);
	    }

	    if ((state.line === _line || state.lineIndent > nodeIndent) && (ch !== 0)) {
	      throwError(state, 'bad indentation of a mapping entry');
	    } else if (state.lineIndent < nodeIndent) {
	      break;
	    }
	  }

	  //
	  // Epilogue.
	  //

	  // Special case: last mapping's node contains only the key in explicit notation.
	  if (atExplicitKey) {
	    storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
	  }

	  // Expose the resulting mapping.
	  if (detected) {
	    state.tag = _tag;
	    state.anchor = _anchor;
	    state.kind = 'mapping';
	    state.result = _result;
	  }

	  return detected;
	}

	function readTagProperty(state) {
	  var _position,
	      isVerbatim = false,
	      isNamed    = false,
	      tagHandle,
	      tagName,
	      ch;

	  ch = state.input.charCodeAt(state.position);

	  if (ch !== 0x21/* ! */) return false;

	  if (state.tag !== null) {
	    throwError(state, 'duplication of a tag property');
	  }

	  ch = state.input.charCodeAt(++state.position);

	  if (ch === 0x3C/* < */) {
	    isVerbatim = true;
	    ch = state.input.charCodeAt(++state.position);

	  } else if (ch === 0x21/* ! */) {
	    isNamed = true;
	    tagHandle = '!!';
	    ch = state.input.charCodeAt(++state.position);

	  } else {
	    tagHandle = '!';
	  }

	  _position = state.position;

	  if (isVerbatim) {
	    do { ch = state.input.charCodeAt(++state.position); }
	    while (ch !== 0 && ch !== 0x3E/* > */);

	    if (state.position < state.length) {
	      tagName = state.input.slice(_position, state.position);
	      ch = state.input.charCodeAt(++state.position);
	    } else {
	      throwError(state, 'unexpected end of the stream within a verbatim tag');
	    }
	  } else {
	    while (ch !== 0 && !is_WS_OR_EOL(ch)) {

	      if (ch === 0x21/* ! */) {
	        if (!isNamed) {
	          tagHandle = state.input.slice(_position - 1, state.position + 1);

	          if (!PATTERN_TAG_HANDLE.test(tagHandle)) {
	            throwError(state, 'named tag handle cannot contain such characters');
	          }

	          isNamed = true;
	          _position = state.position + 1;
	        } else {
	          throwError(state, 'tag suffix cannot contain exclamation marks');
	        }
	      }

	      ch = state.input.charCodeAt(++state.position);
	    }

	    tagName = state.input.slice(_position, state.position);

	    if (PATTERN_FLOW_INDICATORS.test(tagName)) {
	      throwError(state, 'tag suffix cannot contain flow indicator characters');
	    }
	  }

	  if (tagName && !PATTERN_TAG_URI.test(tagName)) {
	    throwError(state, 'tag name cannot contain such characters: ' + tagName);
	  }

	  try {
	    tagName = decodeURIComponent(tagName);
	  } catch (err) {
	    throwError(state, 'tag name is malformed: ' + tagName);
	  }

	  if (isVerbatim) {
	    state.tag = tagName;

	  } else if (_hasOwnProperty$1.call(state.tagMap, tagHandle)) {
	    state.tag = state.tagMap[tagHandle] + tagName;

	  } else if (tagHandle === '!') {
	    state.tag = '!' + tagName;

	  } else if (tagHandle === '!!') {
	    state.tag = 'tag:yaml.org,2002:' + tagName;

	  } else {
	    throwError(state, 'undeclared tag handle "' + tagHandle + '"');
	  }

	  return true;
	}

	function readAnchorProperty(state) {
	  var _position,
	      ch;

	  ch = state.input.charCodeAt(state.position);

	  if (ch !== 0x26/* & */) return false;

	  if (state.anchor !== null) {
	    throwError(state, 'duplication of an anchor property');
	  }

	  ch = state.input.charCodeAt(++state.position);
	  _position = state.position;

	  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
	    ch = state.input.charCodeAt(++state.position);
	  }

	  if (state.position === _position) {
	    throwError(state, 'name of an anchor node must contain at least one character');
	  }

	  state.anchor = state.input.slice(_position, state.position);
	  return true;
	}

	function readAlias(state) {
	  var _position, alias,
	      ch;

	  ch = state.input.charCodeAt(state.position);

	  if (ch !== 0x2A/* * */) return false;

	  ch = state.input.charCodeAt(++state.position);
	  _position = state.position;

	  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
	    ch = state.input.charCodeAt(++state.position);
	  }

	  if (state.position === _position) {
	    throwError(state, 'name of an alias node must contain at least one character');
	  }

	  alias = state.input.slice(_position, state.position);

	  if (!_hasOwnProperty$1.call(state.anchorMap, alias)) {
	    throwError(state, 'unidentified alias "' + alias + '"');
	  }

	  state.result = state.anchorMap[alias];
	  skipSeparationSpace(state, true, -1);
	  return true;
	}

	function composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {
	  var allowBlockStyles,
	      allowBlockScalars,
	      allowBlockCollections,
	      indentStatus = 1, // 1: this>parent, 0: this=parent, -1: this<parent
	      atNewLine  = false,
	      hasContent = false,
	      typeIndex,
	      typeQuantity,
	      typeList,
	      type,
	      flowIndent,
	      blockIndent;

	  if (state.listener !== null) {
	    state.listener('open', state);
	  }

	  state.tag    = null;
	  state.anchor = null;
	  state.kind   = null;
	  state.result = null;

	  allowBlockStyles = allowBlockScalars = allowBlockCollections =
	    CONTEXT_BLOCK_OUT === nodeContext ||
	    CONTEXT_BLOCK_IN  === nodeContext;

	  if (allowToSeek) {
	    if (skipSeparationSpace(state, true, -1)) {
	      atNewLine = true;

	      if (state.lineIndent > parentIndent) {
	        indentStatus = 1;
	      } else if (state.lineIndent === parentIndent) {
	        indentStatus = 0;
	      } else if (state.lineIndent < parentIndent) {
	        indentStatus = -1;
	      }
	    }
	  }

	  if (indentStatus === 1) {
	    while (readTagProperty(state) || readAnchorProperty(state)) {
	      if (skipSeparationSpace(state, true, -1)) {
	        atNewLine = true;
	        allowBlockCollections = allowBlockStyles;

	        if (state.lineIndent > parentIndent) {
	          indentStatus = 1;
	        } else if (state.lineIndent === parentIndent) {
	          indentStatus = 0;
	        } else if (state.lineIndent < parentIndent) {
	          indentStatus = -1;
	        }
	      } else {
	        allowBlockCollections = false;
	      }
	    }
	  }

	  if (allowBlockCollections) {
	    allowBlockCollections = atNewLine || allowCompact;
	  }

	  if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {
	    if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {
	      flowIndent = parentIndent;
	    } else {
	      flowIndent = parentIndent + 1;
	    }

	    blockIndent = state.position - state.lineStart;

	    if (indentStatus === 1) {
	      if (allowBlockCollections &&
	          (readBlockSequence(state, blockIndent) ||
	           readBlockMapping(state, blockIndent, flowIndent)) ||
	          readFlowCollection(state, flowIndent)) {
	        hasContent = true;
	      } else {
	        if ((allowBlockScalars && readBlockScalar(state, flowIndent)) ||
	            readSingleQuotedScalar(state, flowIndent) ||
	            readDoubleQuotedScalar(state, flowIndent)) {
	          hasContent = true;

	        } else if (readAlias(state)) {
	          hasContent = true;

	          if (state.tag !== null || state.anchor !== null) {
	            throwError(state, 'alias node should not have any properties');
	          }

	        } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {
	          hasContent = true;

	          if (state.tag === null) {
	            state.tag = '?';
	          }
	        }

	        if (state.anchor !== null) {
	          state.anchorMap[state.anchor] = state.result;
	        }
	      }
	    } else if (indentStatus === 0) {
	      // Special case: block sequences are allowed to have same indentation level as the parent.
	      // http://www.yaml.org/spec/1.2/spec.html#id2799784
	      hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);
	    }
	  }

	  if (state.tag === null) {
	    if (state.anchor !== null) {
	      state.anchorMap[state.anchor] = state.result;
	    }

	  } else if (state.tag === '?') {
	    // Implicit resolving is not allowed for non-scalar types, and '?'
	    // non-specific tag is only automatically assigned to plain scalars.
	    //
	    // We only need to check kind conformity in case user explicitly assigns '?'
	    // tag, for example like this: "!<?> [0]"
	    //
	    if (state.result !== null && state.kind !== 'scalar') {
	      throwError(state, 'unacceptable node kind for !<?> tag; it should be "scalar", not "' + state.kind + '"');
	    }

	    for (typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1) {
	      type = state.implicitTypes[typeIndex];

	      if (type.resolve(state.result)) { // `state.result` updated in resolver if matched
	        state.result = type.construct(state.result);
	        state.tag = type.tag;
	        if (state.anchor !== null) {
	          state.anchorMap[state.anchor] = state.result;
	        }
	        break;
	      }
	    }
	  } else if (state.tag !== '!') {
	    if (_hasOwnProperty$1.call(state.typeMap[state.kind || 'fallback'], state.tag)) {
	      type = state.typeMap[state.kind || 'fallback'][state.tag];
	    } else {
	      // looking for multi type
	      type = null;
	      typeList = state.typeMap.multi[state.kind || 'fallback'];

	      for (typeIndex = 0, typeQuantity = typeList.length; typeIndex < typeQuantity; typeIndex += 1) {
	        if (state.tag.slice(0, typeList[typeIndex].tag.length) === typeList[typeIndex].tag) {
	          type = typeList[typeIndex];
	          break;
	        }
	      }
	    }

	    if (!type) {
	      throwError(state, 'unknown tag !<' + state.tag + '>');
	    }

	    if (state.result !== null && type.kind !== state.kind) {
	      throwError(state, 'unacceptable node kind for !<' + state.tag + '> tag; it should be "' + type.kind + '", not "' + state.kind + '"');
	    }

	    if (!type.resolve(state.result, state.tag)) { // `state.result` updated in resolver if matched
	      throwError(state, 'cannot resolve a node with !<' + state.tag + '> explicit tag');
	    } else {
	      state.result = type.construct(state.result, state.tag);
	      if (state.anchor !== null) {
	        state.anchorMap[state.anchor] = state.result;
	      }
	    }
	  }

	  if (state.listener !== null) {
	    state.listener('close', state);
	  }
	  return state.tag !== null ||  state.anchor !== null || hasContent;
	}

	function readDocument(state) {
	  var documentStart = state.position,
	      _position,
	      directiveName,
	      directiveArgs,
	      hasDirectives = false,
	      ch;

	  state.version = null;
	  state.checkLineBreaks = state.legacy;
	  state.tagMap = Object.create(null);
	  state.anchorMap = Object.create(null);

	  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
	    skipSeparationSpace(state, true, -1);

	    ch = state.input.charCodeAt(state.position);

	    if (state.lineIndent > 0 || ch !== 0x25/* % */) {
	      break;
	    }

	    hasDirectives = true;
	    ch = state.input.charCodeAt(++state.position);
	    _position = state.position;

	    while (ch !== 0 && !is_WS_OR_EOL(ch)) {
	      ch = state.input.charCodeAt(++state.position);
	    }

	    directiveName = state.input.slice(_position, state.position);
	    directiveArgs = [];

	    if (directiveName.length < 1) {
	      throwError(state, 'directive name must not be less than one character in length');
	    }

	    while (ch !== 0) {
	      while (is_WHITE_SPACE(ch)) {
	        ch = state.input.charCodeAt(++state.position);
	      }

	      if (ch === 0x23/* # */) {
	        do { ch = state.input.charCodeAt(++state.position); }
	        while (ch !== 0 && !is_EOL(ch));
	        break;
	      }

	      if (is_EOL(ch)) break;

	      _position = state.position;

	      while (ch !== 0 && !is_WS_OR_EOL(ch)) {
	        ch = state.input.charCodeAt(++state.position);
	      }

	      directiveArgs.push(state.input.slice(_position, state.position));
	    }

	    if (ch !== 0) readLineBreak(state);

	    if (_hasOwnProperty$1.call(directiveHandlers, directiveName)) {
	      directiveHandlers[directiveName](state, directiveName, directiveArgs);
	    } else {
	      throwWarning(state, 'unknown document directive "' + directiveName + '"');
	    }
	  }

	  skipSeparationSpace(state, true, -1);

	  if (state.lineIndent === 0 &&
	      state.input.charCodeAt(state.position)     === 0x2D/* - */ &&
	      state.input.charCodeAt(state.position + 1) === 0x2D/* - */ &&
	      state.input.charCodeAt(state.position + 2) === 0x2D/* - */) {
	    state.position += 3;
	    skipSeparationSpace(state, true, -1);

	  } else if (hasDirectives) {
	    throwError(state, 'directives end mark is expected');
	  }

	  composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);
	  skipSeparationSpace(state, true, -1);

	  if (state.checkLineBreaks &&
	      PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {
	    throwWarning(state, 'non-ASCII line breaks are interpreted as content');
	  }

	  state.documents.push(state.result);

	  if (state.position === state.lineStart && testDocumentSeparator(state)) {

	    if (state.input.charCodeAt(state.position) === 0x2E/* . */) {
	      state.position += 3;
	      skipSeparationSpace(state, true, -1);
	    }
	    return;
	  }

	  if (state.position < (state.length - 1)) {
	    throwError(state, 'end of the stream or a document separator is expected');
	  } else {
	    return;
	  }
	}


	function loadDocuments(input, options) {
	  input = String(input);
	  options = options || {};

	  if (input.length !== 0) {

	    // Add tailing `\n` if not exists
	    if (input.charCodeAt(input.length - 1) !== 0x0A/* LF */ &&
	        input.charCodeAt(input.length - 1) !== 0x0D/* CR */) {
	      input += '\n';
	    }

	    // Strip BOM
	    if (input.charCodeAt(0) === 0xFEFF) {
	      input = input.slice(1);
	    }
	  }

	  var state = new State$1(input, options);

	  var nullpos = input.indexOf('\0');

	  if (nullpos !== -1) {
	    state.position = nullpos;
	    throwError(state, 'null byte is not allowed in input');
	  }

	  // Use 0 as string terminator. That significantly simplifies bounds check.
	  state.input += '\0';

	  while (state.input.charCodeAt(state.position) === 0x20/* Space */) {
	    state.lineIndent += 1;
	    state.position += 1;
	  }

	  while (state.position < (state.length - 1)) {
	    readDocument(state);
	  }

	  return state.documents;
	}


	function loadAll(input, iterator, options) {
	  if (iterator !== null && typeof iterator === 'object' && typeof options === 'undefined') {
	    options = iterator;
	    iterator = null;
	  }

	  var documents = loadDocuments(input, options);

	  if (typeof iterator !== 'function') {
	    return documents;
	  }

	  for (var index = 0, length = documents.length; index < length; index += 1) {
	    iterator(documents[index]);
	  }
	}


	function load(input, options) {
	  var documents = loadDocuments(input, options);

	  if (documents.length === 0) {
	    /*eslint-disable no-undefined*/
	    return undefined;
	  } else if (documents.length === 1) {
	    return documents[0];
	  }
	  throw new YAMLException$1('expected a single document in the stream, but found more');
	}


	loader$1.loadAll = loadAll;
	loader$1.load    = load;

	var dumper$1 = {};

	/*eslint-disable no-use-before-define*/

	var common              = common$5;
	var YAMLException       = exception;
	var DEFAULT_SCHEMA      = _default;

	var _toString       = Object.prototype.toString;
	var _hasOwnProperty = Object.prototype.hasOwnProperty;

	var CHAR_BOM                  = 0xFEFF;
	var CHAR_TAB                  = 0x09; /* Tab */
	var CHAR_LINE_FEED            = 0x0A; /* LF */
	var CHAR_CARRIAGE_RETURN      = 0x0D; /* CR */
	var CHAR_SPACE                = 0x20; /* Space */
	var CHAR_EXCLAMATION          = 0x21; /* ! */
	var CHAR_DOUBLE_QUOTE         = 0x22; /* " */
	var CHAR_SHARP                = 0x23; /* # */
	var CHAR_PERCENT              = 0x25; /* % */
	var CHAR_AMPERSAND            = 0x26; /* & */
	var CHAR_SINGLE_QUOTE         = 0x27; /* ' */
	var CHAR_ASTERISK             = 0x2A; /* * */
	var CHAR_COMMA                = 0x2C; /* , */
	var CHAR_MINUS                = 0x2D; /* - */
	var CHAR_COLON                = 0x3A; /* : */
	var CHAR_EQUALS               = 0x3D; /* = */
	var CHAR_GREATER_THAN         = 0x3E; /* > */
	var CHAR_QUESTION             = 0x3F; /* ? */
	var CHAR_COMMERCIAL_AT        = 0x40; /* @ */
	var CHAR_LEFT_SQUARE_BRACKET  = 0x5B; /* [ */
	var CHAR_RIGHT_SQUARE_BRACKET = 0x5D; /* ] */
	var CHAR_GRAVE_ACCENT         = 0x60; /* ` */
	var CHAR_LEFT_CURLY_BRACKET   = 0x7B; /* { */
	var CHAR_VERTICAL_LINE        = 0x7C; /* | */
	var CHAR_RIGHT_CURLY_BRACKET  = 0x7D; /* } */

	var ESCAPE_SEQUENCES = {};

	ESCAPE_SEQUENCES[0x00]   = '\\0';
	ESCAPE_SEQUENCES[0x07]   = '\\a';
	ESCAPE_SEQUENCES[0x08]   = '\\b';
	ESCAPE_SEQUENCES[0x09]   = '\\t';
	ESCAPE_SEQUENCES[0x0A]   = '\\n';
	ESCAPE_SEQUENCES[0x0B]   = '\\v';
	ESCAPE_SEQUENCES[0x0C]   = '\\f';
	ESCAPE_SEQUENCES[0x0D]   = '\\r';
	ESCAPE_SEQUENCES[0x1B]   = '\\e';
	ESCAPE_SEQUENCES[0x22]   = '\\"';
	ESCAPE_SEQUENCES[0x5C]   = '\\\\';
	ESCAPE_SEQUENCES[0x85]   = '\\N';
	ESCAPE_SEQUENCES[0xA0]   = '\\_';
	ESCAPE_SEQUENCES[0x2028] = '\\L';
	ESCAPE_SEQUENCES[0x2029] = '\\P';

	var DEPRECATED_BOOLEANS_SYNTAX = [
	  'y', 'Y', 'yes', 'Yes', 'YES', 'on', 'On', 'ON',
	  'n', 'N', 'no', 'No', 'NO', 'off', 'Off', 'OFF'
	];

	var DEPRECATED_BASE60_SYNTAX = /^[-+]?[0-9_]+(?::[0-9_]+)+(?:\.[0-9_]*)?$/;

	function compileStyleMap(schema, map) {
	  var result, keys, index, length, tag, style, type;

	  if (map === null) return {};

	  result = {};
	  keys = Object.keys(map);

	  for (index = 0, length = keys.length; index < length; index += 1) {
	    tag = keys[index];
	    style = String(map[tag]);

	    if (tag.slice(0, 2) === '!!') {
	      tag = 'tag:yaml.org,2002:' + tag.slice(2);
	    }
	    type = schema.compiledTypeMap['fallback'][tag];

	    if (type && _hasOwnProperty.call(type.styleAliases, style)) {
	      style = type.styleAliases[style];
	    }

	    result[tag] = style;
	  }

	  return result;
	}

	function encodeHex(character) {
	  var string, handle, length;

	  string = character.toString(16).toUpperCase();

	  if (character <= 0xFF) {
	    handle = 'x';
	    length = 2;
	  } else if (character <= 0xFFFF) {
	    handle = 'u';
	    length = 4;
	  } else if (character <= 0xFFFFFFFF) {
	    handle = 'U';
	    length = 8;
	  } else {
	    throw new YAMLException('code point within a string may not be greater than 0xFFFFFFFF');
	  }

	  return '\\' + handle + common.repeat('0', length - string.length) + string;
	}


	var QUOTING_TYPE_SINGLE = 1,
	    QUOTING_TYPE_DOUBLE = 2;

	function State(options) {
	  this.schema        = options['schema'] || DEFAULT_SCHEMA;
	  this.indent        = Math.max(1, (options['indent'] || 2));
	  this.noArrayIndent = options['noArrayIndent'] || false;
	  this.skipInvalid   = options['skipInvalid'] || false;
	  this.flowLevel     = (common.isNothing(options['flowLevel']) ? -1 : options['flowLevel']);
	  this.styleMap      = compileStyleMap(this.schema, options['styles'] || null);
	  this.sortKeys      = options['sortKeys'] || false;
	  this.lineWidth     = options['lineWidth'] || 80;
	  this.noRefs        = options['noRefs'] || false;
	  this.noCompatMode  = options['noCompatMode'] || false;
	  this.condenseFlow  = options['condenseFlow'] || false;
	  this.quotingType   = options['quotingType'] === '"' ? QUOTING_TYPE_DOUBLE : QUOTING_TYPE_SINGLE;
	  this.forceQuotes   = options['forceQuotes'] || false;
	  this.replacer      = typeof options['replacer'] === 'function' ? options['replacer'] : null;

	  this.implicitTypes = this.schema.compiledImplicit;
	  this.explicitTypes = this.schema.compiledExplicit;

	  this.tag = null;
	  this.result = '';

	  this.duplicates = [];
	  this.usedDuplicates = null;
	}

	// Indents every line in a string. Empty lines (\n only) are not indented.
	function indentString(string, spaces) {
	  var ind = common.repeat(' ', spaces),
	      position = 0,
	      next = -1,
	      result = '',
	      line,
	      length = string.length;

	  while (position < length) {
	    next = string.indexOf('\n', position);
	    if (next === -1) {
	      line = string.slice(position);
	      position = length;
	    } else {
	      line = string.slice(position, next + 1);
	      position = next + 1;
	    }

	    if (line.length && line !== '\n') result += ind;

	    result += line;
	  }

	  return result;
	}

	function generateNextLine(state, level) {
	  return '\n' + common.repeat(' ', state.indent * level);
	}

	function testImplicitResolving(state, str) {
	  var index, length, type;

	  for (index = 0, length = state.implicitTypes.length; index < length; index += 1) {
	    type = state.implicitTypes[index];

	    if (type.resolve(str)) {
	      return true;
	    }
	  }

	  return false;
	}

	// [33] s-white ::= s-space | s-tab
	function isWhitespace(c) {
	  return c === CHAR_SPACE || c === CHAR_TAB;
	}

	// Returns true if the character can be printed without escaping.
	// From YAML 1.2: "any allowed characters known to be non-printable
	// should also be escaped. [However,] This isnt mandatory"
	// Derived from nb-char - \t - #x85 - #xA0 - #x2028 - #x2029.
	function isPrintable(c) {
	  return  (0x00020 <= c && c <= 0x00007E)
	      || ((0x000A1 <= c && c <= 0x00D7FF) && c !== 0x2028 && c !== 0x2029)
	      || ((0x0E000 <= c && c <= 0x00FFFD) && c !== CHAR_BOM)
	      ||  (0x10000 <= c && c <= 0x10FFFF);
	}

	// [34] ns-char ::= nb-char - s-white
	// [27] nb-char ::= c-printable - b-char - c-byte-order-mark
	// [26] b-char  ::= b-line-feed | b-carriage-return
	// Including s-white (for some reason, examples doesn't match specs in this aspect)
	// ns-char ::= c-printable - b-line-feed - b-carriage-return - c-byte-order-mark
	function isNsCharOrWhitespace(c) {
	  return isPrintable(c)
	    && c !== CHAR_BOM
	    // - b-char
	    && c !== CHAR_CARRIAGE_RETURN
	    && c !== CHAR_LINE_FEED;
	}

	// [127]  ns-plain-safe(c) ::= c = flow-out   ns-plain-safe-out
	//                             c = flow-in    ns-plain-safe-in
	//                             c = block-key  ns-plain-safe-out
	//                             c = flow-key   ns-plain-safe-in
	// [128] ns-plain-safe-out ::= ns-char
	// [129]  ns-plain-safe-in ::= ns-char - c-flow-indicator
	// [130]  ns-plain-char(c) ::=  ( ns-plain-safe(c) - : - # )
	//                            | ( /* An ns-char preceding */ # )
	//                            | ( : /* Followed by an ns-plain-safe(c) */ )
	function isPlainSafe(c, prev, inblock) {
	  var cIsNsCharOrWhitespace = isNsCharOrWhitespace(c);
	  var cIsNsChar = cIsNsCharOrWhitespace && !isWhitespace(c);
	  return (
	    // ns-plain-safe
	    inblock ? // c = flow-in
	      cIsNsCharOrWhitespace
	      : cIsNsCharOrWhitespace
	        // - c-flow-indicator
	        && c !== CHAR_COMMA
	        && c !== CHAR_LEFT_SQUARE_BRACKET
	        && c !== CHAR_RIGHT_SQUARE_BRACKET
	        && c !== CHAR_LEFT_CURLY_BRACKET
	        && c !== CHAR_RIGHT_CURLY_BRACKET
	  )
	    // ns-plain-char
	    && c !== CHAR_SHARP // false on '#'
	    && !(prev === CHAR_COLON && !cIsNsChar) // false on ': '
	    || (isNsCharOrWhitespace(prev) && !isWhitespace(prev) && c === CHAR_SHARP) // change to true on '[^ ]#'
	    || (prev === CHAR_COLON && cIsNsChar); // change to true on ':[^ ]'
	}

	// Simplified test for values allowed as the first character in plain style.
	function isPlainSafeFirst(c) {
	  // Uses a subset of ns-char - c-indicator
	  // where ns-char = nb-char - s-white.
	  // No support of ( ( ? | : | - ) /* Followed by an ns-plain-safe(c)) */ ) part
	  return isPrintable(c) && c !== CHAR_BOM
	    && !isWhitespace(c) // - s-white
	    // - (c-indicator ::=
	    // - | ? | : | , | [ | ] | { | }
	    && c !== CHAR_MINUS
	    && c !== CHAR_QUESTION
	    && c !== CHAR_COLON
	    && c !== CHAR_COMMA
	    && c !== CHAR_LEFT_SQUARE_BRACKET
	    && c !== CHAR_RIGHT_SQUARE_BRACKET
	    && c !== CHAR_LEFT_CURLY_BRACKET
	    && c !== CHAR_RIGHT_CURLY_BRACKET
	    // | # | & | * | ! | | | = | > | ' | "
	    && c !== CHAR_SHARP
	    && c !== CHAR_AMPERSAND
	    && c !== CHAR_ASTERISK
	    && c !== CHAR_EXCLAMATION
	    && c !== CHAR_VERTICAL_LINE
	    && c !== CHAR_EQUALS
	    && c !== CHAR_GREATER_THAN
	    && c !== CHAR_SINGLE_QUOTE
	    && c !== CHAR_DOUBLE_QUOTE
	    // | % | @ | `)
	    && c !== CHAR_PERCENT
	    && c !== CHAR_COMMERCIAL_AT
	    && c !== CHAR_GRAVE_ACCENT;
	}

	// Simplified test for values allowed as the last character in plain style.
	function isPlainSafeLast(c) {
	  // just not whitespace or colon, it will be checked to be plain character later
	  return !isWhitespace(c) && c !== CHAR_COLON;
	}

	// Same as 'string'.codePointAt(pos), but works in older browsers.
	function codePointAt(string, pos) {
	  var first = string.charCodeAt(pos), second;
	  if (first >= 0xD800 && first <= 0xDBFF && pos + 1 < string.length) {
	    second = string.charCodeAt(pos + 1);
	    if (second >= 0xDC00 && second <= 0xDFFF) {
	      // https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
	      return (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;
	    }
	  }
	  return first;
	}

	// Determines whether block indentation indicator is required.
	function needIndentIndicator(string) {
	  var leadingSpaceRe = /^\n* /;
	  return leadingSpaceRe.test(string);
	}

	var STYLE_PLAIN   = 1,
	    STYLE_SINGLE  = 2,
	    STYLE_LITERAL = 3,
	    STYLE_FOLDED  = 4,
	    STYLE_DOUBLE  = 5;

	// Determines which scalar styles are possible and returns the preferred style.
	// lineWidth = -1 => no limit.
	// Pre-conditions: str.length > 0.
	// Post-conditions:
	//    STYLE_PLAIN or STYLE_SINGLE => no \n are in the string.
	//    STYLE_LITERAL => no lines are suitable for folding (or lineWidth is -1).
	//    STYLE_FOLDED => a line > lineWidth and can be folded (and lineWidth != -1).
	function chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth,
	  testAmbiguousType, quotingType, forceQuotes, inblock) {

	  var i;
	  var char = 0;
	  var prevChar = null;
	  var hasLineBreak = false;
	  var hasFoldableLine = false; // only checked if shouldTrackWidth
	  var shouldTrackWidth = lineWidth !== -1;
	  var previousLineBreak = -1; // count the first line correctly
	  var plain = isPlainSafeFirst(codePointAt(string, 0))
	          && isPlainSafeLast(codePointAt(string, string.length - 1));

	  if (singleLineOnly || forceQuotes) {
	    // Case: no block styles.
	    // Check for disallowed characters to rule out plain and single.
	    for (i = 0; i < string.length; char >= 0x10000 ? i += 2 : i++) {
	      char = codePointAt(string, i);
	      if (!isPrintable(char)) {
	        return STYLE_DOUBLE;
	      }
	      plain = plain && isPlainSafe(char, prevChar, inblock);
	      prevChar = char;
	    }
	  } else {
	    // Case: block styles permitted.
	    for (i = 0; i < string.length; char >= 0x10000 ? i += 2 : i++) {
	      char = codePointAt(string, i);
	      if (char === CHAR_LINE_FEED) {
	        hasLineBreak = true;
	        // Check if any line can be folded.
	        if (shouldTrackWidth) {
	          hasFoldableLine = hasFoldableLine ||
	            // Foldable line = too long, and not more-indented.
	            (i - previousLineBreak - 1 > lineWidth &&
	             string[previousLineBreak + 1] !== ' ');
	          previousLineBreak = i;
	        }
	      } else if (!isPrintable(char)) {
	        return STYLE_DOUBLE;
	      }
	      plain = plain && isPlainSafe(char, prevChar, inblock);
	      prevChar = char;
	    }
	    // in case the end is missing a \n
	    hasFoldableLine = hasFoldableLine || (shouldTrackWidth &&
	      (i - previousLineBreak - 1 > lineWidth &&
	       string[previousLineBreak + 1] !== ' '));
	  }
	  // Although every style can represent \n without escaping, prefer block styles
	  // for multiline, since they're more readable and they don't add empty lines.
	  // Also prefer folding a super-long line.
	  if (!hasLineBreak && !hasFoldableLine) {
	    // Strings interpretable as another type have to be quoted;
	    // e.g. the string 'true' vs. the boolean true.
	    if (plain && !forceQuotes && !testAmbiguousType(string)) {
	      return STYLE_PLAIN;
	    }
	    return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;
	  }
	  // Edge case: block indentation indicator can only have one digit.
	  if (indentPerLevel > 9 && needIndentIndicator(string)) {
	    return STYLE_DOUBLE;
	  }
	  // At this point we know block styles are valid.
	  // Prefer literal style unless we want to fold.
	  if (!forceQuotes) {
	    return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;
	  }
	  return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;
	}

	// Note: line breaking/folding is implemented for only the folded style.
	// NB. We drop the last trailing newline (if any) of a returned block scalar
	//  since the dumper adds its own newline. This always works:
	//     No ending newline => unaffected; already using strip "-" chomping.
	//     Ending newline    => removed then restored.
	//  Importantly, this keeps the "+" chomp indicator from gaining an extra line.
	function writeScalar(state, string, level, iskey, inblock) {
	  state.dump = (function () {
	    if (string.length === 0) {
	      return state.quotingType === QUOTING_TYPE_DOUBLE ? '""' : "''";
	    }
	    if (!state.noCompatMode) {
	      if (DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1 || DEPRECATED_BASE60_SYNTAX.test(string)) {
	        return state.quotingType === QUOTING_TYPE_DOUBLE ? ('"' + string + '"') : ("'" + string + "'");
	      }
	    }

	    var indent = state.indent * Math.max(1, level); // no 0-indent scalars
	    // As indentation gets deeper, let the width decrease monotonically
	    // to the lower bound min(state.lineWidth, 40).
	    // Note that this implies
	    //  state.lineWidth  40 + state.indent: width is fixed at the lower bound.
	    //  state.lineWidth > 40 + state.indent: width decreases until the lower bound.
	    // This behaves better than a constant minimum width which disallows narrower options,
	    // or an indent threshold which causes the width to suddenly increase.
	    var lineWidth = state.lineWidth === -1
	      ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent);

	    // Without knowing if keys are implicit/explicit, assume implicit for safety.
	    var singleLineOnly = iskey
	      // No block styles in flow mode.
	      || (state.flowLevel > -1 && level >= state.flowLevel);
	    function testAmbiguity(string) {
	      return testImplicitResolving(state, string);
	    }

	    switch (chooseScalarStyle(string, singleLineOnly, state.indent, lineWidth,
	      testAmbiguity, state.quotingType, state.forceQuotes && !iskey, inblock)) {

	      case STYLE_PLAIN:
	        return string;
	      case STYLE_SINGLE:
	        return "'" + string.replace(/'/g, "''") + "'";
	      case STYLE_LITERAL:
	        return '|' + blockHeader(string, state.indent)
	          + dropEndingNewline(indentString(string, indent));
	      case STYLE_FOLDED:
	        return '>' + blockHeader(string, state.indent)
	          + dropEndingNewline(indentString(foldString(string, lineWidth), indent));
	      case STYLE_DOUBLE:
	        return '"' + escapeString(string) + '"';
	      default:
	        throw new YAMLException('impossible error: invalid scalar style');
	    }
	  }());
	}

	// Pre-conditions: string is valid for a block scalar, 1 <= indentPerLevel <= 9.
	function blockHeader(string, indentPerLevel) {
	  var indentIndicator = needIndentIndicator(string) ? String(indentPerLevel) : '';

	  // note the special case: the string '\n' counts as a "trailing" empty line.
	  var clip =          string[string.length - 1] === '\n';
	  var keep = clip && (string[string.length - 2] === '\n' || string === '\n');
	  var chomp = keep ? '+' : (clip ? '' : '-');

	  return indentIndicator + chomp + '\n';
	}

	// (See the note for writeScalar.)
	function dropEndingNewline(string) {
	  return string[string.length - 1] === '\n' ? string.slice(0, -1) : string;
	}

	// Note: a long line without a suitable break point will exceed the width limit.
	// Pre-conditions: every char in str isPrintable, str.length > 0, width > 0.
	function foldString(string, width) {
	  // In folded style, $k$ consecutive newlines output as $k+1$ newlines
	  // unless they're before or after a more-indented line, or at the very
	  // beginning or end, in which case $k$ maps to $k$.
	  // Therefore, parse each chunk as newline(s) followed by a content line.
	  var lineRe = /(\n+)([^\n]*)/g;

	  // first line (possibly an empty line)
	  var result = (function () {
	    var nextLF = string.indexOf('\n');
	    nextLF = nextLF !== -1 ? nextLF : string.length;
	    lineRe.lastIndex = nextLF;
	    return foldLine(string.slice(0, nextLF), width);
	  }());
	  // If we haven't reached the first content line yet, don't add an extra \n.
	  var prevMoreIndented = string[0] === '\n' || string[0] === ' ';
	  var moreIndented;

	  // rest of the lines
	  var match;
	  while ((match = lineRe.exec(string))) {
	    var prefix = match[1], line = match[2];
	    moreIndented = (line[0] === ' ');
	    result += prefix
	      + (!prevMoreIndented && !moreIndented && line !== ''
	        ? '\n' : '')
	      + foldLine(line, width);
	    prevMoreIndented = moreIndented;
	  }

	  return result;
	}

	// Greedy line breaking.
	// Picks the longest line under the limit each time,
	// otherwise settles for the shortest line over the limit.
	// NB. More-indented lines *cannot* be folded, as that would add an extra \n.
	function foldLine(line, width) {
	  if (line === '' || line[0] === ' ') return line;

	  // Since a more-indented line adds a \n, breaks can't be followed by a space.
	  var breakRe = / [^ ]/g; // note: the match index will always be <= length-2.
	  var match;
	  // start is an inclusive index. end, curr, and next are exclusive.
	  var start = 0, end, curr = 0, next = 0;
	  var result = '';

	  // Invariants: 0 <= start <= length-1.
	  //   0 <= curr <= next <= max(0, length-2). curr - start <= width.
	  // Inside the loop:
	  //   A match implies length >= 2, so curr and next are <= length-2.
	  while ((match = breakRe.exec(line))) {
	    next = match.index;
	    // maintain invariant: curr - start <= width
	    if (next - start > width) {
	      end = (curr > start) ? curr : next; // derive end <= length-2
	      result += '\n' + line.slice(start, end);
	      // skip the space that was output as \n
	      start = end + 1;                    // derive start <= length-1
	    }
	    curr = next;
	  }

	  // By the invariants, start <= length-1, so there is something left over.
	  // It is either the whole string or a part starting from non-whitespace.
	  result += '\n';
	  // Insert a break if the remainder is too long and there is a break available.
	  if (line.length - start > width && curr > start) {
	    result += line.slice(start, curr) + '\n' + line.slice(curr + 1);
	  } else {
	    result += line.slice(start);
	  }

	  return result.slice(1); // drop extra \n joiner
	}

	// Escapes a double-quoted string.
	function escapeString(string) {
	  var result = '';
	  var char = 0;
	  var escapeSeq;

	  for (var i = 0; i < string.length; char >= 0x10000 ? i += 2 : i++) {
	    char = codePointAt(string, i);
	    escapeSeq = ESCAPE_SEQUENCES[char];

	    if (!escapeSeq && isPrintable(char)) {
	      result += string[i];
	      if (char >= 0x10000) result += string[i + 1];
	    } else {
	      result += escapeSeq || encodeHex(char);
	    }
	  }

	  return result;
	}

	function writeFlowSequence(state, level, object) {
	  var _result = '',
	      _tag    = state.tag,
	      index,
	      length,
	      value;

	  for (index = 0, length = object.length; index < length; index += 1) {
	    value = object[index];

	    if (state.replacer) {
	      value = state.replacer.call(object, String(index), value);
	    }

	    // Write only valid elements, put null instead of invalid elements.
	    if (writeNode(state, level, value, false, false) ||
	        (typeof value === 'undefined' &&
	         writeNode(state, level, null, false, false))) {

	      if (_result !== '') _result += ',' + (!state.condenseFlow ? ' ' : '');
	      _result += state.dump;
	    }
	  }

	  state.tag = _tag;
	  state.dump = '[' + _result + ']';
	}

	function writeBlockSequence(state, level, object, compact) {
	  var _result = '',
	      _tag    = state.tag,
	      index,
	      length,
	      value;

	  for (index = 0, length = object.length; index < length; index += 1) {
	    value = object[index];

	    if (state.replacer) {
	      value = state.replacer.call(object, String(index), value);
	    }

	    // Write only valid elements, put null instead of invalid elements.
	    if (writeNode(state, level + 1, value, true, true, false, true) ||
	        (typeof value === 'undefined' &&
	         writeNode(state, level + 1, null, true, true, false, true))) {

	      if (!compact || _result !== '') {
	        _result += generateNextLine(state, level);
	      }

	      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
	        _result += '-';
	      } else {
	        _result += '- ';
	      }

	      _result += state.dump;
	    }
	  }

	  state.tag = _tag;
	  state.dump = _result || '[]'; // Empty sequence if no valid values.
	}

	function writeFlowMapping(state, level, object) {
	  var _result       = '',
	      _tag          = state.tag,
	      objectKeyList = Object.keys(object),
	      index,
	      length,
	      objectKey,
	      objectValue,
	      pairBuffer;

	  for (index = 0, length = objectKeyList.length; index < length; index += 1) {

	    pairBuffer = '';
	    if (_result !== '') pairBuffer += ', ';

	    if (state.condenseFlow) pairBuffer += '"';

	    objectKey = objectKeyList[index];
	    objectValue = object[objectKey];

	    if (state.replacer) {
	      objectValue = state.replacer.call(object, objectKey, objectValue);
	    }

	    if (!writeNode(state, level, objectKey, false, false)) {
	      continue; // Skip this pair because of invalid key;
	    }

	    if (state.dump.length > 1024) pairBuffer += '? ';

	    pairBuffer += state.dump + (state.condenseFlow ? '"' : '') + ':' + (state.condenseFlow ? '' : ' ');

	    if (!writeNode(state, level, objectValue, false, false)) {
	      continue; // Skip this pair because of invalid value.
	    }

	    pairBuffer += state.dump;

	    // Both key and value are valid.
	    _result += pairBuffer;
	  }

	  state.tag = _tag;
	  state.dump = '{' + _result + '}';
	}

	function writeBlockMapping(state, level, object, compact) {
	  var _result       = '',
	      _tag          = state.tag,
	      objectKeyList = Object.keys(object),
	      index,
	      length,
	      objectKey,
	      objectValue,
	      explicitPair,
	      pairBuffer;

	  // Allow sorting keys so that the output file is deterministic
	  if (state.sortKeys === true) {
	    // Default sorting
	    objectKeyList.sort();
	  } else if (typeof state.sortKeys === 'function') {
	    // Custom sort function
	    objectKeyList.sort(state.sortKeys);
	  } else if (state.sortKeys) {
	    // Something is wrong
	    throw new YAMLException('sortKeys must be a boolean or a function');
	  }

	  for (index = 0, length = objectKeyList.length; index < length; index += 1) {
	    pairBuffer = '';

	    if (!compact || _result !== '') {
	      pairBuffer += generateNextLine(state, level);
	    }

	    objectKey = objectKeyList[index];
	    objectValue = object[objectKey];

	    if (state.replacer) {
	      objectValue = state.replacer.call(object, objectKey, objectValue);
	    }

	    if (!writeNode(state, level + 1, objectKey, true, true, true)) {
	      continue; // Skip this pair because of invalid key.
	    }

	    explicitPair = (state.tag !== null && state.tag !== '?') ||
	                   (state.dump && state.dump.length > 1024);

	    if (explicitPair) {
	      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
	        pairBuffer += '?';
	      } else {
	        pairBuffer += '? ';
	      }
	    }

	    pairBuffer += state.dump;

	    if (explicitPair) {
	      pairBuffer += generateNextLine(state, level);
	    }

	    if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {
	      continue; // Skip this pair because of invalid value.
	    }

	    if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
	      pairBuffer += ':';
	    } else {
	      pairBuffer += ': ';
	    }

	    pairBuffer += state.dump;

	    // Both key and value are valid.
	    _result += pairBuffer;
	  }

	  state.tag = _tag;
	  state.dump = _result || '{}'; // Empty mapping if no valid pairs.
	}

	function detectType(state, object, explicit) {
	  var _result, typeList, index, length, type, style;

	  typeList = explicit ? state.explicitTypes : state.implicitTypes;

	  for (index = 0, length = typeList.length; index < length; index += 1) {
	    type = typeList[index];

	    if ((type.instanceOf  || type.predicate) &&
	        (!type.instanceOf || ((typeof object === 'object') && (object instanceof type.instanceOf))) &&
	        (!type.predicate  || type.predicate(object))) {

	      if (explicit) {
	        if (type.multi && type.representName) {
	          state.tag = type.representName(object);
	        } else {
	          state.tag = type.tag;
	        }
	      } else {
	        state.tag = '?';
	      }

	      if (type.represent) {
	        style = state.styleMap[type.tag] || type.defaultStyle;

	        if (_toString.call(type.represent) === '[object Function]') {
	          _result = type.represent(object, style);
	        } else if (_hasOwnProperty.call(type.represent, style)) {
	          _result = type.represent[style](object, style);
	        } else {
	          throw new YAMLException('!<' + type.tag + '> tag resolver accepts not "' + style + '" style');
	        }

	        state.dump = _result;
	      }

	      return true;
	    }
	  }

	  return false;
	}

	// Serializes `object` and writes it to global `result`.
	// Returns true on success, or false on invalid object.
	//
	function writeNode(state, level, object, block, compact, iskey, isblockseq) {
	  state.tag = null;
	  state.dump = object;

	  if (!detectType(state, object, false)) {
	    detectType(state, object, true);
	  }

	  var type = _toString.call(state.dump);
	  var inblock = block;
	  var tagStr;

	  if (block) {
	    block = (state.flowLevel < 0 || state.flowLevel > level);
	  }

	  var objectOrArray = type === '[object Object]' || type === '[object Array]',
	      duplicateIndex,
	      duplicate;

	  if (objectOrArray) {
	    duplicateIndex = state.duplicates.indexOf(object);
	    duplicate = duplicateIndex !== -1;
	  }

	  if ((state.tag !== null && state.tag !== '?') || duplicate || (state.indent !== 2 && level > 0)) {
	    compact = false;
	  }

	  if (duplicate && state.usedDuplicates[duplicateIndex]) {
	    state.dump = '*ref_' + duplicateIndex;
	  } else {
	    if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {
	      state.usedDuplicates[duplicateIndex] = true;
	    }
	    if (type === '[object Object]') {
	      if (block && (Object.keys(state.dump).length !== 0)) {
	        writeBlockMapping(state, level, state.dump, compact);
	        if (duplicate) {
	          state.dump = '&ref_' + duplicateIndex + state.dump;
	        }
	      } else {
	        writeFlowMapping(state, level, state.dump);
	        if (duplicate) {
	          state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;
	        }
	      }
	    } else if (type === '[object Array]') {
	      if (block && (state.dump.length !== 0)) {
	        if (state.noArrayIndent && !isblockseq && level > 0) {
	          writeBlockSequence(state, level - 1, state.dump, compact);
	        } else {
	          writeBlockSequence(state, level, state.dump, compact);
	        }
	        if (duplicate) {
	          state.dump = '&ref_' + duplicateIndex + state.dump;
	        }
	      } else {
	        writeFlowSequence(state, level, state.dump);
	        if (duplicate) {
	          state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;
	        }
	      }
	    } else if (type === '[object String]') {
	      if (state.tag !== '?') {
	        writeScalar(state, state.dump, level, iskey, inblock);
	      }
	    } else if (type === '[object Undefined]') {
	      return false;
	    } else {
	      if (state.skipInvalid) return false;
	      throw new YAMLException('unacceptable kind of an object to dump ' + type);
	    }

	    if (state.tag !== null && state.tag !== '?') {
	      // Need to encode all characters except those allowed by the spec:
	      //
	      // [35] ns-dec-digit    ::=  [#x30-#x39] /* 0-9 */
	      // [36] ns-hex-digit    ::=  ns-dec-digit
	      //                         | [#x41-#x46] /* A-F */ | [#x61-#x66] /* a-f */
	      // [37] ns-ascii-letter ::=  [#x41-#x5A] /* A-Z */ | [#x61-#x7A] /* a-z */
	      // [38] ns-word-char    ::=  ns-dec-digit | ns-ascii-letter | -
	      // [39] ns-uri-char     ::=  % ns-hex-digit ns-hex-digit | ns-word-char | #
	      //                         | ; | / | ? | : | @ | & | = | + | $ | ,
	      //                         | _ | . | ! | ~ | * | ' | ( | ) | [ | ]
	      //
	      // Also need to encode '!' because it has special meaning (end of tag prefix).
	      //
	      tagStr = encodeURI(
	        state.tag[0] === '!' ? state.tag.slice(1) : state.tag
	      ).replace(/!/g, '%21');

	      if (state.tag[0] === '!') {
	        tagStr = '!' + tagStr;
	      } else if (tagStr.slice(0, 18) === 'tag:yaml.org,2002:') {
	        tagStr = '!!' + tagStr.slice(18);
	      } else {
	        tagStr = '!<' + tagStr + '>';
	      }

	      state.dump = tagStr + ' ' + state.dump;
	    }
	  }

	  return true;
	}

	function getDuplicateReferences(object, state) {
	  var objects = [],
	      duplicatesIndexes = [],
	      index,
	      length;

	  inspectNode(object, objects, duplicatesIndexes);

	  for (index = 0, length = duplicatesIndexes.length; index < length; index += 1) {
	    state.duplicates.push(objects[duplicatesIndexes[index]]);
	  }
	  state.usedDuplicates = new Array(length);
	}

	function inspectNode(object, objects, duplicatesIndexes) {
	  var objectKeyList,
	      index,
	      length;

	  if (object !== null && typeof object === 'object') {
	    index = objects.indexOf(object);
	    if (index !== -1) {
	      if (duplicatesIndexes.indexOf(index) === -1) {
	        duplicatesIndexes.push(index);
	      }
	    } else {
	      objects.push(object);

	      if (Array.isArray(object)) {
	        for (index = 0, length = object.length; index < length; index += 1) {
	          inspectNode(object[index], objects, duplicatesIndexes);
	        }
	      } else {
	        objectKeyList = Object.keys(object);

	        for (index = 0, length = objectKeyList.length; index < length; index += 1) {
	          inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);
	        }
	      }
	    }
	  }
	}

	function dump(input, options) {
	  options = options || {};

	  var state = new State(options);

	  if (!state.noRefs) getDuplicateReferences(input, state);

	  var value = input;

	  if (state.replacer) {
	    value = state.replacer.call({ '': value }, '', value);
	  }

	  if (writeNode(state, 0, value, true, true)) return state.dump + '\n';

	  return '';
	}

	dumper$1.dump = dump;

	var loader = loader$1;
	var dumper = dumper$1;


	function renamed(from, to) {
	  return function () {
	    throw new Error('Function yaml.' + from + ' is removed in js-yaml 4. ' +
	      'Use yaml.' + to + ' instead, which is now safe by default.');
	  };
	}


	jsYaml.Type                = type;
	jsYaml.Schema              = schema;
	jsYaml.FAILSAFE_SCHEMA     = failsafe;
	jsYaml.JSON_SCHEMA         = json;
	jsYaml.CORE_SCHEMA         = core;
	jsYaml.DEFAULT_SCHEMA      = _default;
	jsYaml.load                = loader.load;
	jsYaml.loadAll             = loader.loadAll;
	jsYaml.dump                = dumper.dump;
	jsYaml.YAMLException       = exception;

	// Re-export all types in case user wants to create custom schema
	jsYaml.types = {
	  binary:    binary$1,
	  float:     float,
	  map:       map,
	  null:      _null,
	  pairs:     pairs,
	  set:       set,
	  timestamp: timestamp,
	  bool:      bool,
	  int:       int,
	  merge:     merge,
	  omap:      omap,
	  seq:       seq,
	  str:       str
	};

	// Removed functions from JS-YAML 3.0.x
	jsYaml.safeLoad            = renamed('safeLoad', 'load');
	jsYaml.safeLoadAll         = renamed('safeLoadAll', 'loadAll');
	jsYaml.safeDump            = renamed('safeDump', 'dump');

	(function (exports) {
		Object.defineProperty(exports, "__esModule", {
		    value: true
		});
		Object.defineProperty(exports, "default", {
		    enumerable: true,
		    get: function() {
		        return _default;
		    }
		});
		var _errorsJs = errors;
		var _jsYaml = /*#__PURE__*/ _interopRequireWildcard(jsYaml);
		function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
		    try {
		        var info = gen[key](arg);
		        var value = info.value;
		    } catch (error) {
		        reject(error);
		        return;
		    }
		    if (info.done) {
		        resolve(value);
		    } else {
		        Promise.resolve(value).then(_next, _throw);
		    }
		}
		function _asyncToGenerator(fn) {
		    return function() {
		        var self = this, args = arguments;
		        return new Promise(function(resolve, reject) {
		            var gen = fn.apply(self, args);
		            function _next(value) {
		                asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
		            }
		            function _throw(err) {
		                asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
		            }
		            _next(undefined);
		        });
		    };
		}
		function _getRequireWildcardCache(nodeInterop) {
		    if (typeof WeakMap !== "function") return null;
		    var cacheBabelInterop = new WeakMap();
		    var cacheNodeInterop = new WeakMap();
		    return (_getRequireWildcardCache = function(nodeInterop) {
		        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
		    })(nodeInterop);
		}
		function _interopRequireWildcard(obj, nodeInterop) {
		    if (obj && obj.__esModule) {
		        return obj;
		    }
		    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
		        return {
		            default: obj
		        };
		    }
		    var cache = _getRequireWildcardCache(nodeInterop);
		    if (cache && cache.has(obj)) {
		        return cache.get(obj);
		    }
		    var newObj = {};
		    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
		    for(var key in obj){
		        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
		            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
		            if (desc && (desc.get || desc.set)) {
		                Object.defineProperty(newObj, key, desc);
		            } else {
		                newObj[key] = obj[key];
		            }
		        }
		    }
		    newObj.default = obj;
		    if (cache) {
		        cache.set(obj, newObj);
		    }
		    return newObj;
		}
		var __generator = function(thisArg, body) {
		    var f, y, t, g, _ = {
		        label: 0,
		        sent: function() {
		            if (t[0] & 1) throw t[1];
		            return t[1];
		        },
		        trys: [],
		        ops: []
		    };
		    return g = {
		        next: verb(0),
		        "throw": verb(1),
		        "return": verb(2)
		    }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
		        return this;
		    }), g;
		    function verb(n) {
		        return function(v) {
		            return step([
		                n,
		                v
		            ]);
		        };
		    }
		    function step(op) {
		        if (f) throw new TypeError("Generator is already executing.");
		        while(_)try {
		            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
		            if (y = 0, t) op = [
		                op[0] & 2,
		                t.value
		            ];
		            switch(op[0]){
		                case 0:
		                case 1:
		                    t = op;
		                    break;
		                case 4:
		                    _.label++;
		                    return {
		                        value: op[1],
		                        done: false
		                    };
		                case 5:
		                    _.label++;
		                    y = op[1];
		                    op = [
		                        0
		                    ];
		                    continue;
		                case 7:
		                    op = _.ops.pop();
		                    _.trys.pop();
		                    continue;
		                default:
		                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
		                        _ = 0;
		                        continue;
		                    }
		                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
		                        _.label = op[1];
		                        break;
		                    }
		                    if (op[0] === 6 && _.label < t[1]) {
		                        _.label = t[1];
		                        t = op;
		                        break;
		                    }
		                    if (t && _.label < t[2]) {
		                        _.label = t[2];
		                        _.ops.push(op);
		                        break;
		                    }
		                    if (t[2]) _.ops.pop();
		                    _.trys.pop();
		                    continue;
		            }
		            op = body.call(thisArg, _);
		        } catch (e) {
		            op = [
		                6,
		                e
		            ];
		            y = 0;
		        } finally{
		            f = t = 0;
		        }
		        if (op[0] & 5) throw op[1];
		        return {
		            value: op[0] ? op[1] : void 0,
		            done: true
		        };
		    }
		};
		var _default = {
		    /**
		   * The order that this parser will run, in relation to other parsers.
		   *
		   * @type {number}
		   */ order: 200,
		    /**
		   * Whether to allow "empty" files. This includes zero-byte files, as well as empty JSON objects.
		   *
		   * @type {boolean}
		   */ allowEmpty: true,
		    /**
		   * Determines whether this parser can parse a given file reference.
		   * Parsers that match will be tried, in order, until one successfully parses the file.
		   * Parsers that don't match will be skipped, UNLESS none of the parsers match, in which case
		   * every parser will be tried.
		   *
		   * @type {RegExp|string[]|function}
		   */ canParse: [
		        ".yaml",
		        ".yml",
		        ".json"
		    ],
		    parse: /**
		   * Parses the given file as YAML
		   *
		   * @param {object} file           - An object containing information about the referenced file
		   * @param {string} file.url       - The full URL of the referenced file
		   * @param {string} file.extension - The lowercased file extension (e.g. ".txt", ".html", etc.)
		   * @param {*}      file.data      - The file contents. This will be whatever data type was returned by the resolver
		   * @returns {Promise}
		   */ function parse(file) {
		        return _asyncToGenerator(function() {
		            var data;
		            return __generator(this, function(_state) {
		                data = file.data;
		                if (Buffer.isBuffer(data)) {
		                    data = data.toString();
		                }
		                if (typeof data === "string") {
		                    try {
		                        return [
		                            2,
		                            _jsYaml.default.load(data, {
		                                schema: _jsYaml.JSON_SCHEMA
		                            })
		                        ];
		                    } catch (e) {
		                        throw new _errorsJs.ParserError(e.message, file.url);
		                    }
		                } else {
		                    // data is already a JavaScript value (object, array, number, null, NaN, etc.)
		                    return [
		                        2,
		                        data
		                    ];
		                }
		                return [
		                    2
		                ];
		            });
		        })();
		    }
		}; 
	} (yaml));

	var text = {};

	(function (exports) {
		Object.defineProperty(exports, "__esModule", {
		    value: true
		});
		Object.defineProperty(exports, "default", {
		    enumerable: true,
		    get: function() {
		        return _default;
		    }
		});
		var _errorsJs = errors;
		var TEXT_REGEXP = /\.(txt|htm|html|md|xml|js|min|map|css|scss|less|svg)$/i;
		var _default = {
		    /**
		   * The order that this parser will run, in relation to other parsers.
		   *
		   * @type {number}
		   */ order: 300,
		    /**
		   * Whether to allow "empty" files (zero bytes).
		   *
		   * @type {boolean}
		   */ allowEmpty: true,
		    /**
		   * The encoding that the text is expected to be in.
		   *
		   * @type {string}
		   */ encoding: "utf8",
		    /**
		   * Determines whether this parser can parse a given file reference.
		   * Parsers that return true will be tried, in order, until one successfully parses the file.
		   * Parsers that return false will be skipped, UNLESS all parsers returned false, in which case
		   * every parser will be tried.
		   *
		   * @param {object} file           - An object containing information about the referenced file
		   * @param {string} file.url       - The full URL of the referenced file
		   * @param {string} file.extension - The lowercased file extension (e.g. ".txt", ".html", etc.)
		   * @param {*}      file.data      - The file contents. This will be whatever data type was returned by the resolver
		   * @returns {boolean}
		   */ canParse: function canParse(file) {
		        // Use this parser if the file is a string or Buffer, and has a known text-based extension
		        return (typeof file.data === "string" || Buffer.isBuffer(file.data)) && TEXT_REGEXP.test(file.url);
		    },
		    /**
		   * Parses the given file as text
		   *
		   * @param {object} file           - An object containing information about the referenced file
		   * @param {string} file.url       - The full URL of the referenced file
		   * @param {string} file.extension - The lowercased file extension (e.g. ".txt", ".html", etc.)
		   * @param {*}      file.data      - The file contents. This will be whatever data type was returned by the resolver
		   * @returns {string}
		   */ parse: function parse(file) {
		        if (typeof file.data === "string") {
		            return file.data;
		        } else if (Buffer.isBuffer(file.data)) {
		            return file.data.toString(this.encoding);
		        } else {
		            throw new _errorsJs.ParserError("data is not text", file.url);
		        }
		    }
		}; 
	} (text));

	var binary = {};

	(function (exports) {
		Object.defineProperty(exports, "__esModule", {
		    value: true
		});
		Object.defineProperty(exports, "default", {
		    enumerable: true,
		    get: function() {
		        return _default;
		    }
		});
		var BINARY_REGEXP = /\.(jpeg|jpg|gif|png|bmp|ico)$/i;
		var _default = {
		    /**
		   * The order that this parser will run, in relation to other parsers.
		   *
		   * @type {number}
		   */ order: 400,
		    /**
		   * Whether to allow "empty" files (zero bytes).
		   *
		   * @type {boolean}
		   */ allowEmpty: true,
		    /**
		   * Determines whether this parser can parse a given file reference.
		   * Parsers that return true will be tried, in order, until one successfully parses the file.
		   * Parsers that return false will be skipped, UNLESS all parsers returned false, in which case
		   * every parser will be tried.
		   *
		   * @param {object} file           - An object containing information about the referenced file
		   * @param {string} file.url       - The full URL of the referenced file
		   * @param {string} file.extension - The lowercased file extension (e.g. ".txt", ".html", etc.)
		   * @param {*}      file.data      - The file contents. This will be whatever data type was returned by the resolver
		   * @returns {boolean}
		   */ canParse: function canParse(file) {
		        // Use this parser if the file is a Buffer, and has a known binary extension
		        return Buffer.isBuffer(file.data) && BINARY_REGEXP.test(file.url);
		    },
		    /**
		   * Parses the given data as a Buffer (byte array).
		   *
		   * @param {object} file           - An object containing information about the referenced file
		   * @param {string} file.url       - The full URL of the referenced file
		   * @param {string} file.extension - The lowercased file extension (e.g. ".txt", ".html", etc.)
		   * @param {*}      file.data      - The file contents. This will be whatever data type was returned by the resolver
		   * @returns {Buffer}
		   */ parse: function parse(file) {
		        if (Buffer.isBuffer(file.data)) {
		            return file.data;
		        } else {
		            // This will reject if data is anything other than a string or typed array
		            return Buffer.from(file.data);
		        }
		    }
		}; 
	} (binary));

	var file = {};

	(function (exports) {
		Object.defineProperty(exports, "__esModule", {
		    value: true
		});
		Object.defineProperty(exports, "default", {
		    enumerable: true,
		    get: function() {
		        return _default;
		    }
		});
		var _fs = /*#__PURE__*/ _interopRequireDefault(require$$0);
		var _ono = require$$9;
		var _urlJs = /*#__PURE__*/ _interopRequireWildcard(url);
		var _errorsJs = errors;
		function _interopRequireDefault(obj) {
		    return obj && obj.__esModule ? obj : {
		        default: obj
		    };
		}
		function _getRequireWildcardCache(nodeInterop) {
		    if (typeof WeakMap !== "function") return null;
		    var cacheBabelInterop = new WeakMap();
		    var cacheNodeInterop = new WeakMap();
		    return (_getRequireWildcardCache = function(nodeInterop) {
		        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
		    })(nodeInterop);
		}
		function _interopRequireWildcard(obj, nodeInterop) {
		    if (obj && obj.__esModule) {
		        return obj;
		    }
		    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
		        return {
		            default: obj
		        };
		    }
		    var cache = _getRequireWildcardCache(nodeInterop);
		    if (cache && cache.has(obj)) {
		        return cache.get(obj);
		    }
		    var newObj = {};
		    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
		    for(var key in obj){
		        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
		            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
		            if (desc && (desc.get || desc.set)) {
		                Object.defineProperty(newObj, key, desc);
		            } else {
		                newObj[key] = obj[key];
		            }
		        }
		    }
		    newObj.default = obj;
		    if (cache) {
		        cache.set(obj, newObj);
		    }
		    return newObj;
		}
		var _default = {
		    /**
		   * The order that this resolver will run, in relation to other resolvers.
		   *
		   * @type {number}
		   */ order: 100,
		    /**
		   * Determines whether this resolver can read a given file reference.
		   * Resolvers that return true will be tried, in order, until one successfully resolves the file.
		   * Resolvers that return false will not be given a chance to resolve the file.
		   *
		   * @param {object} file           - An object containing information about the referenced file
		   * @param {string} file.url       - The full URL of the referenced file
		   * @param {string} file.extension - The lowercased file extension (e.g. ".txt", ".html", etc.)
		   * @returns {boolean}
		   */ canRead: function canRead(file) {
		        return _urlJs.isFileSystemPath(file.url);
		    },
		    /**
		   * Reads the given file and returns its raw contents as a Buffer.
		   *
		   * @param {object} file           - An object containing information about the referenced file
		   * @param {string} file.url       - The full URL of the referenced file
		   * @param {string} file.extension - The lowercased file extension (e.g. ".txt", ".html", etc.)
		   * @returns {Promise<Buffer>}
		   */ read: function read(file) {
		        return new Promise(function(resolve, reject) {
		            var path;
		            try {
		                path = _urlJs.toFileSystemPath(file.url);
		            } catch (err) {
		                reject(new _errorsJs.ResolverError(_ono.ono.uri(err, "Malformed URI: ".concat(file.url)), file.url));
		            }
		            // console.log('Opening file: %s', path);
		            try {
		                _fs.default.readFile(path, function(err, data) {
		                    if (err) {
		                        reject(new _errorsJs.ResolverError((0, _ono.ono)(err, 'Error opening file "'.concat(path, '"')), path));
		                    } else {
		                        resolve(data);
		                    }
		                });
		            } catch (err1) {
		                reject(new _errorsJs.ResolverError((0, _ono.ono)(err1, 'Error opening file "'.concat(path, '"')), path));
		            }
		        });
		    }
		}; 
	} (file));

	var http = {};

	(function (exports) {
		Object.defineProperty(exports, "__esModule", {
		    value: true
		});
		Object.defineProperty(exports, "default", {
		    enumerable: true,
		    get: function() {
		        return _default;
		    }
		});
		var _ono = require$$9;
		var _urlJs = /*#__PURE__*/ _interopRequireWildcard(url);
		var _errorsJs = errors;
		function _getRequireWildcardCache(nodeInterop) {
		    if (typeof WeakMap !== "function") return null;
		    var cacheBabelInterop = new WeakMap();
		    var cacheNodeInterop = new WeakMap();
		    return (_getRequireWildcardCache = function(nodeInterop) {
		        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
		    })(nodeInterop);
		}
		function _interopRequireWildcard(obj, nodeInterop) {
		    if (obj && obj.__esModule) {
		        return obj;
		    }
		    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
		        return {
		            default: obj
		        };
		    }
		    var cache = _getRequireWildcardCache(nodeInterop);
		    if (cache && cache.has(obj)) {
		        return cache.get(obj);
		    }
		    var newObj = {};
		    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
		    for(var key in obj){
		        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
		            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
		            if (desc && (desc.get || desc.set)) {
		                Object.defineProperty(newObj, key, desc);
		            } else {
		                newObj[key] = obj[key];
		            }
		        }
		    }
		    newObj.default = obj;
		    if (cache) {
		        cache.set(obj, newObj);
		    }
		    return newObj;
		}
		var _default = {
		    /**
		   * The order that this resolver will run, in relation to other resolvers.
		   *
		   * @type {number}
		   */ order: 200,
		    /**
		   * HTTP headers to send when downloading files.
		   *
		   * @example:
		   * {
		   *   "User-Agent": "JSON Schema $Ref Parser",
		   *   Accept: "application/json"
		   * }
		   *
		   * @type {object}
		   */ headers: null,
		    /**
		   * HTTP request timeout (in milliseconds).
		   *
		   * @type {number}
		   */ timeout: 5000,
		    /**
		   * The maximum number of HTTP redirects to follow.
		   * To disable automatic following of redirects, set this to zero.
		   *
		   * @type {number}
		   */ redirects: 5,
		    /**
		   * The `withCredentials` option of XMLHttpRequest.
		   * Set this to `true` if you're downloading files from a CORS-enabled server that requires authentication
		   *
		   * @type {boolean}
		   */ withCredentials: false,
		    /**
		   * Determines whether this resolver can read a given file reference.
		   * Resolvers that return true will be tried in order, until one successfully resolves the file.
		   * Resolvers that return false will not be given a chance to resolve the file.
		   *
		   * @param {object} file           - An object containing information about the referenced file
		   * @param {string} file.url       - The full URL of the referenced file
		   * @param {string} file.extension - The lowercased file extension (e.g. ".txt", ".html", etc.)
		   * @returns {boolean}
		   */ canRead: function canRead(file) {
		        return _urlJs.isHttp(file.url);
		    },
		    /**
		   * Reads the given URL and returns its raw contents as a Buffer.
		   *
		   * @param {object} file           - An object containing information about the referenced file
		   * @param {string} file.url       - The full URL of the referenced file
		   * @param {string} file.extension - The lowercased file extension (e.g. ".txt", ".html", etc.)
		   * @returns {Promise<Buffer>}
		   */ read: function read(file) {
		        var u = _urlJs.parse(file.url);
		        if (typeof window !== "undefined" && !u.protocol) {
		            // Use the protocol of the current page
		            u.protocol = _urlJs.parse(location.href).protocol;
		        }
		        return download(u, this);
		    }
		};
		/**
		 * Downloads the given file.
		 *
		 * @param {Url|string} u        - The url to download (can be a parsed {@link Url} object)
		 * @param {object} httpOptions  - The `options.resolve.http` object
		 * @param {number} [redirects]  - The redirect URLs that have already been followed
		 *
		 * @returns {Promise<Buffer>}
		 * The promise resolves with the raw downloaded data, or rejects if there is an HTTP error.
		 */ function download(u, httpOptions, redirects) {
		    u = _urlJs.parse(u);
		    redirects = redirects || [];
		    redirects.push(u.href);
		    return get(u, httpOptions).then(function(res) {
		        if (res.status >= 400) {
		            throw (0, _ono.ono)({
		                status: res.statusCode
		            }, "HTTP ERROR ".concat(res.status));
		        } else if (res.status >= 300) {
		            if (redirects.length > httpOptions.redirects) {
		                throw new _errorsJs.ResolverError((0, _ono.ono)({
		                    status: res.status
		                }, "Error downloading ".concat(redirects[0], ". \nToo many redirects: \n  ").concat(redirects.join(" \n  "))));
		            } else if (!res.headers.location) {
		                throw (0, _ono.ono)({
		                    status: res.status
		                }, "HTTP ".concat(res.status, " redirect with no location header"));
		            } else {
		                // console.log('HTTP %d redirect %s -> %s', res.status, u.href, res.headers.location);
		                var redirectTo = _urlJs.resolve(u, res.headers.location);
		                return download(redirectTo, httpOptions, redirects);
		            }
		        } else {
		            return res.body ? res.arrayBuffer().then(function(buf) {
		                return Buffer.from(buf);
		            }) : Buffer.alloc(0);
		        }
		    }).catch(function(err) {
		        throw new _errorsJs.ResolverError((0, _ono.ono)(err, "Error downloading ".concat(u.href)), u.href);
		    });
		}
		/**
		 * Sends an HTTP GET request.
		 *
		 * @param {Url} u - A parsed {@link Url} object
		 * @param {object} httpOptions - The `options.resolve.http` object
		 *
		 * @returns {Promise<Response>}
		 * The promise resolves with the HTTP Response object.
		 */ function get(u, httpOptions) {
		    var controller;
		    var timeoutId;
		    if (httpOptions.timeout) {
		        controller = new AbortController();
		        timeoutId = setTimeout(function() {
		            return controller.abort();
		        }, httpOptions.timeout);
		    }
		    return fetch(u, {
		        method: "GET",
		        headers: httpOptions.headers || {},
		        credentials: httpOptions.withCredentials ? "include" : "same-origin",
		        signal: controller ? controller.signal : null
		    }).then(function(response) {
		        if (timeoutId) {
		            clearTimeout(timeoutId);
		        }
		        return response;
		    });
		} 
	} (http));

	/* eslint lines-around-comment: [2, {beforeBlockComment: false}] */

	(function (exports) {
		Object.defineProperty(exports, "__esModule", {
		    value: true
		});
		Object.defineProperty(exports, "default", {
		    enumerable: true,
		    get: function() {
		        return _default;
		    }
		});
		var _jsonJs = /*#__PURE__*/ _interopRequireDefault(json$1);
		var _yamlJs = /*#__PURE__*/ _interopRequireDefault(yaml);
		var _textJs = /*#__PURE__*/ _interopRequireDefault(text);
		var _binaryJs = /*#__PURE__*/ _interopRequireDefault(binary);
		var _fileJs = /*#__PURE__*/ _interopRequireDefault(file);
		var _httpJs = /*#__PURE__*/ _interopRequireDefault(http);
		function _instanceof(left, right) {
		    if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) {
		        return !!right[Symbol.hasInstance](left);
		    } else {
		        return left instanceof right;
		    }
		}
		function _interopRequireDefault(obj) {
		    return obj && obj.__esModule ? obj : {
		        default: obj
		    };
		}
		var _default = $RefParserOptions;
		/**
		 * Options that determine how JSON schemas are parsed, resolved, and dereferenced.
		 *
		 * @param {object|$RefParserOptions} [options] - Overridden options
		 * @constructor
		 */ function $RefParserOptions(options) {
		    merge(this, $RefParserOptions.defaults);
		    merge(this, options);
		}
		$RefParserOptions.defaults = {
		    /**
		   * Determines how different types of files will be parsed.
		   *
		   * You can add additional parsers of your own, replace an existing one with
		   * your own implementation, or disable any parser by setting it to false.
		   */ parse: {
		        json: _jsonJs.default,
		        yaml: _yamlJs.default,
		        text: _textJs.default,
		        binary: _binaryJs.default
		    },
		    /**
		   * Determines how JSON References will be resolved.
		   *
		   * You can add additional resolvers of your own, replace an existing one with
		   * your own implementation, or disable any resolver by setting it to false.
		   */ resolve: {
		        file: _fileJs.default,
		        http: _httpJs.default,
		        /**
		     * Determines whether external $ref pointers will be resolved.
		     * If this option is disabled, then none of above resolvers will be called.
		     * Instead, external $ref pointers will simply be ignored.
		     *
		     * @type {boolean}
		     */ external: true
		    },
		    /**
		   * By default, JSON Schema $Ref Parser throws the first error it encounters. Setting `continueOnError` to `true`
		   * causes it to keep processing as much as possible and then throw a single error that contains all errors
		   * that were encountered.
		  */ continueOnError: false,
		    /**
		   * Determines the types of JSON references that are allowed.
		   */ dereference: {
		        /**
		     * Dereference circular (recursive) JSON references?
		     * If false, then a {@link ReferenceError} will be thrown if a circular reference is found.
		     * If "ignore", then circular references will not be dereferenced.
		     *
		     * @type {boolean|string}
		     */ circular: true,
		        /**
		     * A function, called for each path, which can return true to stop this path and all
		     * subpaths from being dereferenced further. This is useful in schemas where some
		     * subpaths contain literal $ref keys that should not be dereferenced.
		     *
		     * @type {function}
		     */ excludedPathMatcher: function() {
		            return false;
		        }
		    }
		};
		/**
		 * Merges the properties of the source object into the target object.
		 *
		 * @param {object} target - The object that we're populating
		 * @param {?object} source - The options that are being merged
		 * @returns {object}
		 */ function merge(target, source) {
		    if (isMergeable(source)) {
		        var keys = Object.keys(source);
		        for(var i = 0; i < keys.length; i++){
		            var key = keys[i];
		            var sourceSetting = source[key];
		            var targetSetting = target[key];
		            if (isMergeable(sourceSetting)) {
		                // It's a nested object, so merge it recursively
		                target[key] = merge(targetSetting || {}, sourceSetting);
		            } else if (sourceSetting !== undefined) {
		                // It's a scalar value, function, or array. No merging necessary. Just overwrite the target value.
		                target[key] = sourceSetting;
		            }
		        }
		    }
		    return target;
		}
		/**
		 * Determines whether the given value can be merged,
		 * or if it is a scalar value that should just override the target value.
		 *
		 * @param   {*}  val
		 * @returns {Boolean}
		 */ function isMergeable(val) {
		    return val && typeof val === "object" && !Array.isArray(val) && !_instanceof(val, RegExp) && !_instanceof(val, Date);
		} 
	} (options$1));

	(function (exports) {
		Object.defineProperty(exports, "__esModule", {
		    value: true
		});
		Object.defineProperty(exports, "default", {
		    enumerable: true,
		    get: function() {
		        return _default;
		    }
		});
		var _optionsJs = /*#__PURE__*/ _interopRequireDefault(options$1);
		function _instanceof(left, right) {
		    if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) {
		        return !!right[Symbol.hasInstance](left);
		    } else {
		        return left instanceof right;
		    }
		}
		function _interopRequireDefault(obj) {
		    return obj && obj.__esModule ? obj : {
		        default: obj
		    };
		}
		var _default = normalizeArgs;
		/**
		 * Normalizes the given arguments, accounting for optional args.
		 *
		 * @param {Arguments} args
		 * @returns {object}
		 */ function normalizeArgs(args) {
		    var path, schema, options, callback;
		    args = Array.prototype.slice.call(args);
		    if (typeof args[args.length - 1] === "function") {
		        // The last parameter is a callback function
		        callback = args.pop();
		    }
		    if (typeof args[0] === "string") {
		        // The first parameter is the path
		        path = args[0];
		        if (typeof args[2] === "object") {
		            // The second parameter is the schema, and the third parameter is the options
		            schema = args[1];
		            options = args[2];
		        } else {
		            // The second parameter is the options
		            schema = undefined;
		            options = args[1];
		        }
		    } else {
		        // The first parameter is the schema
		        path = "";
		        schema = args[0];
		        options = args[1];
		    }
		    if (!_instanceof(options, _optionsJs.default)) {
		        options = new _optionsJs.default(options);
		    }
		    return {
		        path: path,
		        schema: schema,
		        options: options,
		        callback: callback
		    };
		} 
	} (normalizeArgs));

	var resolveExternal = {};

	(function (exports) {
		Object.defineProperty(exports, "__esModule", {
		    value: true
		});
		Object.defineProperty(exports, "default", {
		    enumerable: true,
		    get: function() {
		        return _default;
		    }
		});
		var _refJs = /*#__PURE__*/ _interopRequireDefault(requireRef());
		var _pointerJs = /*#__PURE__*/ _interopRequireDefault(requirePointer());
		var _parseJs = /*#__PURE__*/ _interopRequireDefault(parse);
		var _urlJs = /*#__PURE__*/ _interopRequireWildcard(url);
		var _errorsJs = errors;
		function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
		    try {
		        var info = gen[key](arg);
		        var value = info.value;
		    } catch (error) {
		        reject(error);
		        return;
		    }
		    if (info.done) {
		        resolve(value);
		    } else {
		        Promise.resolve(value).then(_next, _throw);
		    }
		}
		function _asyncToGenerator(fn) {
		    return function() {
		        var self = this, args = arguments;
		        return new Promise(function(resolve, reject) {
		            var gen = fn.apply(self, args);
		            function _next(value) {
		                asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
		            }
		            function _throw(err) {
		                asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
		            }
		            _next(undefined);
		        });
		    };
		}
		function _interopRequireDefault(obj) {
		    return obj && obj.__esModule ? obj : {
		        default: obj
		    };
		}
		function _getRequireWildcardCache(nodeInterop) {
		    if (typeof WeakMap !== "function") return null;
		    var cacheBabelInterop = new WeakMap();
		    var cacheNodeInterop = new WeakMap();
		    return (_getRequireWildcardCache = function(nodeInterop) {
		        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
		    })(nodeInterop);
		}
		function _interopRequireWildcard(obj, nodeInterop) {
		    if (obj && obj.__esModule) {
		        return obj;
		    }
		    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
		        return {
		            default: obj
		        };
		    }
		    var cache = _getRequireWildcardCache(nodeInterop);
		    if (cache && cache.has(obj)) {
		        return cache.get(obj);
		    }
		    var newObj = {};
		    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
		    for(var key in obj){
		        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
		            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
		            if (desc && (desc.get || desc.set)) {
		                Object.defineProperty(newObj, key, desc);
		            } else {
		                newObj[key] = obj[key];
		            }
		        }
		    }
		    newObj.default = obj;
		    if (cache) {
		        cache.set(obj, newObj);
		    }
		    return newObj;
		}
		var __generator = function(thisArg, body) {
		    var f, y, t, g, _ = {
		        label: 0,
		        sent: function() {
		            if (t[0] & 1) throw t[1];
		            return t[1];
		        },
		        trys: [],
		        ops: []
		    };
		    return g = {
		        next: verb(0),
		        "throw": verb(1),
		        "return": verb(2)
		    }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
		        return this;
		    }), g;
		    function verb(n) {
		        return function(v) {
		            return step([
		                n,
		                v
		            ]);
		        };
		    }
		    function step(op) {
		        if (f) throw new TypeError("Generator is already executing.");
		        while(_)try {
		            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
		            if (y = 0, t) op = [
		                op[0] & 2,
		                t.value
		            ];
		            switch(op[0]){
		                case 0:
		                case 1:
		                    t = op;
		                    break;
		                case 4:
		                    _.label++;
		                    return {
		                        value: op[1],
		                        done: false
		                    };
		                case 5:
		                    _.label++;
		                    y = op[1];
		                    op = [
		                        0
		                    ];
		                    continue;
		                case 7:
		                    op = _.ops.pop();
		                    _.trys.pop();
		                    continue;
		                default:
		                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
		                        _ = 0;
		                        continue;
		                    }
		                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
		                        _.label = op[1];
		                        break;
		                    }
		                    if (op[0] === 6 && _.label < t[1]) {
		                        _.label = t[1];
		                        t = op;
		                        break;
		                    }
		                    if (t && _.label < t[2]) {
		                        _.label = t[2];
		                        _.ops.push(op);
		                        break;
		                    }
		                    if (t[2]) _.ops.pop();
		                    _.trys.pop();
		                    continue;
		            }
		            op = body.call(thisArg, _);
		        } catch (e) {
		            op = [
		                6,
		                e
		            ];
		            y = 0;
		        } finally{
		            f = t = 0;
		        }
		        if (op[0] & 5) throw op[1];
		        return {
		            value: op[0] ? op[1] : void 0,
		            done: true
		        };
		    }
		};
		var _default = resolveExternal;
		/**
		 * Crawls the JSON schema, finds all external JSON references, and resolves their values.
		 * This method does not mutate the JSON schema. The resolved values are added to {@link $RefParser#$refs}.
		 *
		 * NOTE: We only care about EXTERNAL references here. INTERNAL references are only relevant when dereferencing.
		 *
		 * @param {$RefParser} parser
		 * @param {$RefParserOptions} options
		 *
		 * @returns {Promise}
		 * The promise resolves once all JSON references in the schema have been resolved,
		 * including nested references that are contained in externally-referenced files.
		 */ function resolveExternal(parser, options) {
		    if (!options.resolve.external) {
		        // Nothing to resolve, so exit early
		        return Promise.resolve();
		    }
		    try {
		        // console.log('Resolving $ref pointers in %s', parser.$refs._root$Ref.path);
		        var promises = crawl(parser.schema, parser.$refs._root$Ref.path + "#", parser.$refs, options);
		        return Promise.all(promises);
		    } catch (e) {
		        return Promise.reject(e);
		    }
		}
		/**
		 * Recursively crawls the given value, and resolves any external JSON references.
		 *
		 * @param {*} obj - The value to crawl. If it's not an object or array, it will be ignored.
		 * @param {string} path - The full path of `obj`, possibly with a JSON Pointer in the hash
		 * @param {$Refs} $refs
		 * @param {$RefParserOptions} options
		 * @param {Set} seen - Internal.
		 *
		 * @returns {Promise[]}
		 * Returns an array of promises. There will be one promise for each JSON reference in `obj`.
		 * If `obj` does not contain any JSON references, then the array will be empty.
		 * If any of the JSON references point to files that contain additional JSON references,
		 * then the corresponding promise will internally reference an array of promises.
		 */ function crawl(obj, path, $refs, options, seen) {
		    seen = seen || new Set();
		    var promises = [];
		    if (obj && typeof obj === "object" && !ArrayBuffer.isView(obj) && !seen.has(obj)) {
		        seen.add(obj); // Track previously seen objects to avoid infinite recursion
		        if (_refJs.default.isExternal$Ref(obj)) {
		            promises.push(resolve$Ref(obj, path, $refs, options));
		        } else {
		            var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
		            try {
		                for(var _iterator = Object.keys(obj)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
		                    var key = _step.value;
		                    var keyPath = _pointerJs.default.join(path, key);
		                    var value = obj[key];
		                    if (_refJs.default.isExternal$Ref(value)) {
		                        promises.push(resolve$Ref(value, keyPath, $refs, options));
		                    } else {
		                        promises = promises.concat(crawl(value, keyPath, $refs, options, seen));
		                    }
		                }
		            } catch (err) {
		                _didIteratorError = true;
		                _iteratorError = err;
		            } finally{
		                try {
		                    if (!_iteratorNormalCompletion && _iterator.return != null) {
		                        _iterator.return();
		                    }
		                } finally{
		                    if (_didIteratorError) {
		                        throw _iteratorError;
		                    }
		                }
		            }
		        }
		    }
		    return promises;
		}
		function resolve$Ref($ref, path, $refs, options) {
		    return _resolve$Ref.apply(this, arguments);
		}
		function _resolve$Ref() {
		    _resolve$Ref = /**
		 * Resolves the given JSON Reference, and then crawls the resulting value.
		 *
		 * @param {{$ref: string}} $ref - The JSON Reference to resolve
		 * @param {string} path - The full path of `$ref`, possibly with a JSON Pointer in the hash
		 * @param {$Refs} $refs
		 * @param {$RefParserOptions} options
		 *
		 * @returns {Promise}
		 * The promise resolves once all JSON references in the object have been resolved,
		 * including nested references that are contained in externally-referenced files.
		 */ _asyncToGenerator(function($ref, path, $refs, options) {
		        var resolvedPath, withoutHash, result, promises, err;
		        return __generator(this, function(_state) {
		            switch(_state.label){
		                case 0:
		                    resolvedPath = _urlJs.resolve(path, $ref.$ref);
		                    withoutHash = _urlJs.stripHash(resolvedPath);
		                    // Do we already have this $ref?
		                    $ref = $refs._$refs[withoutHash];
		                    if ($ref) {
		                        // We've already parsed this $ref, so use the existing value
		                        return [
		                            2,
		                            Promise.resolve($ref.value)
		                        ];
		                    }
		                    _state.label = 1;
		                case 1:
		                    _state.trys.push([
		                        1,
		                        3,
		                        ,
		                        4
		                    ]);
		                    return [
		                        4,
		                        (0, _parseJs.default)(resolvedPath, $refs, options)
		                    ];
		                case 2:
		                    result = _state.sent();
		                    promises = crawl(result, withoutHash + "#", $refs, options);
		                    return [
		                        2,
		                        Promise.all(promises)
		                    ];
		                case 3:
		                    err = _state.sent();
		                    if (!options.continueOnError || !(0, _errorsJs.isHandledError)(err)) {
		                        throw err;
		                    }
		                    if ($refs._$refs[withoutHash]) {
		                        err.source = decodeURI(_urlJs.stripHash(path));
		                        err.path = _urlJs.safePointerToPath(_urlJs.getHash(path));
		                    }
		                    return [
		                        2,
		                        []
		                    ];
		                case 4:
		                    return [
		                        2
		                    ];
		            }
		        });
		    });
		    return _resolve$Ref.apply(this, arguments);
		} 
	} (resolveExternal));

	var bundle = {};

	(function (exports) {
		Object.defineProperty(exports, "__esModule", {
		    value: true
		});
		Object.defineProperty(exports, "default", {
		    enumerable: true,
		    get: function() {
		        return _default;
		    }
		});
		var _refJs = /*#__PURE__*/ _interopRequireDefault(requireRef());
		var _pointerJs = /*#__PURE__*/ _interopRequireDefault(requirePointer());
		var _urlJs = /*#__PURE__*/ _interopRequireWildcard(url);
		function _interopRequireDefault(obj) {
		    return obj && obj.__esModule ? obj : {
		        default: obj
		    };
		}
		function _getRequireWildcardCache(nodeInterop) {
		    if (typeof WeakMap !== "function") return null;
		    var cacheBabelInterop = new WeakMap();
		    var cacheNodeInterop = new WeakMap();
		    return (_getRequireWildcardCache = function(nodeInterop) {
		        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
		    })(nodeInterop);
		}
		function _interopRequireWildcard(obj, nodeInterop) {
		    if (obj && obj.__esModule) {
		        return obj;
		    }
		    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
		        return {
		            default: obj
		        };
		    }
		    var cache = _getRequireWildcardCache(nodeInterop);
		    if (cache && cache.has(obj)) {
		        return cache.get(obj);
		    }
		    var newObj = {};
		    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
		    for(var key in obj){
		        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
		            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
		            if (desc && (desc.get || desc.set)) {
		                Object.defineProperty(newObj, key, desc);
		            } else {
		                newObj[key] = obj[key];
		            }
		        }
		    }
		    newObj.default = obj;
		    if (cache) {
		        cache.set(obj, newObj);
		    }
		    return newObj;
		}
		var _default = bundle;
		/**
		 * Bundles all external JSON references into the main JSON schema, thus resulting in a schema that
		 * only has *internal* references, not any *external* references.
		 * This method mutates the JSON schema object, adding new references and re-mapping existing ones.
		 *
		 * @param {$RefParser} parser
		 * @param {$RefParserOptions} options
		 */ function bundle(parser, options) {
		    // console.log('Bundling $ref pointers in %s', parser.$refs._root$Ref.path);
		    // Build an inventory of all $ref pointers in the JSON Schema
		    var inventory = [];
		    crawl(parser, "schema", parser.$refs._root$Ref.path + "#", "#", 0, inventory, parser.$refs, options);
		    // Remap all $ref pointers
		    remap(inventory);
		}
		/**
		 * Recursively crawls the given value, and inventories all JSON references.
		 *
		 * @param {object} parent - The object containing the value to crawl. If the value is not an object or array, it will be ignored.
		 * @param {string} key - The property key of `parent` to be crawled
		 * @param {string} path - The full path of the property being crawled, possibly with a JSON Pointer in the hash
		 * @param {string} pathFromRoot - The path of the property being crawled, from the schema root
		 * @param {object[]} inventory - An array of already-inventoried $ref pointers
		 * @param {$Refs} $refs
		 * @param {$RefParserOptions} options
		 */ function crawl(parent, key, path, pathFromRoot, indirections, inventory, $refs, options) {
		    var obj = key === null ? parent : parent[key];
		    if (obj && typeof obj === "object" && !ArrayBuffer.isView(obj)) {
		        if (_refJs.default.isAllowed$Ref(obj)) {
		            inventory$Ref(parent, key, path, pathFromRoot, indirections, inventory, $refs, options);
		        } else {
		            // Crawl the object in a specific order that's optimized for bundling.
		            // This is important because it determines how `pathFromRoot` gets built,
		            // which later determines which keys get dereferenced and which ones get remapped
		            var keys = Object.keys(obj).sort(function(a, b) {
		                // Most people will expect references to be bundled into the the "definitions" property,
		                // so we always crawl that property first, if it exists.
		                if (a === "definitions") {
		                    return -1;
		                } else if (b === "definitions") {
		                    return 1;
		                } else {
		                    // Otherwise, crawl the keys based on their length.
		                    // This produces the shortest possible bundled references
		                    return a.length - b.length;
		                }
		            });
		            var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
		            try {
		                // eslint-disable-next-line no-shadow
		                for(var _iterator = keys[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
		                    var _$key = _step.value;
		                    var keyPath = _pointerJs.default.join(path, _$key);
		                    var keyPathFromRoot = _pointerJs.default.join(pathFromRoot, _$key);
		                    var value = obj[_$key];
		                    if (_refJs.default.isAllowed$Ref(value)) {
		                        inventory$Ref(obj, _$key, path, keyPathFromRoot, indirections, inventory, $refs, options);
		                    } else {
		                        crawl(obj, _$key, keyPath, keyPathFromRoot, indirections, inventory, $refs, options);
		                    }
		                }
		            } catch (err) {
		                _didIteratorError = true;
		                _iteratorError = err;
		            } finally{
		                try {
		                    if (!_iteratorNormalCompletion && _iterator.return != null) {
		                        _iterator.return();
		                    }
		                } finally{
		                    if (_didIteratorError) {
		                        throw _iteratorError;
		                    }
		                }
		            }
		        }
		    }
		}
		/**
		 * Inventories the given JSON Reference (i.e. records detailed information about it so we can
		 * optimize all $refs in the schema), and then crawls the resolved value.
		 *
		 * @param {object} $refParent - The object that contains a JSON Reference as one of its keys
		 * @param {string} $refKey - The key in `$refParent` that is a JSON Reference
		 * @param {string} path - The full path of the JSON Reference at `$refKey`, possibly with a JSON Pointer in the hash
		 * @param {string} pathFromRoot - The path of the JSON Reference at `$refKey`, from the schema root
		 * @param {object[]} inventory - An array of already-inventoried $ref pointers
		 * @param {$Refs} $refs
		 * @param {$RefParserOptions} options
		 */ function inventory$Ref($refParent, $refKey, path, pathFromRoot, indirections, inventory, $refs, options) {
		    var $ref = $refKey === null ? $refParent : $refParent[$refKey];
		    var $refPath = _urlJs.resolve(path, $ref.$ref);
		    var pointer = $refs._resolve($refPath, pathFromRoot, options);
		    if (pointer === null) {
		        return;
		    }
		    var depth = _pointerJs.default.parse(pathFromRoot).length;
		    var file = _urlJs.stripHash(pointer.path);
		    var hash = _urlJs.getHash(pointer.path);
		    var external = file !== $refs._root$Ref.path;
		    var extended = _refJs.default.isExtended$Ref($ref);
		    indirections += pointer.indirections;
		    var existingEntry = findInInventory(inventory, $refParent, $refKey);
		    if (existingEntry) {
		        // This $Ref has already been inventoried, so we don't need to process it again
		        if (depth < existingEntry.depth || indirections < existingEntry.indirections) {
		            removeFromInventory(inventory, existingEntry);
		        } else {
		            return;
		        }
		    }
		    inventory.push({
		        $ref: $ref,
		        parent: $refParent,
		        key: $refKey,
		        pathFromRoot: pathFromRoot,
		        depth: depth,
		        file: file,
		        hash: hash,
		        value: pointer.value,
		        circular: pointer.circular,
		        extended: extended,
		        external: external,
		        indirections: indirections
		    });
		    // Recursively crawl the resolved value
		    if (!existingEntry || external) {
		        crawl(pointer.value, null, pointer.path, pathFromRoot, indirections + 1, inventory, $refs, options);
		    }
		}
		/**
		 * Re-maps every $ref pointer, so that they're all relative to the root of the JSON Schema.
		 * Each referenced value is dereferenced EXACTLY ONCE.  All subsequent references to the same
		 * value are re-mapped to point to the first reference.
		 *
		 * @example:
		 *  {
		 *    first: { $ref: somefile.json#/some/part },
		 *    second: { $ref: somefile.json#/another/part },
		 *    third: { $ref: somefile.json },
		 *    fourth: { $ref: somefile.json#/some/part/sub/part }
		 *  }
		 *
		 * In this example, there are four references to the same file, but since the third reference points
		 * to the ENTIRE file, that's the only one we need to dereference.  The other three can just be
		 * remapped to point inside the third one.
		 *
		 * On the other hand, if the third reference DIDN'T exist, then the first and second would both need
		 * to be dereferenced, since they point to different parts of the file. The fourth reference does NOT
		 * need to be dereferenced, because it can be remapped to point inside the first one.
		 *
		 * @param {object[]} inventory
		 */ function remap(inventory) {
		    // Group & sort all the $ref pointers, so they're in the order that we need to dereference/remap them
		    inventory.sort(function(a, b) {
		        if (a.file !== b.file) {
		            // Group all the $refs that point to the same file
		            return a.file < b.file ? -1 : +1;
		        } else if (a.hash !== b.hash) {
		            // Group all the $refs that point to the same part of the file
		            return a.hash < b.hash ? -1 : +1;
		        } else if (a.circular !== b.circular) {
		            // If the $ref points to itself, then sort it higher than other $refs that point to this $ref
		            return a.circular ? -1 : +1;
		        } else if (a.extended !== b.extended) {
		            // If the $ref extends the resolved value, then sort it lower than other $refs that don't extend the value
		            return a.extended ? +1 : -1;
		        } else if (a.indirections !== b.indirections) {
		            // Sort direct references higher than indirect references
		            return a.indirections - b.indirections;
		        } else if (a.depth !== b.depth) {
		            // Sort $refs by how close they are to the JSON Schema root
		            return a.depth - b.depth;
		        } else {
		            // Determine how far each $ref is from the "definitions" property.
		            // Most people will expect references to be bundled into the the "definitions" property if possible.
		            var aDefinitionsIndex = a.pathFromRoot.lastIndexOf("/definitions");
		            var bDefinitionsIndex = b.pathFromRoot.lastIndexOf("/definitions");
		            if (aDefinitionsIndex !== bDefinitionsIndex) {
		                // Give higher priority to the $ref that's closer to the "definitions" property
		                return bDefinitionsIndex - aDefinitionsIndex;
		            } else {
		                // All else is equal, so use the shorter path, which will produce the shortest possible reference
		                return a.pathFromRoot.length - b.pathFromRoot.length;
		            }
		        }
		    });
		    var file, hash, pathFromRoot;
		    var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
		    try {
		        for(var _iterator = inventory[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
		            var entry = _step.value;
		            // console.log('Re-mapping $ref pointer "%s" at %s', entry.$ref.$ref, entry.pathFromRoot);
		            if (!entry.external) {
		                // This $ref already resolves to the main JSON Schema file
		                entry.$ref.$ref = entry.hash;
		            } else if (entry.file === file && entry.hash === hash) {
		                // This $ref points to the same value as the prevous $ref, so remap it to the same path
		                entry.$ref.$ref = pathFromRoot;
		            } else if (entry.file === file && entry.hash.indexOf(hash + "/") === 0) {
		                // This $ref points to a sub-value of the prevous $ref, so remap it beneath that path
		                entry.$ref.$ref = _pointerJs.default.join(pathFromRoot, _pointerJs.default.parse(entry.hash.replace(hash, "#")));
		            } else {
		                // We've moved to a new file or new hash
		                file = entry.file;
		                hash = entry.hash;
		                pathFromRoot = entry.pathFromRoot;
		                // This is the first $ref to point to this value, so dereference the value.
		                // Any other $refs that point to the same value will point to this $ref instead
		                entry.$ref = entry.parent[entry.key] = _refJs.default.dereference(entry.$ref, entry.value);
		                if (entry.circular) {
		                    // This $ref points to itself
		                    entry.$ref.$ref = entry.pathFromRoot;
		                }
		            }
		        // console.log('    new value: %s', (entry.$ref && entry.$ref.$ref) ? entry.$ref.$ref : '[object Object]');
		        }
		    } catch (err) {
		        _didIteratorError = true;
		        _iteratorError = err;
		    } finally{
		        try {
		            if (!_iteratorNormalCompletion && _iterator.return != null) {
		                _iterator.return();
		            }
		        } finally{
		            if (_didIteratorError) {
		                throw _iteratorError;
		            }
		        }
		    }
		}
		/**
		 * TODO
		 */ function findInInventory(inventory, $refParent, $refKey) {
		    for(var i = 0; i < inventory.length; i++){
		        var existingEntry = inventory[i];
		        if (existingEntry.parent === $refParent && existingEntry.key === $refKey) {
		            return existingEntry;
		        }
		    }
		}
		function removeFromInventory(inventory, entry) {
		    var index = inventory.indexOf(entry);
		    inventory.splice(index, 1);
		} 
	} (bundle));

	var dereference$1 = {};

	(function (exports) {
		Object.defineProperty(exports, "__esModule", {
		    value: true
		});
		Object.defineProperty(exports, "default", {
		    enumerable: true,
		    get: function() {
		        return _default;
		    }
		});
		var _refJs = /*#__PURE__*/ _interopRequireDefault(requireRef());
		var _pointerJs = /*#__PURE__*/ _interopRequireDefault(requirePointer());
		var _ono = require$$9;
		var _urlJs = /*#__PURE__*/ _interopRequireWildcard(url);
		function _interopRequireDefault(obj) {
		    return obj && obj.__esModule ? obj : {
		        default: obj
		    };
		}
		function _getRequireWildcardCache(nodeInterop) {
		    if (typeof WeakMap !== "function") return null;
		    var cacheBabelInterop = new WeakMap();
		    var cacheNodeInterop = new WeakMap();
		    return (_getRequireWildcardCache = function(nodeInterop) {
		        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
		    })(nodeInterop);
		}
		function _interopRequireWildcard(obj, nodeInterop) {
		    if (obj && obj.__esModule) {
		        return obj;
		    }
		    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
		        return {
		            default: obj
		        };
		    }
		    var cache = _getRequireWildcardCache(nodeInterop);
		    if (cache && cache.has(obj)) {
		        return cache.get(obj);
		    }
		    var newObj = {};
		    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
		    for(var key in obj){
		        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
		            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
		            if (desc && (desc.get || desc.set)) {
		                Object.defineProperty(newObj, key, desc);
		            } else {
		                newObj[key] = obj[key];
		            }
		        }
		    }
		    newObj.default = obj;
		    if (cache) {
		        cache.set(obj, newObj);
		    }
		    return newObj;
		}
		var _default = dereference;
		/**
		 * Crawls the JSON schema, finds all JSON references, and dereferences them.
		 * This method mutates the JSON schema object, replacing JSON references with their resolved value.
		 *
		 * @param {$RefParser} parser
		 * @param {$RefParserOptions} options
		 */ function dereference(parser, options) {
		    // console.log('Dereferencing $ref pointers in %s', parser.$refs._root$Ref.path);
		    var dereferenced = crawl(parser.schema, parser.$refs._root$Ref.path, "#", new Set(), new Set(), new Map(), parser.$refs, options);
		    parser.$refs.circular = dereferenced.circular;
		    parser.schema = dereferenced.value;
		}
		/**
		 * Recursively crawls the given value, and dereferences any JSON references.
		 *
		 * @param {*} obj - The value to crawl. If it's not an object or array, it will be ignored.
		 * @param {string} path - The full path of `obj`, possibly with a JSON Pointer in the hash
		 * @param {string} pathFromRoot - The path of `obj` from the schema root
		 * @param {Set<object>} parents - An array of the parent objects that have already been dereferenced
		 * @param {Set<object>} processedObjects - An array of all the objects that have already been processed
		 * @param {Map<string,object>} dereferencedCache - An map of all the dereferenced objects
		 * @param {$Refs} $refs
		 * @param {$RefParserOptions} options
		 * @returns {{value: object, circular: boolean}}
		 */ function crawl(obj, path, pathFromRoot, parents, processedObjects, dereferencedCache, $refs, options) {
		    var dereferenced;
		    var result = {
		        value: obj,
		        circular: false
		    };
		    var isExcludedPath = options.dereference.excludedPathMatcher;
		    if (options.dereference.circular === "ignore" || !processedObjects.has(obj)) {
		        if (obj && typeof obj === "object" && !ArrayBuffer.isView(obj) && !isExcludedPath(pathFromRoot)) {
		            parents.add(obj);
		            processedObjects.add(obj);
		            if (_refJs.default.isAllowed$Ref(obj, options)) {
		                dereferenced = dereference$Ref(obj, path, pathFromRoot, parents, processedObjects, dereferencedCache, $refs, options);
		                result.circular = dereferenced.circular;
		                result.value = dereferenced.value;
		            } else {
		                var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
		                try {
		                    for(var _iterator = Object.keys(obj)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
		                        var key = _step.value;
		                        var keyPath = _pointerJs.default.join(path, key);
		                        var keyPathFromRoot = _pointerJs.default.join(pathFromRoot, key);
		                        if (isExcludedPath(keyPathFromRoot)) {
		                            continue;
		                        }
		                        var value = obj[key];
		                        var circular = false;
		                        if (_refJs.default.isAllowed$Ref(value, options)) {
		                            dereferenced = dereference$Ref(value, keyPath, keyPathFromRoot, parents, processedObjects, dereferencedCache, $refs, options);
		                            circular = dereferenced.circular;
		                            // Avoid pointless mutations; breaks frozen objects to no profit
		                            if (obj[key] !== dereferenced.value) {
		                                obj[key] = dereferenced.value;
		                                if (options.dereference.onDereference) {
		                                    options.dereference.onDereference(value.$ref, obj[key]);
		                                }
		                            }
		                        } else {
		                            if (!parents.has(value)) {
		                                dereferenced = crawl(value, keyPath, keyPathFromRoot, parents, processedObjects, dereferencedCache, $refs, options);
		                                circular = dereferenced.circular;
		                                // Avoid pointless mutations; breaks frozen objects to no profit
		                                if (obj[key] !== dereferenced.value) {
		                                    obj[key] = dereferenced.value;
		                                }
		                            } else {
		                                circular = foundCircularReference(keyPath, $refs, options);
		                            }
		                        }
		                        // Set the "isCircular" flag if this or any other property is circular
		                        result.circular = result.circular || circular;
		                    }
		                } catch (err) {
		                    _didIteratorError = true;
		                    _iteratorError = err;
		                } finally{
		                    try {
		                        if (!_iteratorNormalCompletion && _iterator.return != null) {
		                            _iterator.return();
		                        }
		                    } finally{
		                        if (_didIteratorError) {
		                            throw _iteratorError;
		                        }
		                    }
		                }
		            }
		            parents.delete(obj);
		        }
		    }
		    return result;
		}
		/**
		 * Dereferences the given JSON Reference, and then crawls the resulting value.
		 *
		 * @param {{$ref: string}} $ref - The JSON Reference to resolve
		 * @param {string} path - The full path of `$ref`, possibly with a JSON Pointer in the hash
		 * @param {string} pathFromRoot - The path of `$ref` from the schema root
		 * @param {Set<object>} parents - An array of the parent objects that have already been dereferenced
		 * @param {Set<object>} processedObjects - An array of all the objects that have already been dereferenced
		 * @param {Map<string,object>} dereferencedCache - An map of all the dereferenced objects
		 * @param {$Refs} $refs
		 * @param {$RefParserOptions} options
		 * @returns {{value: object, circular: boolean}}
		 */ function dereference$Ref($ref, path, pathFromRoot, parents, processedObjects, dereferencedCache, $refs, options) {
		    // console.log('Dereferencing $ref pointer "%s" at %s', $ref.$ref, path);
		    var $refPath = _urlJs.resolve(path, $ref.$ref);
		    var cache = dereferencedCache.get($refPath);
		    if (cache) {
		        var refKeys = Object.keys($ref);
		        if (refKeys.length > 1) {
		            var extraKeys = {};
		            var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
		            try {
		                for(var _iterator = refKeys[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
		                    var key = _step.value;
		                    if (key !== "$ref" && !(key in cache.value)) {
		                        extraKeys[key] = $ref[key];
		                    }
		                }
		            } catch (err) {
		                _didIteratorError = true;
		                _iteratorError = err;
		            } finally{
		                try {
		                    if (!_iteratorNormalCompletion && _iterator.return != null) {
		                        _iterator.return();
		                    }
		                } finally{
		                    if (_didIteratorError) {
		                        throw _iteratorError;
		                    }
		                }
		            }
		            return {
		                circular: cache.circular,
		                value: Object.assign({}, cache.value, extraKeys)
		            };
		        }
		        return cache;
		    }
		    var pointer = $refs._resolve($refPath, path, options);
		    if (pointer === null) {
		        return {
		            circular: false,
		            value: null
		        };
		    }
		    // Check for circular references
		    var directCircular = pointer.circular;
		    var circular = directCircular || parents.has(pointer.value);
		    circular && foundCircularReference(path, $refs, options);
		    // Dereference the JSON reference
		    var dereferencedValue = _refJs.default.dereference($ref, pointer.value);
		    // Crawl the dereferenced value (unless it's circular)
		    if (!circular) {
		        // Determine if the dereferenced value is circular
		        var dereferenced = crawl(dereferencedValue, pointer.path, pathFromRoot, parents, processedObjects, dereferencedCache, $refs, options);
		        circular = dereferenced.circular;
		        dereferencedValue = dereferenced.value;
		    }
		    if (circular && !directCircular && options.dereference.circular === "ignore") {
		        // The user has chosen to "ignore" circular references, so don't change the value
		        dereferencedValue = $ref;
		    }
		    if (directCircular) {
		        // The pointer is a DIRECT circular reference (i.e. it references itself).
		        // So replace the $ref path with the absolute path from the JSON Schema root
		        dereferencedValue.$ref = pathFromRoot;
		    }
		    var dereferencedObject = {
		        circular: circular,
		        value: dereferencedValue
		    };
		    // only cache if no extra properties than $ref
		    if (Object.keys($ref).length === 1) {
		        dereferencedCache.set($refPath, dereferencedObject);
		    }
		    return dereferencedObject;
		}
		/**
		 * Called when a circular reference is found.
		 * It sets the {@link $Refs#circular} flag, and throws an error if options.dereference.circular is false.
		 *
		 * @param {string} keyPath - The JSON Reference path of the circular reference
		 * @param {$Refs} $refs
		 * @param {$RefParserOptions} options
		 * @returns {boolean} - always returns true, to indicate that a circular reference was found
		 */ function foundCircularReference(keyPath, $refs, options) {
		    $refs.circular = true;
		    if (!options.dereference.circular) {
		        throw _ono.ono.reference("Circular $ref pointer found at ".concat(keyPath));
		    }
		    return true;
		} 
	} (dereference$1));

	function makeNext () {
	  if (typeof browser$1 === 'object' && typeof browser$1.nextTick === 'function') {
	    return browser$1.nextTick
	  } else if (typeof setImmediate === 'function') {
	    return setImmediate
	  } else {
	    return function next (f) {
	      setTimeout(f, 0);
	    }
	  }
	}

	var next$1 = makeNext();

	var next = next$1;

	var maybe = function maybe (cb, promise) {
	  if (cb) {
	    promise
	      .then(function (result) {
	        next(function () { cb(null, result); });
	      }, function (err) {
	        next(function () { cb(err); });
	      });
	    return undefined
	  }
	  else {
	    return promise
	  }
	};

	(function (module, exports) {
		Object.defineProperty(exports, "__esModule", {
		    value: true
		});
		function _export(target, all) {
		    for(var name in all)Object.defineProperty(target, name, {
		        enumerable: true,
		        get: all[name]
		    });
		}
		_export(exports, {
		    default: function() {
		        return _default;
		    },
		    JSONParserError: function() {
		        return _errorsJs.JSONParserError;
		    },
		    InvalidPointerError: function() {
		        return _errorsJs.InvalidPointerError;
		    },
		    MissingPointerError: function() {
		        return _errorsJs.MissingPointerError;
		    },
		    ResolverError: function() {
		        return _errorsJs.ResolverError;
		    },
		    ParserError: function() {
		        return _errorsJs.ParserError;
		    },
		    UnmatchedParserError: function() {
		        return _errorsJs.UnmatchedParserError;
		    },
		    UnmatchedResolverError: function() {
		        return _errorsJs.UnmatchedResolverError;
		    },
		    parse: function() {
		        return parse$1;
		    },
		    resolve: function() {
		        return resolve;
		    },
		    bundle: function() {
		        return bundle$1;
		    },
		    dereference: function() {
		        return dereference;
		    }
		});
		var _refsJs = /*#__PURE__*/ _interopRequireDefault(refs);
		var _parseJs = /*#__PURE__*/ _interopRequireDefault(parse);
		var _normalizeArgsJs = /*#__PURE__*/ _interopRequireDefault(normalizeArgs);
		var _resolveExternalJs = /*#__PURE__*/ _interopRequireDefault(resolveExternal);
		var _bundleJs = /*#__PURE__*/ _interopRequireDefault(bundle);
		var _dereferenceJs = /*#__PURE__*/ _interopRequireDefault(dereference$1);
		var _urlJs = /*#__PURE__*/ _interopRequireWildcard(url);
		var _errorsJs = errors;
		var _callMeMaybe = /*#__PURE__*/ _interopRequireDefault(maybe);
		var _ono = require$$9;
		function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
		    try {
		        var info = gen[key](arg);
		        var value = info.value;
		    } catch (error) {
		        reject(error);
		        return;
		    }
		    if (info.done) {
		        resolve(value);
		    } else {
		        Promise.resolve(value).then(_next, _throw);
		    }
		}
		function _asyncToGenerator(fn) {
		    return function() {
		        var self = this, args = arguments;
		        return new Promise(function(resolve, reject) {
		            var gen = fn.apply(self, args);
		            function _next(value) {
		                asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
		            }
		            function _throw(err) {
		                asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
		            }
		            _next(undefined);
		        });
		    };
		}
		function _interopRequireDefault(obj) {
		    return obj && obj.__esModule ? obj : {
		        default: obj
		    };
		}
		function _getRequireWildcardCache(nodeInterop) {
		    if (typeof WeakMap !== "function") return null;
		    var cacheBabelInterop = new WeakMap();
		    var cacheNodeInterop = new WeakMap();
		    return (_getRequireWildcardCache = function(nodeInterop) {
		        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
		    })(nodeInterop);
		}
		function _interopRequireWildcard(obj, nodeInterop) {
		    if (obj && obj.__esModule) {
		        return obj;
		    }
		    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
		        return {
		            default: obj
		        };
		    }
		    var cache = _getRequireWildcardCache(nodeInterop);
		    if (cache && cache.has(obj)) {
		        return cache.get(obj);
		    }
		    var newObj = {};
		    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
		    for(var key in obj){
		        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
		            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
		            if (desc && (desc.get || desc.set)) {
		                Object.defineProperty(newObj, key, desc);
		            } else {
		                newObj[key] = obj[key];
		            }
		        }
		    }
		    newObj.default = obj;
		    if (cache) {
		        cache.set(obj, newObj);
		    }
		    return newObj;
		}
		var __generator = function(thisArg, body) {
		    var f, y, t, g, _ = {
		        label: 0,
		        sent: function() {
		            if (t[0] & 1) throw t[1];
		            return t[1];
		        },
		        trys: [],
		        ops: []
		    };
		    return(g = {
		        next: verb(0),
		        "throw": verb(1),
		        "return": verb(2)
		    }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
		        return this;
		    }), g);
		    function verb(n) {
		        return function(v) {
		            return step([
		                n,
		                v
		            ]);
		        };
		    }
		    function step(op) {
		        if (f) throw new TypeError("Generator is already executing.");
		        while(_)try {
		            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
		            if (y = 0, t) op = [
		                op[0] & 2,
		                t.value
		            ];
		            switch(op[0]){
		                case 0:
		                case 1:
		                    t = op;
		                    break;
		                case 4:
		                    _.label++;
		                    return {
		                        value: op[1],
		                        done: false
		                    };
		                case 5:
		                    _.label++;
		                    y = op[1];
		                    op = [
		                        0
		                    ];
		                    continue;
		                case 7:
		                    op = _.ops.pop();
		                    _.trys.pop();
		                    continue;
		                default:
		                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
		                        _ = 0;
		                        continue;
		                    }
		                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
		                        _.label = op[1];
		                        break;
		                    }
		                    if (op[0] === 6 && _.label < t[1]) {
		                        _.label = t[1];
		                        t = op;
		                        break;
		                    }
		                    if (t && _.label < t[2]) {
		                        _.label = t[2];
		                        _.ops.push(op);
		                        break;
		                    }
		                    if (t[2]) _.ops.pop();
		                    _.trys.pop();
		                    continue;
		            }
		            op = body.call(thisArg, _);
		        } catch (e) {
		            op = [
		                6,
		                e
		            ];
		            y = 0;
		        } finally{
		            f = t = 0;
		        }
		        if (op[0] & 5) throw op[1];
		        return {
		            value: op[0] ? op[1] : void 0,
		            done: true
		        };
		    }
		};
		var _default = $RefParser;
		/**
		 * This class parses a JSON schema, builds a map of its JSON references and their resolved values,
		 * and provides methods for traversing, manipulating, and dereferencing those references.
		 *
		 * @constructor
		 */ function $RefParser() {
		    /**
		   * The parsed (and possibly dereferenced) JSON schema object
		   *
		   * @type {object}
		   * @readonly
		   */ this.schema = null;
		    /**
		   * The resolved JSON references
		   *
		   * @type {$Refs}
		   * @readonly
		   */ this.$refs = new _refsJs.default();
		}
		/**
		 * Parses the given JSON schema.
		 * This method does not resolve any JSON references.
		 * It just reads a single file in JSON or YAML format, and parse it as a JavaScript object.
		 *
		 * @param {string} [path] - The file path or URL of the JSON schema
		 * @param {object} [schema] - A JSON schema object. This object will be used instead of reading from `path`.
		 * @param {$RefParserOptions} [options] - Options that determine how the schema is parsed
		 * @param {function} [callback] - An error-first callback. The second parameter is the parsed JSON schema object.
		 * @returns {Promise} - The returned promise resolves with the parsed JSON schema object.
		 */ $RefParser.parse = function parse(path, schema, options, callback) {
		    var Class = this; // eslint-disable-line consistent-this
		    var instance = new Class();
		    return instance.parse.apply(instance, arguments);
		};
		/**
		 * Parses the given JSON schema.
		 * This method does not resolve any JSON references.
		 * It just reads a single file in JSON or YAML format, and parse it as a JavaScript object.
		 *
		 * @param {string} [path] - The file path or URL of the JSON schema
		 * @param {object} [schema] - A JSON schema object. This object will be used instead of reading from `path`.
		 * @param {$RefParserOptions} [options] - Options that determine how the schema is parsed
		 * @param {function} [callback] - An error-first callback. The second parameter is the parsed JSON schema object.
		 * @returns {Promise} - The returned promise resolves with the parsed JSON schema object.
		 */ $RefParser.prototype.parse = function() {
		    var _parse = _asyncToGenerator(function(path, schema, options, callback) {
		        var args, promise, _$err, pathType, $ref, me, result, err;
		        var _arguments = arguments;
		        return __generator(this, function(_state) {
		            switch(_state.label){
		                case 0:
		                    args = (0, _normalizeArgsJs.default)(_arguments);
		                    if (!args.path && !args.schema) {
		                        _$err = (0, _ono.ono)("Expected a file path, URL, or object. Got ".concat(args.path || args.schema));
		                        return [
		                            2,
		                            (0, _callMeMaybe.default)(args.callback, Promise.reject(_$err))
		                        ];
		                    }
		                    // Reset everything
		                    this.schema = null;
		                    this.$refs = new _refsJs.default();
		                    pathType = "http";
		                    if (_urlJs.isFileSystemPath(args.path)) {
		                        args.path = _urlJs.fromFileSystemPath(args.path);
		                        pathType = "file";
		                    }
		                    // Resolve the absolute path of the schema
		                    args.path = _urlJs.resolve(_urlJs.cwd(), args.path);
		                    if (args.schema && typeof args.schema === "object") {
		                        $ref = this.$refs._add(args.path);
		                        $ref.value = args.schema;
		                        $ref.pathType = pathType;
		                        promise = Promise.resolve(args.schema);
		                    } else {
		                        // Parse the schema file/url
		                        promise = (0, _parseJs.default)(args.path, this.$refs, args.options);
		                    }
		                    me = this;
		                    _state.label = 1;
		                case 1:
		                    _state.trys.push([
		                        1,
		                        3,
		                        ,
		                        4
		                    ]);
		                    return [
		                        4,
		                        promise
		                    ];
		                case 2:
		                    result = _state.sent();
		                    if (result !== null && typeof result === "object" && !Buffer.isBuffer(result)) {
		                        me.schema = result;
		                        return [
		                            2,
		                            (0, _callMeMaybe.default)(args.callback, Promise.resolve(me.schema))
		                        ];
		                    } else if (args.options.continueOnError) {
		                        me.schema = null; // it's already set to null at line 79, but let's set it again for the sake of readability
		                        return [
		                            2,
		                            (0, _callMeMaybe.default)(args.callback, Promise.resolve(me.schema))
		                        ];
		                    } else {
		                        throw _ono.ono.syntax('"'.concat(me.$refs._root$Ref.path || result, '" is not a valid JSON Schema'));
		                    }
		                case 3:
		                    err = _state.sent();
		                    if (!args.options.continueOnError || !(0, _errorsJs.isHandledError)(err)) {
		                        return [
		                            2,
		                            (0, _callMeMaybe.default)(args.callback, Promise.reject(err))
		                        ];
		                    }
		                    if (this.$refs._$refs[_urlJs.stripHash(args.path)]) {
		                        this.$refs._$refs[_urlJs.stripHash(args.path)].addError(err);
		                    }
		                    return [
		                        2,
		                        (0, _callMeMaybe.default)(args.callback, Promise.resolve(null))
		                    ];
		                case 4:
		                    return [
		                        2
		                    ];
		            }
		        });
		    });
		    function parse(path, schema, options, callback) {
		        return _parse.apply(this, arguments);
		    }
		    return parse;
		}();
		/**
		 * Parses the given JSON schema and resolves any JSON references, including references in
		 * externally-referenced files.
		 *
		 * @param {string} [path] - The file path or URL of the JSON schema
		 * @param {object} [schema] - A JSON schema object. This object will be used instead of reading from `path`.
		 * @param {$RefParserOptions} [options] - Options that determine how the schema is parsed and resolved
		 * @param {function} [callback]
		 * - An error-first callback. The second parameter is a {@link $Refs} object containing the resolved JSON references
		 *
		 * @returns {Promise}
		 * The returned promise resolves with a {@link $Refs} object containing the resolved JSON references
		 */ $RefParser.resolve = function resolve(path, schema, options, callback) {
		    var Class = this; // eslint-disable-line consistent-this
		    var instance = new Class();
		    return instance.resolve.apply(instance, arguments);
		};
		/**
		 * Parses the given JSON schema and resolves any JSON references, including references in
		 * externally-referenced files.
		 *
		 * @param {string} [path] - The file path or URL of the JSON schema
		 * @param {object} [schema] - A JSON schema object. This object will be used instead of reading from `path`.
		 * @param {$RefParserOptions} [options] - Options that determine how the schema is parsed and resolved
		 * @param {function} [callback]
		 * - An error-first callback. The second parameter is a {@link $Refs} object containing the resolved JSON references
		 *
		 * @returns {Promise}
		 * The returned promise resolves with a {@link $Refs} object containing the resolved JSON references
		 */ $RefParser.prototype.resolve = function() {
		    var _resolve = _asyncToGenerator(function(path, schema, options, callback) {
		        var me, args, err;
		        var _arguments = arguments;
		        return __generator(this, function(_state) {
		            switch(_state.label){
		                case 0:
		                    me = this;
		                    args = (0, _normalizeArgsJs.default)(_arguments);
		                    _state.label = 1;
		                case 1:
		                    _state.trys.push([
		                        1,
		                        4,
		                        ,
		                        5
		                    ]);
		                    return [
		                        4,
		                        this.parse(args.path, args.schema, args.options)
		                    ];
		                case 2:
		                    _state.sent();
		                    return [
		                        4,
		                        (0, _resolveExternalJs.default)(me, args.options)
		                    ];
		                case 3:
		                    _state.sent();
		                    finalize(me);
		                    return [
		                        2,
		                        (0, _callMeMaybe.default)(args.callback, Promise.resolve(me.$refs))
		                    ];
		                case 4:
		                    err = _state.sent();
		                    return [
		                        2,
		                        (0, _callMeMaybe.default)(args.callback, Promise.reject(err))
		                    ];
		                case 5:
		                    return [
		                        2
		                    ];
		            }
		        });
		    });
		    function resolve(path, schema, options, callback) {
		        return _resolve.apply(this, arguments);
		    }
		    return resolve;
		}();
		/**
		 * Parses the given JSON schema, resolves any JSON references, and bundles all external references
		 * into the main JSON schema. This produces a JSON schema that only has *internal* references,
		 * not any *external* references.
		 *
		 * @param {string} [path] - The file path or URL of the JSON schema
		 * @param {object} [schema] - A JSON schema object. This object will be used instead of reading from `path`.
		 * @param {$RefParserOptions} [options] - Options that determine how the schema is parsed, resolved, and dereferenced
		 * @param {function} [callback] - An error-first callback. The second parameter is the bundled JSON schema object
		 * @returns {Promise} - The returned promise resolves with the bundled JSON schema object.
		 */ $RefParser.bundle = function bundle(path, schema, options, callback) {
		    var Class = this; // eslint-disable-line consistent-this
		    var instance = new Class();
		    return instance.bundle.apply(instance, arguments);
		};
		/**
		 * Parses the given JSON schema, resolves any JSON references, and bundles all external references
		 * into the main JSON schema. This produces a JSON schema that only has *internal* references,
		 * not any *external* references.
		 *
		 * @param {string} [path] - The file path or URL of the JSON schema
		 * @param {object} [schema] - A JSON schema object. This object will be used instead of reading from `path`.
		 * @param {$RefParserOptions} [options] - Options that determine how the schema is parsed, resolved, and dereferenced
		 * @param {function} [callback] - An error-first callback. The second parameter is the bundled JSON schema object
		 * @returns {Promise} - The returned promise resolves with the bundled JSON schema object.
		 */ $RefParser.prototype.bundle = function() {
		    var _bundle = _asyncToGenerator(function(path, schema, options, callback) {
		        var me, args, err;
		        var _arguments = arguments;
		        return __generator(this, function(_state) {
		            switch(_state.label){
		                case 0:
		                    me = this;
		                    args = (0, _normalizeArgsJs.default)(_arguments);
		                    _state.label = 1;
		                case 1:
		                    _state.trys.push([
		                        1,
		                        3,
		                        ,
		                        4
		                    ]);
		                    return [
		                        4,
		                        this.resolve(args.path, args.schema, args.options)
		                    ];
		                case 2:
		                    _state.sent();
		                    (0, _bundleJs.default)(me, args.options);
		                    finalize(me);
		                    return [
		                        2,
		                        (0, _callMeMaybe.default)(args.callback, Promise.resolve(me.schema))
		                    ];
		                case 3:
		                    err = _state.sent();
		                    return [
		                        2,
		                        (0, _callMeMaybe.default)(args.callback, Promise.reject(err))
		                    ];
		                case 4:
		                    return [
		                        2
		                    ];
		            }
		        });
		    });
		    function bundle(path, schema, options, callback) {
		        return _bundle.apply(this, arguments);
		    }
		    return bundle;
		}();
		/**
		 * Parses the given JSON schema, resolves any JSON references, and dereferences the JSON schema.
		 * That is, all JSON references are replaced with their resolved values.
		 *
		 * @param {string} [path] - The file path or URL of the JSON schema
		 * @param {object} [schema] - A JSON schema object. This object will be used instead of reading from `path`.
		 * @param {$RefParserOptions} [options] - Options that determine how the schema is parsed, resolved, and dereferenced
		 * @param {function} [callback] - An error-first callback. The second parameter is the dereferenced JSON schema object
		 * @returns {Promise} - The returned promise resolves with the dereferenced JSON schema object.
		 */ $RefParser.dereference = function dereference(path, schema, options, callback) {
		    var Class = this; // eslint-disable-line consistent-this
		    var instance = new Class();
		    return instance.dereference.apply(instance, arguments);
		};
		/**
		 * Parses the given JSON schema, resolves any JSON references, and dereferences the JSON schema.
		 * That is, all JSON references are replaced with their resolved values.
		 *
		 * @param {string} [path] - The file path or URL of the JSON schema
		 * @param {object} [schema] - A JSON schema object. This object will be used instead of reading from `path`.
		 * @param {$RefParserOptions} [options] - Options that determine how the schema is parsed, resolved, and dereferenced
		 * @param {function} [callback] - An error-first callback. The second parameter is the dereferenced JSON schema object
		 * @returns {Promise} - The returned promise resolves with the dereferenced JSON schema object.
		 */ $RefParser.prototype.dereference = function() {
		    var _dereference = _asyncToGenerator(function(path, schema, options, callback) {
		        var me, args, err;
		        var _arguments = arguments;
		        return __generator(this, function(_state) {
		            switch(_state.label){
		                case 0:
		                    me = this;
		                    args = (0, _normalizeArgsJs.default)(_arguments);
		                    _state.label = 1;
		                case 1:
		                    _state.trys.push([
		                        1,
		                        3,
		                        ,
		                        4
		                    ]);
		                    return [
		                        4,
		                        this.resolve(args.path, args.schema, args.options)
		                    ];
		                case 2:
		                    _state.sent();
		                    (0, _dereferenceJs.default)(me, args.options);
		                    finalize(me);
		                    return [
		                        2,
		                        (0, _callMeMaybe.default)(args.callback, Promise.resolve(me.schema))
		                    ];
		                case 3:
		                    err = _state.sent();
		                    return [
		                        2,
		                        (0, _callMeMaybe.default)(args.callback, Promise.reject(err))
		                    ];
		                case 4:
		                    return [
		                        2
		                    ];
		            }
		        });
		    });
		    function dereference(path, schema, options, callback) {
		        return _dereference.apply(this, arguments);
		    }
		    return dereference;
		}();
		function finalize(parser) {
		    var errors = _errorsJs.JSONParserErrorGroup.getParserErrors(parser);
		    if (errors.length > 0) {
		        throw new _errorsJs.JSONParserErrorGroup(parser);
		    }
		}
		var parse$1 = $RefParser.parse.bind($RefParser);
		var resolve = $RefParser.resolve.bind($RefParser);
		var bundle$1 = $RefParser.bundle.bind($RefParser);
		var dereference = $RefParser.dereference.bind($RefParser);
		// CommonJS default export hack
		{
		    module.exports = Object.assign(module.exports.default, module.exports);
		} 
	} (cjs, cjs.exports));

	var cjsExports = cjs.exports;

	var __assign = (commonjsGlobal && commonjsGlobal.__assign) || function () {
	    __assign = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign.apply(this, arguments);
	};
	var __awaiter = (commonjsGlobal && commonjsGlobal.__awaiter) || function (thisArg, _arguments, P, generator) {
	    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
	    return new (P || (P = Promise))(function (resolve, reject) {
	        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
	        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
	        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
	        step((generator = generator.apply(thisArg, _arguments || [])).next());
	    });
	};
	var __generator = (commonjsGlobal && commonjsGlobal.__generator) || function (thisArg, body) {
	    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
	    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
	    function verb(n) { return function (v) { return step([n, v]); }; }
	    function step(op) {
	        if (f) throw new TypeError("Generator is already executing.");
	        while (g && (g = 0, op[0] && (_ = 0)), _) try {
	            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
	            if (y = 0, t) op = [op[0] & 2, t.value];
	            switch (op[0]) {
	                case 0: case 1: t = op; break;
	                case 4: _.label++; return { value: op[1], done: false };
	                case 5: _.label++; y = op[1]; op = [0]; continue;
	                case 7: op = _.ops.pop(); _.trys.pop(); continue;
	                default:
	                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
	                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
	                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
	                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
	                    if (t[2]) _.ops.pop();
	                    _.trys.pop(); continue;
	            }
	            op = body.call(thisArg, _);
	        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
	        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
	    }
	};
	Object.defineProperty(resolver, "__esModule", { value: true });
	resolver.dereference = void 0;
	var $RefParser = cjsExports;
	var utils_1$1 = utils;
	function dereference(schema, _a) {
	    var cwd = _a.cwd, $refOptions = _a.$refOptions;
	    return __awaiter(this, void 0, void 0, function () {
	        var parser, dereferencedPaths, dereferencedSchema;
	        return __generator(this, function (_b) {
	            switch (_b.label) {
	                case 0:
	                    (0, utils_1$1.log)('green', 'dereferencer', 'Dereferencing input schema:', cwd, schema);
	                    parser = new $RefParser();
	                    dereferencedPaths = new WeakMap();
	                    return [4 /*yield*/, parser.dereference(cwd, schema, __assign(__assign({}, $refOptions), { dereference: __assign(__assign({}, $refOptions.dereference), { onDereference: function ($ref, schema) {
	                                    dereferencedPaths.set(schema, $ref);
	                                } }) }))];
	                case 1:
	                    dereferencedSchema = (_b.sent()) // TODO: fix types
	                    ;
	                    return [2 /*return*/, { dereferencedPaths: dereferencedPaths, dereferencedSchema: dereferencedSchema }];
	            }
	        });
	    });
	}
	resolver.dereference = dereference;

	var validator = {};

	Object.defineProperty(validator, "__esModule", { value: true });
	validator.validate = void 0;
	var utils_1 = utils;
	var rules = new Map();
	rules.set('Enum members and tsEnumNames must be of the same length', function (schema) {
	    if (schema.enum && schema.tsEnumNames && schema.enum.length !== schema.tsEnumNames.length) {
	        return false;
	    }
	});
	rules.set('tsEnumNames must be an array of strings', function (schema) {
	    if (schema.tsEnumNames && schema.tsEnumNames.some(function (_) { return typeof _ !== 'string'; })) {
	        return false;
	    }
	});
	rules.set('When both maxItems and minItems are present, maxItems >= minItems', function (schema) {
	    var maxItems = schema.maxItems, minItems = schema.minItems;
	    if (typeof maxItems === 'number' && typeof minItems === 'number') {
	        return maxItems >= minItems;
	    }
	});
	rules.set('When maxItems exists, maxItems >= 0', function (schema) {
	    var maxItems = schema.maxItems;
	    if (typeof maxItems === 'number') {
	        return maxItems >= 0;
	    }
	});
	rules.set('When minItems exists, minItems >= 0', function (schema) {
	    var minItems = schema.minItems;
	    if (typeof minItems === 'number') {
	        return minItems >= 0;
	    }
	});
	rules.set('deprecated must be a boolean', function (schema) {
	    var typeOfDeprecated = typeof schema.deprecated;
	    return typeOfDeprecated === 'boolean' || typeOfDeprecated === 'undefined';
	});
	function validate(schema, filename) {
	    var errors = [];
	    rules.forEach(function (rule, ruleName) {
	        (0, utils_1.traverse)(schema, function (schema, key) {
	            if (rule(schema) === false) {
	                errors.push("Error at key \"".concat(key, "\" in file \"").concat(filename, "\": ").concat(ruleName));
	            }
	            return schema;
	        });
	    });
	    return errors;
	}
	validator.validate = validate;

	var linker = {};

	Object.defineProperty(linker, "__esModule", { value: true });
	linker.link = void 0;
	var JSONSchema_1 = JSONSchema;
	var lodash_1 = lodashExports;
	/**
	 * Traverses over the schema, giving each node a reference to its
	 * parent node. We need this for downstream operations.
	 */
	function link(schema, parent) {
	    if (parent === void 0) { parent = null; }
	    if (!Array.isArray(schema) && !(0, lodash_1.isPlainObject)(schema)) {
	        return schema;
	    }
	    // Handle cycles
	    if (schema.hasOwnProperty(JSONSchema_1.Parent)) {
	        return schema;
	    }
	    // Add a reference to this schema's parent
	    Object.defineProperty(schema, JSONSchema_1.Parent, {
	        enumerable: false,
	        value: parent,
	        writable: false,
	    });
	    // Arrays
	    if (Array.isArray(schema)) {
	        schema.forEach(function (child) { return link(child, schema); });
	    }
	    // Objects
	    for (var key in schema) {
	        link(schema[key], schema);
	    }
	    return schema;
	}
	linker.link = link;

	var optionValidator = {};

	Object.defineProperty(optionValidator, "__esModule", { value: true });
	optionValidator.validateOptions = void 0;
	function validateOptions(_a) {
	    var maxItems = _a.maxItems;
	    if (maxItems !== undefined && maxItems < -1) {
	        throw RangeError("Expected options.maxItems to be >= -1, but was given ".concat(maxItems, "."));
	    }
	}
	optionValidator.validateOptions = validateOptions;

	var hasRequiredSrc;

	function requireSrc () {
		if (hasRequiredSrc) return src;
		hasRequiredSrc = 1;
		(function (exports) {
			var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
			    var extendStatics = function (d, b) {
			        extendStatics = Object.setPrototypeOf ||
			            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
			            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
			        return extendStatics(d, b);
			    };
			    return function (d, b) {
			        if (typeof b !== "function" && b !== null)
			            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
			        extendStatics(d, b);
			        function __() { this.constructor = d; }
			        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
			    };
			})();
			var __assign = (commonjsGlobal && commonjsGlobal.__assign) || function () {
			    __assign = Object.assign || function(t) {
			        for (var s, i = 1, n = arguments.length; i < n; i++) {
			            s = arguments[i];
			            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
			                t[p] = s[p];
			        }
			        return t;
			    };
			    return __assign.apply(this, arguments);
			};
			var __awaiter = (commonjsGlobal && commonjsGlobal.__awaiter) || function (thisArg, _arguments, P, generator) {
			    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
			    return new (P || (P = Promise))(function (resolve, reject) {
			        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
			        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
			        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
			        step((generator = generator.apply(thisArg, _arguments || [])).next());
			    });
			};
			var __generator = (commonjsGlobal && commonjsGlobal.__generator) || function (thisArg, body) {
			    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
			    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
			    function verb(n) { return function (v) { return step([n, v]); }; }
			    function step(op) {
			        if (f) throw new TypeError("Generator is already executing.");
			        while (g && (g = 0, op[0] && (_ = 0)), _) try {
			            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
			            if (y = 0, t) op = [op[0] & 2, t.value];
			            switch (op[0]) {
			                case 0: case 1: t = op; break;
			                case 4: _.label++; return { value: op[1], done: false };
			                case 5: _.label++; y = op[1]; op = [0]; continue;
			                case 7: op = _.ops.pop(); _.trys.pop(); continue;
			                default:
			                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
			                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
			                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
			                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
			                    if (t[2]) _.ops.pop();
			                    _.trys.pop(); continue;
			            }
			            op = body.call(thisArg, _);
			        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
			        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
			    }
			};
			Object.defineProperty(exports, "__esModule", { value: true });
			exports.ValidationError = exports.compile = exports.compileFromFile = exports.DEFAULT_OPTIONS = void 0;
			var fs_1 = require$$0;
			var lodash_1 = lodashExports;
			var path_1 = require$$2;
			var formatter_1 = formatter;
			var generator_1 = requireGenerator();
			var normalizer_1 = normalizer;
			var optimizer_1 = requireOptimizer();
			var parser_1 = parser;
			var resolver_1 = resolver;
			var utils_1 = utils;
			var validator_1 = validator;
			var util_1 = require$$11;
			var linker_1 = linker;
			var optionValidator_1 = optionValidator;
			exports.DEFAULT_OPTIONS = {
			    $refOptions: {},
			    additionalProperties: true,
			    bannerComment: "/* eslint-disable */\n/**\n* This file was automatically generated by json-schema-to-typescript.\n* DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,\n* and run json-schema-to-typescript to regenerate this file.\n*/",
			    cwd: browser$1.cwd(),
			    declareExternallyReferenced: true,
			    enableConstEnums: true,
			    format: true,
			    ignoreMinAndMaxItems: false,
			    maxItems: 20,
			    strictIndexSignatures: false,
			    style: {
			        bracketSpacing: false,
			        printWidth: 120,
			        semi: true,
			        singleQuote: false,
			        tabWidth: 2,
			        trailingComma: 'none',
			        useTabs: false,
			    },
			    unreachableDefinitions: false,
			    unknownAny: true,
			};
			function compileFromFile(filename, options) {
			    if (options === void 0) { options = exports.DEFAULT_OPTIONS; }
			    var contents = (0, utils_1.Try)(function () { return (0, fs_1.readFileSync)(filename); }, function () {
			        throw new ReferenceError("Unable to read file \"".concat(filename, "\""));
			    });
			    var schema = (0, utils_1.Try)(function () { return JSON.parse(contents.toString()); }, function () {
			        throw new TypeError("Error parsing JSON in file \"".concat(filename, "\""));
			    });
			    return compile(schema, (0, utils_1.stripExtension)(filename), __assign({ cwd: (0, path_1.dirname)(filename) }, options));
			}
			exports.compileFromFile = compileFromFile;
			function compile(schema, name, options) {
			    if (options === void 0) { options = {}; }
			    return __awaiter(this, void 0, void 0, function () {
			        function time() {
			            return "(".concat(Date.now() - start, "ms)");
			        }
			        var _options, start, _schema, _a, dereferencedPaths, dereferencedSchema, linked, errors, normalized, parsed, optimized, generated, formatted;
			        return __generator(this, function (_b) {
			            switch (_b.label) {
			                case 0:
			                    (0, optionValidator_1.validateOptions)(options);
			                    _options = (0, lodash_1.merge)({}, exports.DEFAULT_OPTIONS, options);
			                    start = Date.now();
			                    // normalize options
			                    if (!(0, lodash_1.endsWith)(_options.cwd, '/')) {
			                        _options.cwd += '/';
			                    }
			                    _schema = (0, lodash_1.cloneDeep)(schema);
			                    return [4 /*yield*/, (0, resolver_1.dereference)(_schema, _options)];
			                case 1:
			                    _a = _b.sent(), dereferencedPaths = _a.dereferencedPaths, dereferencedSchema = _a.dereferencedSchema;
			                    if (browser$1.env.VERBOSE) {
			                        if ((0, util_1.isDeepStrictEqual)(_schema, dereferencedSchema)) {
			                            (0, utils_1.log)('green', 'dereferencer', time(), ' No change');
			                        }
			                        else {
			                            (0, utils_1.log)('green', 'dereferencer', time(), ' Result:', dereferencedSchema);
			                        }
			                    }
			                    linked = (0, linker_1.link)(dereferencedSchema);
			                    if (browser$1.env.VERBOSE) {
			                        (0, utils_1.log)('green', 'linker', time(), ' No change');
			                    }
			                    errors = (0, validator_1.validate)(linked, name);
			                    if (errors.length) {
			                        errors.forEach(function (_) { return (0, utils_1.error)(_); });
			                        throw new ValidationError();
			                    }
			                    if (browser$1.env.VERBOSE) {
			                        (0, utils_1.log)('green', 'validator', time(), ' No change');
			                    }
			                    normalized = (0, normalizer_1.normalize)(linked, dereferencedPaths, name, _options);
			                    (0, utils_1.log)('yellow', 'normalizer', time(), ' Result:', normalized);
			                    parsed = (0, parser_1.parse)(normalized, _options);
			                    (0, utils_1.log)('blue', 'parser', time(), ' Result:', parsed);
			                    optimized = (0, optimizer_1.optimize)(parsed, _options);
			                    (0, utils_1.log)('cyan', 'optimizer', time(), ' Result:', optimized);
			                    generated = (0, generator_1.generate)(optimized, _options);
			                    (0, utils_1.log)('magenta', 'generator', time(), ' Result:', generated);
			                    formatted = (0, formatter_1.format)(generated, _options);
			                    (0, utils_1.log)('white', 'formatter', time(), ' Result:', formatted);
			                    return [2 /*return*/, formatted];
			            }
			        });
			    });
			}
			exports.compile = compile;
			var ValidationError = /** @class */ (function (_super) {
			    __extends(ValidationError, _super);
			    function ValidationError() {
			        return _super !== null && _super.apply(this, arguments) || this;
			    }
			    return ValidationError;
			}(Error));
			exports.ValidationError = ValidationError;
			
		} (src));
		return src;
	}

	const { compile } = requireSrc();

	const leftInput = document.querySelector('#leftInput textarea');
	const rightOutput = document.querySelector('#rightOutput textarea');
	const errorIcon = document.getElementById('errorIcon');

	leftInput.addEventListener('input', update);

	const localStorageKey = 'json-schema-to-typescript';
	const content = localStorage.getItem(localStorageKey);

	if (content) {
	  leftInput.value = content;
	}

	const options = {
	  declareExternallyReferenced: true,
	  enableConstEnums: true,
	  unreachableDefinitions: false,
	  strictIndexSignatures: false
	};

	// expose options for advance users
	window.options = options;

	console.info("Welcome! If you'd like to play around with more advance options,", "you can mutate the 'options' object assigned to window :)");

	Object.keys(options).forEach(option => {
	  const optionCheckbox = document.getElementById(option);

	  if (!(optionCheckbox instanceof HTMLInputElement)) {
	    console.warn(`"${option}" is missing an config element`);

	    return;
	  }

	  options[option] = optionCheckbox.checked;
	  optionCheckbox.addEventListener('change', () => {
	    options[option] = optionCheckbox.checked;
	    update();
	  });
	});

	// initial compile
	update();

	function update() {
	  localStorage.setItem(localStorageKey, leftInput.value);

	  Promise.resolve()
	    .then(() => JSON.parse(leftInput.value))
	    .then(json => compile(json, 'Demo', options))
	    .then(ts => (rightOutput.value = ts))
	    .then(() => (errorIcon.style.display = 'none'))
	    .catch(e => {
	      console.error(e);

	      errorIcon.style.display = null;
	    });
	}

	document.getElementById('formatButton').addEventListener('click', format);

	function format() {
	  leftInput.value = prettier.format(leftInput.value, { parser: 'json-stringify' });
	}

	return src$1;

})(prettier);
